var Avatar =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (function() {
	  var css           = __webpack_require__(2);
	  var maskImage     = __webpack_require__(7);
	  var samplesImage  = __webpack_require__(8);
	
	  var $             = __webpack_require__(9);
	  var Cropper       = __webpack_require__(10);
	
	  var verbose       = false;
	  var imageSize     = null;
	  var cropper       = null;
	  var $container    = null;
	
	  var template      = `
	    <div id="avatar-cropper">
	      <img id="avatar-cropper-picture" src=""  />
	      <img id="avatar-cropper-mask"    src="`+ maskImage +`"     />
	      <a href="#" class="avatar-cropper-back" id="avatar-cropper-back-upload">&#8249;</a>
	      <a href="#" id="avatar-cropper-crop">Avatar erstellen</a>
	
	      <div id="avatar-cropper-upload">
	        <div id="avatar-cropper-upload-cta">Erstelle Deinen eigenen <b>BTHVN2020 Avatar</b></div>
	        <img src="`+ samplesImage +`" id="avatar-cropper-samples" />
	        <div id="avatar-cropper-upload-button">
	          <input id="avatar-cropper-upload-file" type="file" />
	          <label for="avatar-cropper-upload-file">Lade Dein Bild hoch</label>
	        </div>
	      </div>
	
	      <div id="avatar-cropper-result">
	        <canvas></canvas>
	        <a href="#" class="avatar-cropper-back" id="avatar-cropper-back-crop">&#8249;</a>
	        <a href="#" id="avatar-cropper-download">Avater herunterladen</a>
	      </div>    
	    </div>    
	  `
	
	  function init(parameters) {
	    _setupConfig(Object.assign({}, {
	      verbose:      false,
	      container:    null,
	      imageSize:    634
	    }, parameters));
	    _render();
	  }
	
	  function _setupConfig(opts) {
	    verbose     = opts['verbose'];
	    imageSize   = opts['imageSize'];
	
	    $container  = $(opts['container']);
	  }
	
	  function _setupDom() {
	    $container.html($.parseHTML(template));
	
	    $picture    = $container.find("#avatar-cropper-picture");
	    $mask       = $container.find("#avatar-cropper-mask");
	  }
	
	  function _render() {
	    if(verbose) console.log("Rendering to", $container);
	
	    _setupDom();
	    _setupCropper();
	    _setupListeners();
	  }
	
	  function _setupCropper() {
	    cropper = new Cropper($picture[0], {
	      aspectRatio: 1,
	      guides: false,
	      center: false,
	      crop: function(e) {
	        var cropBox = $(".cropper-crop-box")[0];
	        $mask.attr("style", $(cropBox).attr("style"));
	      }
	    });
	  }
	
	  function _setupListeners() {
	    $("body").on("click", "#avatar-cropper-crop", function(event) {
	      event.preventDefault();
	      _crop();
	    });
	
	    $("body").on("click", "#avatar-cropper-download", function(event) {
	      _download(this);
	    });
	
	    $("body").on("change", "#avatar-cropper-upload-file", function(event) {
	      _upload(this);
	    });
	
	    $("body").on("click", "#avatar-cropper-back-upload", function(event) {
	      event.preventDefault();
	      $("#avatar-cropper-upload").show();
	    });
	
	    $("body").on("click", "#avatar-cropper-back-crop", function(event) {
	      event.preventDefault();
	      $("#avatar-cropper-result").hide();
	      $("#avatar-cropper-download").hide();
	      $("#avatar-cropper-crop").show();
	    });
	  }
	
	  function _upload(uploader) {
	    var file      = uploader.files[0]
	    var imageType = /image.*/;
	    if (!file.type.match(imageType))
	        return;
	    var reader = new FileReader();
	    reader.onload = function(event) {
	      cropper.replace(event.target.result);
	      $("#avatar-cropper-upload").hide();
	    };
	    reader.readAsDataURL(file);
	  }
	
	  function _crop() {
	    var canvas = cropper.getCroppedCanvas({
	      width: imageSize,
	      height: imageSize
	    });
	
	    var ctx = canvas.getContext("2d");
	    var mask = new Image();
	
	    var mask = new Image();
	    mask.onload = function () {
	      ctx.drawImage(mask, 0, 0, imageSize, imageSize);
	      $("#avatar-cropper-result").find("canvas").replaceWith(canvas);
	      $("#avatar-cropper-result").show();
	      $("#avatar-cropper-download").show();
	      $("#avatar-cropper-crop").hide();
	    }
	
	    mask.src = $("#avatar-cropper-mask").attr("src");  
	  }
	
	  function _download(link) {
	    link.href = $("#avatar-cropper-result").find("canvas")[0].toDataURL();
	    link.download = "BTHVN2020-Avatar.png";
	  }
	
	  return {
	    init: init
	  }
	})()

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./avatar.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./avatar.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	exports.i(__webpack_require__(5), "");
	
	// module
	exports.push([module.id, "#avatar-cropper, #avatar-cropper * {\n  box-sizing: border-box;\n}\n\n#avatar-cropper {\n  width: 400px;\n  height: 400px;\n  position: relative;\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 20px;\n  overflow: hidden;\n}\n\n#avatar-cropper-picture {\n  max-width: 100%;\n}\n\n#avatar-cropper-mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1;\n  pointer-events: none;\n}\n\n#avatar-cropper a, #avatar-cropper label {\n  display: block;\n  height: 40px;\n  line-height: 40px;\n  text-transform: uppercase;\n  text-decoration: none;\n  background: #faaf00;\n  border-radius: 3px;\n  text-shadow: 0px 1px 1px rgba(0,0,0,0.15);\n  color: #fff;\n  font-size: 13px;\n  text-align: center;\n  font-family: sans-serif;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: 100;\n  cursor: pointer;\n}\n\n#avatar-cropper-upload {\n  z-index: 100;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: #fff;\n  padding: 40px;\n  text-align: center;\n}\n\n#avatar-cropper-samples {\n  width: 340px;\n  position: absolute;\n  top: 140px;\n  left: 30px;\n}\n\n#avatar-cropper-upload #avatar-cropper-upload-cta {\n  font-size: 28px;\n  line-height: 34px;\n}\n\n#avatar-cropper-upload #avatar-cropper-upload-button {\n  position: absolute;\n  bottom: 10px;\n  left: 10px;\n  right: 10px;\n  height: 40px;\n}\n\n#avatar-cropper-upload #avatar-cropper-upload-button label {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  cursor: pointer;\n}\n\n#avatar-cropper-upload #avatar-cropper-upload-button input {\n  opacity: 0.01;\n  visibility: 0.01;\n}\n\n#avatar-cropper-upload #avatar-cropper-upload-button input:focus { outline: none; }\n\n#avatar-cropper-crop {\n  position: absolute;\n  bottom: 10px;\n  left: 60px;\n  right: 10px;\n}\n\n#avatar-cropper-result {\n  z-index: 110;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: #fff;\n  width: 400px;\n  height: 400px;\n  display: none;\n}\n\n#avatar-cropper-result canvas {\n  width: 400px;\n  height: 400px;\n}\n\n#avatar-cropper-download {\n  position: absolute;\n  bottom: 10px;\n  left: 60px;\n  right: 10px;\n}\n\n#avatar-cropper a.avatar-cropper-back {\n  position: absolute;\n  bottom: 10px;\n  left: 10px;\n  width: 40px;\n  height: 40px;\n  background: #eee;\n  color: #aaa;\n  text-shadow: none;\n  font-size: 30px;\n}", ""]);
	
	// exports


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\n * Cropper.js v0.7.0\n * https://github.com/fengyuanchen/cropperjs\n *\n * Copyright (c) 2015-2016 Fengyuan Chen\n * Released under the MIT license\n *\n * Date: 2016-03-20T06:15:36.234Z\n */.cropper-container{font-size:0;line-height:0;position:relative;-ms-user-select:none;user-select:none;direction:ltr!important;-ms-touch-action:none;touch-action:none;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}.cropper-container img{display:block;width:100%;min-width:0!important;max-width:none!important;height:100%;min-height:0!important;max-height:none!important;image-orientation:0deg!important}.cropper-canvas,.cropper-crop-box,.cropper-drag-box,.cropper-modal,.cropper-wrap-box{position:absolute;top:0;right:0;bottom:0;left:0}.cropper-wrap-box{overflow:hidden}.cropper-drag-box{opacity:0;background-color:#fff}.cropper-modal{opacity:.5;background-color:#000}.cropper-view-box{display:block;overflow:hidden;width:100%;height:100%;outline:#39f solid 1px;outline-color:rgba(51,153,255,.75)}.cropper-dashed{position:absolute;display:block;opacity:.5;border:0 dashed #eee}.cropper-dashed.dashed-h{top:33.33333%;left:0;width:100%;height:33.33333%;border-top-width:1px;border-bottom-width:1px}.cropper-dashed.dashed-v{top:0;left:33.33333%;width:33.33333%;height:100%;border-right-width:1px;border-left-width:1px}.cropper-center{position:absolute;top:50%;left:50%;display:block;width:0;height:0;opacity:.75}.cropper-center:after,.cropper-center:before{position:absolute;display:block;content:' ';background-color:#eee}.cropper-center:before{top:0;left:-3px;width:7px;height:1px}.cropper-center:after{top:-3px;left:0;width:1px;height:7px}.cropper-face,.cropper-line,.cropper-point{position:absolute;display:block;width:100%;height:100%;opacity:.1}.cropper-face{top:0;left:0;background-color:#fff}.cropper-line,.cropper-point{background-color:#39f}.cropper-line.line-e{top:0;right:-3px;width:5px;cursor:e-resize}.cropper-line.line-n{top:-3px;left:0;height:5px;cursor:n-resize}.cropper-line.line-w{top:0;left:-3px;width:5px;cursor:w-resize}.cropper-line.line-s{bottom:-3px;left:0;height:5px;cursor:s-resize}.cropper-point{width:5px;height:5px;opacity:.75}.cropper-point.point-e{top:50%;right:-3px;margin-top:-3px;cursor:e-resize}.cropper-point.point-n{top:-3px;left:50%;margin-left:-3px;cursor:n-resize}.cropper-point.point-w{top:50%;left:-3px;margin-top:-3px;cursor:w-resize}.cropper-point.point-s{bottom:-3px;left:50%;margin-left:-3px;cursor:s-resize}.cropper-point.point-ne{top:-3px;right:-3px;cursor:ne-resize}.cropper-point.point-nw{top:-3px;left:-3px;cursor:nw-resize}.cropper-point.point-sw{bottom:-3px;left:-3px;cursor:sw-resize}.cropper-point.point-se{right:-3px;bottom:-3px;width:20px;height:20px;cursor:se-resize;opacity:1}.cropper-point.point-se:before{position:absolute;right:-50%;bottom:-50%;display:block;width:200%;height:200%;content:' ';opacity:0;background-color:#39f}@media (min-width:768px){.cropper-point.point-se{width:15px;height:15px}}@media (min-width:992px){.cropper-point.point-se{width:10px;height:10px}}@media (min-width:1200px){.cropper-point.point-se{width:5px;height:5px;opacity:.75}}.cropper-invisible{opacity:0}.cropper-bg{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC)}.cropper-hide{position:absolute;display:block;width:0;height:0}.cropper-hidden{display:none!important}.cropper-move{cursor:move}.cropper-crop{cursor:crosshair}.cropper-disabled .cropper-drag-box,.cropper-disabled .cropper-face,.cropper-disabled .cropper-line,.cropper-disabled .cropper-point{cursor:not-allowed}", ""]);
	
	// exports


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.1.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-09-22T22:30Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.1",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
	
			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}
	
			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
	
		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {
	
				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {
	
					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}
	
					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||
	
						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}
	
				return elem.disabled === disabled;
	
			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}
	
			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
	
			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );
	
					if ( elem ) {
	
						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
	
						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}
	
					return [];
				}
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}
	
		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}
	
		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}
	
		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}
	
		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}
	
		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		if ( chainable ) {
			return elems;
		}
	
		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}
	
		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}
	
		if ( data === "false" ) {
			return false;
		}
	
		if ( data === "null" ) {
			return null;
		}
	
		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}
	
		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}
	
		return data;
	}
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;
	
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );
	
		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );
	
		} else {
			ret = [];
		}
	
		if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}
	
		return ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			if ( delegateCount &&
	
				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&
	
				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}
	
				if ( button & 2 ) {
					return 3;
				}
	
				if ( button & 4 ) {
					return 2;
				}
	
				return 0;
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;
	
		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;
	
		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];
	
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
	
				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}
	
					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}
	
					return -1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}
	
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}
	
					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;
	
					if ( index < 0 ) {
						i = max;
	
					} else {
						i = one ? index : 0;
					}
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				if ( val == null ) {
					return null;
				}
	
				if ( jQuery.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}
	
				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	
	return jQuery;
	} );


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Cropper.js v0.7.0
	 * https://github.com/fengyuanchen/cropperjs
	 *
	 * Copyright (c) 2015-2016 Fengyuan Chen
	 * Released under the MIT license
	 *
	 * Date: 2016-03-20T06:15:36.234Z
	 */
	
	(function (global, factory) {
	  if (typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = global.document ? factory(global, true) : function (window) {
	      if (!window.document) {
	        throw new Error('Cropper requires a window with a document');
	      }
	
	      return factory(window);
	    };
	  } else {
	    factory(global);
	  }
	})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
	
	  'use strict';
	
	  // Globals
	  var document = window.document;
	  var location = window.location;
	  var navigator = window.navigator;
	  var ArrayBuffer = window.ArrayBuffer;
	  var Object = window.Object;
	  var Array = window.Array;
	  var String = window.String;
	  var Number = window.Number;
	  var Math = window.Math;
	
	  // Constants
	  var NAMESPACE = 'cropper';
	
	  // Classes
	  var CLASS_MODAL = NAMESPACE + '-modal';
	  var CLASS_HIDE = NAMESPACE + '-hide';
	  var CLASS_HIDDEN = NAMESPACE + '-hidden';
	  var CLASS_INVISIBLE = NAMESPACE + '-invisible';
	  var CLASS_MOVE = NAMESPACE + '-move';
	  var CLASS_CROP = NAMESPACE + '-crop';
	  var CLASS_DISABLED = NAMESPACE + '-disabled';
	  var CLASS_BG = NAMESPACE + '-bg';
	
	  // Events
	  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';
	  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';
	  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';
	  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';
	  var EVENT_DBLCLICK = 'dblclick';
	  var EVENT_RESIZE = 'resize';
	  var EVENT_ERROR = 'error';
	  var EVENT_LOAD = 'load';
	  var EVENT_BUILD = 'build';
	  var EVENT_BUILT = 'built';
	  var EVENT_CROP_START = 'cropstart';
	  var EVENT_CROP_MOVE = 'cropmove';
	  var EVENT_CROP_END = 'cropend';
	  var EVENT_CROP = 'crop';
	  var EVENT_ZOOM = 'zoom';
	
	  // RegExps
	  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;
	  var REGEXP_SUFFIX = /width|height|left|top|marginLeft|marginTop/;
	  var REGEXP_ORIGINS = /^(https?:)\/\/([^\:\/\?#]+):?(\d*)/i;
	  var REGEXP_TRIM = /^\s+(.*)\s+$/;
	  var REGEXP_SPACES = /\s+/;
	  var REGEXP_DATA_URL = /^data\:/;
	  var REGEXP_DATA_URL_HEAD = /^data\:([^\;]+)\;base64,/;
	  var REGEXP_DATA_URL_JPEG = /^data\:image\/jpeg.*;base64,/;
	
	  // Data
	  var DATA_PREVIEW = 'preview';
	  var DATA_ACTION = 'action';
	
	  // Actions
	  var ACTION_EAST = 'e';
	  var ACTION_WEST = 'w';
	  var ACTION_SOUTH = 's';
	  var ACTION_NORTH = 'n';
	  var ACTION_SOUTH_EAST = 'se';
	  var ACTION_SOUTH_WEST = 'sw';
	  var ACTION_NORTH_EAST = 'ne';
	  var ACTION_NORTH_WEST = 'nw';
	  var ACTION_ALL = 'all';
	  var ACTION_CROP = 'crop';
	  var ACTION_MOVE = 'move';
	  var ACTION_ZOOM = 'zoom';
	  var ACTION_NONE = 'none';
	
	  // Supports
	  var SUPPORT_CANVAS = !!document.createElement('canvas').getContext;
	  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);
	
	  // Maths
	  var min = Math.min;
	  var max = Math.max;
	  var abs = Math.abs;
	  var sin = Math.sin;
	  var cos = Math.cos;
	  var sqrt = Math.sqrt;
	  var round = Math.round;
	  var floor = Math.floor;
	  var PI = Math.PI;
	
	  // Utilities
	  var objectProto = Object.prototype;
	  var toString = objectProto.toString;
	  var hasOwnProperty = objectProto.hasOwnProperty;
	  var slice = Array.prototype.slice;
	  var fromCharCode = String.fromCharCode;
	
	  function typeOf(obj) {
	    return toString.call(obj).slice(8, -1).toLowerCase();
	  }
	
	  function isNumber(num) {
	    return typeof num === 'number' && !isNaN(num);
	  }
	
	  function isUndefined(obj) {
	    return typeof obj === 'undefined';
	  }
	
	  function isObject(obj) {
	    return typeof obj === 'object' && obj !== null;
	  }
	
	  function isPlainObject(obj) {
	    var constructor;
	    var prototype;
	
	    if (!isObject(obj)) {
	      return false;
	    }
	
	    try {
	      constructor = obj.constructor;
	      prototype = constructor.prototype;
	
	      return constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
	    } catch (e) {
	      return false;
	    }
	  }
	
	  function isFunction(fn) {
	    return typeOf(fn) === 'function';
	  }
	
	  function isArray(arr) {
	    return Array.isArray ? Array.isArray(arr) : typeOf(arr) === 'array';
	  }
	
	  function toArray(obj, offset) {
	    offset = offset >= 0 ? offset : 0;
	
	    if (Array.from) {
	      return Array.from(obj).slice(offset);
	    }
	
	    return slice.call(obj, offset);
	  }
	
	  function trim(str) {
	    if (typeof str === 'string') {
	      str = str.trim ? str.trim() : str.replace(REGEXP_TRIM, '$1');
	    }
	
	    return str;
	  }
	
	  function each(obj, callback) {
	    var length;
	    var i;
	
	    if (obj && isFunction(callback)) {
	      if (isArray(obj) || isNumber(obj.length)/* array-like */) {
	        for (i = 0, length = obj.length; i < length; i++) {
	          if (callback.call(obj, obj[i], i, obj) === false) {
	            break;
	          }
	        }
	      } else if (isObject(obj)) {
	        for (i in obj) {
	          if (obj.hasOwnProperty(i)) {
	            if (callback.call(obj, obj[i], i, obj) === false) {
	              break;
	            }
	          }
	        }
	      }
	    }
	
	    return obj;
	  }
	
	  function extend(obj) {
	    var args;
	
	    if (arguments.length > 1) {
	      args = toArray(arguments);
	
	      if (Object.assign) {
	        return Object.assign.apply(Object, args);
	      }
	
	      args.shift();
	
	      each(args, function (arg) {
	        each(arg, function (prop, i) {
	          obj[i] = prop;
	        });
	      });
	    }
	
	    return obj;
	  }
	
	  function proxy(fn, context) {
	    var args = toArray(arguments, 2);
	
	    return function () {
	      return fn.apply(context, args.concat(toArray(arguments)));
	    };
	  }
	
	  function setStyle(element, styles) {
	    var style = element.style;
	
	    each(styles, function (value, property) {
	      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
	        value += 'px';
	      }
	
	      style[property] = value;
	    });
	  }
	
	  function hasClass(element, value) {
	    return element.classList ?
	      element.classList.contains(value) :
	      element.className.indexOf(value) > -1;
	  }
	
	  function addClass(element, value) {
	    var className;
	
	    if (isNumber(element.length)) {
	      return each(element, function (elem) {
	        addClass(elem, value);
	      });
	    }
	
	    if (element.classList) {
	      return element.classList.add(value);
	    }
	
	    className = trim(element.className);
	
	    if (!className) {
	      element.className = value;
	    } else if (className.indexOf(value) < 0) {
	      element.className = className + ' ' + value;
	    }
	  }
	
	  function removeClass(element, value) {
	    if (isNumber(element.length)) {
	      return each(element, function (elem) {
	        removeClass(elem, value);
	      });
	    }
	
	    if (element.classList) {
	      return element.classList.remove(value);
	    }
	
	    if (element.className.indexOf(value) >= 0) {
	      element.className = element.className.replace(value, '');
	    }
	  }
	
	  function toggleClass(element, value, added) {
	    if (isNumber(element.length)) {
	      return each(element, function (elem) {
	        toggleClass(elem, value, added);
	      });
	    }
	
	    // IE10-11 doesn't support the second parameter of `classList.toggle`
	    if (added) {
	      addClass(element, value);
	    } else {
	      removeClass(element, value);
	    }
	  }
	
	  function getData(element, name) {
	    return isObject(element[name]) ?
	      element[name] :
	      element.dataset ?
	        element.dataset[name] :
	        element.getAttribute('data-' + name);
	  }
	
	  function setData(element, name, data) {
	    if (isObject(data) && isUndefined(element[name])) {
	      element[name] = data;
	    } else if (element.dataset) {
	      element.dataset[name] = data;
	    } else {
	      element.setAttribute('data-' + name, data);
	    }
	  }
	
	  function removeData(element, name) {
	    if (isObject(element[name])) {
	      delete element[name];
	    } else if (element.dataset) {
	      delete element.dataset[name];
	    } else {
	      element.removeAttribute('data-' + name);
	    }
	  }
	
	  function addListener(element, type, handler, once) {
	    var types = trim(type).split(REGEXP_SPACES);
	    var originalHandler = handler;
	
	    if (types.length > 1) {
	      return each(types, function (type) {
	        addListener(element, type, handler);
	      });
	    }
	
	    if (once) {
	      handler = function () {
	        removeListener(element, type, handler);
	
	        return originalHandler.apply(element, arguments);
	      };
	    }
	
	    if (element.addEventListener) {
	      element.addEventListener(type, handler, false);
	    } else if (element.attachEvent) {
	      element.attachEvent('on' + type, handler);
	    }
	  }
	
	  function removeListener(element, type, handler) {
	    var types = trim(type).split(REGEXP_SPACES);
	
	    if (types.length > 1) {
	      return each(types, function (type) {
	        removeListener(element, type, handler);
	      });
	    }
	
	    if (element.removeEventListener) {
	      element.removeEventListener(type, handler, false);
	    } else if (element.detachEvent) {
	      element.detachEvent('on' + type, handler);
	    }
	  }
	
	  function dispatchEvent(element, type, data) {
	    var event;
	
	    if (element.dispatchEvent) {
	
	      // Event and CustomEvent on IE9-11 are global objects, not constructors
	      if (isFunction(Event) && isFunction(CustomEvent)) {
	        if (isUndefined(data)) {
	          event = new Event(type, {
	            bubbles: true,
	            cancelable: true
	          });
	        } else {
	          event = new CustomEvent(type, {
	            detail: data,
	            bubbles: true,
	            cancelable: true
	          });
	        }
	      } else {
	        // IE9-11
	        if (isUndefined(data)) {
	          event = document.createEvent('Event');
	          event.initEvent(type, true, true);
	        } else {
	          event = document.createEvent('CustomEvent');
	          event.initCustomEvent(type, true, true, data);
	        }
	      }
	
	      // IE9+
	      return element.dispatchEvent(event);
	    } else if (element.fireEvent) {
	
	      // IE6-10 (native events only)
	      return element.fireEvent('on' + type);
	    }
	  }
	
	  function preventDefault(e) {
	    if (e.preventDefault) {
	      e.preventDefault();
	    } else {
	      e.returnValue = false;
	    }
	  }
	
	  function getEvent(event) {
	    var e = event || window.event;
	    var doc;
	
	    // Fix target property (IE8)
	    if (!e.target) {
	      e.target = e.srcElement || document;
	    }
	
	    if (!isNumber(e.pageX)) {
	      doc = document.documentElement;
	      e.pageX = e.clientX + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0);
	      e.pageY = e.clientY + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0);
	    }
	
	    return e;
	  }
	
	  function getOffset(element) {
	    var doc = document.documentElement;
	    var box = element.getBoundingClientRect();
	
	    return {
	      left: box.left + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0),
	      top: box.top + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0)
	    };
	  }
	
	  function getTouchesCenter(touches) {
	    var length = touches.length;
	    var pageX = 0;
	    var pageY = 0;
	
	    if (length) {
	      each(touches, function (touch) {
	        pageX += touch.pageX;
	        pageY += touch.pageY;
	      });
	
	      pageX /= length;
	      pageY /= length;
	    }
	
	    return {
	      pageX: pageX,
	      pageY: pageY
	    };
	  }
	
	  function getByTag(element, tagName) {
	    return element.getElementsByTagName(tagName);
	  }
	
	  function getByClass(element, className) {
	    return element.getElementsByClassName ?
	      element.getElementsByClassName(className) :
	      element.querySelectorAll('.' + className);
	  }
	
	  function createElement(tagName) {
	    return document.createElement(tagName);
	  }
	
	  function appendChild(element, elem) {
	    element.appendChild(elem);
	  }
	
	  function removeChild(element) {
	    if (element.parentNode) {
	      element.parentNode.removeChild(element);
	    }
	  }
	
	  function empty(element) {
	    while (element.firstChild) {
	      element.removeChild(element.firstChild);
	    }
	  }
	
	  function isCrossOriginURL(url) {
	    var parts = url.match(REGEXP_ORIGINS);
	
	    return parts && (
	      parts[1] !== location.protocol ||
	      parts[2] !== location.hostname ||
	      parts[3] !== location.port
	    );
	  }
	
	  function addTimestamp(url) {
	    var timestamp = 'timestamp=' + (new Date()).getTime();
	
	    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);
	  }
	
	  function getImageSize(image, callback) {
	    var newImage;
	
	    // Modern browsers (ignore Safari)
	    if (image.naturalWidth && !IS_SAFARI) {
	      return callback(image.naturalWidth, image.naturalHeight);
	    }
	
	    // IE8: Don't use `new Image()` here
	    newImage = createElement('img');
	
	    newImage.onload = function () {
	      callback(this.width, this.height);
	    };
	
	    newImage.src = image.src;
	  }
	
	  function getTransform(data) {
	    var transforms = [];
	    var rotate = data.rotate;
	    var scaleX = data.scaleX;
	    var scaleY = data.scaleY;
	
	    if (isNumber(rotate)) {
	      transforms.push('rotate(' + rotate + 'deg)');
	    }
	
	    if (isNumber(scaleX) && isNumber(scaleY)) {
	      transforms.push('scale(' + scaleX + ',' + scaleY + ')');
	    }
	
	    return transforms.length ? transforms.join(' ') : 'none';
	  }
	
	  function getRotatedSizes(data, reversed) {
	    var deg = abs(data.degree) % 180;
	    var arc = (deg > 90 ? (180 - deg) : deg) * PI / 180;
	    var sinArc = sin(arc);
	    var cosArc = cos(arc);
	    var width = data.width;
	    var height = data.height;
	    var aspectRatio = data.aspectRatio;
	    var newWidth;
	    var newHeight;
	
	    if (!reversed) {
	      newWidth = width * cosArc + height * sinArc;
	      newHeight = width * sinArc + height * cosArc;
	    } else {
	      newWidth = width / (cosArc + sinArc / aspectRatio);
	      newHeight = newWidth / aspectRatio;
	    }
	
	    return {
	      width: newWidth,
	      height: newHeight
	    };
	  }
	
	  function getSourceCanvas(image, data) {
	    var canvas = createElement('canvas');
	    var context = canvas.getContext('2d');
	    var dstX = 0;
	    var dstY = 0;
	    var dstWidth = data.naturalWidth;
	    var dstHeight = data.naturalHeight;
	    var rotate = data.rotate;
	    var scaleX = data.scaleX;
	    var scaleY = data.scaleY;
	    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);
	    var rotatable = isNumber(rotate) && rotate !== 0;
	    var advanced = rotatable || scalable;
	    var canvasWidth = dstWidth * abs(scaleX || 1);
	    var canvasHeight = dstHeight * abs(scaleY || 1);
	    var translateX;
	    var translateY;
	    var rotated;
	
	    if (scalable) {
	      translateX = canvasWidth / 2;
	      translateY = canvasHeight / 2;
	    }
	
	    if (rotatable) {
	      rotated = getRotatedSizes({
	        width: canvasWidth,
	        height: canvasHeight,
	        degree: rotate
	      });
	
	      canvasWidth = rotated.width;
	      canvasHeight = rotated.height;
	      translateX = canvasWidth / 2;
	      translateY = canvasHeight / 2;
	    }
	
	    canvas.width = canvasWidth;
	    canvas.height = canvasHeight;
	
	    if (advanced) {
	      dstX = -dstWidth / 2;
	      dstY = -dstHeight / 2;
	
	      context.save();
	      context.translate(translateX, translateY);
	    }
	
	    if (rotatable) {
	      context.rotate(rotate * PI / 180);
	    }
	
	    // Should call `scale` after rotated
	    if (scalable) {
	      context.scale(scaleX, scaleY);
	    }
	
	    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));
	
	    if (advanced) {
	      context.restore();
	    }
	
	    return canvas;
	  }
	
	  function getStringFromCharCode(dataView, start, length) {
	    var str = '';
	    var i = start;
	
	    for (length += start; i < length; i++) {
	      str += fromCharCode(dataView.getUint8(i));
	    }
	
	    return str;
	  }
	
	  function getOrientation(arrayBuffer) {
	    var dataView = new DataView(arrayBuffer);
	    var length = dataView.byteLength;
	    var orientation;
	    var exifIDCode;
	    var tiffOffset;
	    var firstIFDOffset;
	    var littleEndian;
	    var endianness;
	    var app1Start;
	    var ifdStart;
	    var offset;
	    var i;
	
	    // Only handle JPEG image (start by 0xFFD8)
	    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
	      offset = 2;
	
	      while (offset < length) {
	        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
	          app1Start = offset;
	          break;
	        }
	
	        offset++;
	      }
	    }
	
	    if (app1Start) {
	      exifIDCode = app1Start + 4;
	      tiffOffset = app1Start + 10;
	
	      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
	        endianness = dataView.getUint16(tiffOffset);
	        littleEndian = endianness === 0x4949;
	
	        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {
	          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
	            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
	
	            if (firstIFDOffset >= 0x00000008) {
	              ifdStart = tiffOffset + firstIFDOffset;
	            }
	          }
	        }
	      }
	    }
	
	    if (ifdStart) {
	      length = dataView.getUint16(ifdStart, littleEndian);
	
	      for (i = 0; i < length; i++) {
	        offset = ifdStart + i * 12 + 2;
	
	        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {
	
	          // 8 is the offset of the current tag's value
	          offset += 8;
	
	          // Get the original orientation value
	          orientation = dataView.getUint16(offset, littleEndian);
	
	          // Override the orientation with its default value for Safari
	          if (IS_SAFARI) {
	            dataView.setUint16(offset, 1, littleEndian);
	          }
	
	          break;
	        }
	      }
	    }
	
	    return orientation;
	  }
	
	  function dataURLToArrayBuffer(dataURL) {
	    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
	    var binary = atob(base64);
	    var length = binary.length;
	    var arrayBuffer = new ArrayBuffer(length);
	    var dataView = new Uint8Array(arrayBuffer);
	    var i;
	
	    for (i = 0; i < length; i++) {
	      dataView[i] = binary.charCodeAt(i);
	    }
	
	    return arrayBuffer;
	  }
	
	  // Only available for JPEG image
	  function arrayBufferToDataURL(arrayBuffer) {
	    var dataView = new Uint8Array(arrayBuffer);
	    var length = dataView.length;
	    var base64 = '';
	    var i;
	
	    for (i = 0; i < length; i++) {
	      base64 += fromCharCode(dataView[i]);
	    }
	
	    return 'data:image/jpeg;base64,' + btoa(base64);
	  }
	
	  function Cropper(element, options) {
	    var _this = this;
	
	    _this.element = element;
	    _this.options = extend({}, Cropper.DEFAULTS, isPlainObject(options) && options);
	    _this.ready = false;
	    _this.built = false;
	    _this.complete = false;
	    _this.rotated = false;
	    _this.cropped = false;
	    _this.disabled = false;
	    _this.replaced = false;
	    _this.limited = false;
	    _this.wheeling = false;
	    _this.isImg = false;
	    _this.originalUrl = '';
	    _this.canvasData = null;
	    _this.cropBoxData = null;
	    _this.previews = null;
	    _this.init();
	  }
	
	  Cropper.prototype = {
	    constructor: Cropper,
	
	    init: function () {
	      var _this = this;
	      var element = _this.element;
	      var tagName = element.tagName.toLowerCase();
	      var url;
	
	      if (getData(element, NAMESPACE)) {
	        return;
	      }
	
	      setData(element, NAMESPACE, _this);
	
	      if (tagName === 'img') {
	        _this.isImg = true;
	
	        // e.g.: "img/picture.jpg"
	        _this.originalUrl = url = element.getAttribute('src');
	
	        // Stop when it's a blank image
	        if (!url) {
	          return;
	        }
	
	        // e.g.: "http://example.com/img/picture.jpg"
	        url = element.src;
	      } else if (tagName === 'canvas' && SUPPORT_CANVAS) {
	        url = element.toDataURL();
	      }
	
	      _this.load(url);
	    },
	
	    load: function (url) {
	      var _this = this;
	      var options = _this.options;
	      var element = _this.element;
	      var xhr;
	
	      if (!url) {
	        return;
	      }
	
	      if (isFunction(options.build)) {
	        addListener(element, EVENT_BUILD, options.build, true);
	      }
	
	      if (dispatchEvent(element, EVENT_BUILD) === false) {
	        return;
	      }
	
	      _this.url = url;
	      _this.imageData = {};
	
	      if (!options.checkOrientation || !ArrayBuffer) {
	        return _this.clone();
	      }
	
	      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari
	      if (REGEXP_DATA_URL.test(url)) {
	        return REGEXP_DATA_URL_JPEG.test(url) ?
	          _this.read(dataURLToArrayBuffer(url)) :
	          _this.clone();
	      }
	
	      xhr = new XMLHttpRequest();
	
	      xhr.onerror = xhr.onabort = function () {
	        _this.clone();
	      };
	
	      xhr.onload = function () {
	        _this.read(this.response);
	      };
	
	      xhr.open('get', url);
	      xhr.responseType = 'arraybuffer';
	      xhr.send();
	    },
	
	    read: function (arrayBuffer) {
	      var _this = this;
	      var options = _this.options;
	      var orientation = getOrientation(arrayBuffer);
	      var imageData = _this.imageData;
	      var rotate;
	      var scaleX;
	      var scaleY;
	
	      if (orientation > 1) {
	        _this.url = arrayBufferToDataURL(arrayBuffer);
	
	        switch (orientation) {
	
	          // flip horizontal
	          case 2:
	            scaleX = -1;
	            break;
	
	          // rotate left 180
	          case 3:
	            rotate = -180;
	            break;
	
	          // flip vertical
	          case 4:
	            scaleY = -1;
	            break;
	
	          // flip vertical + rotate right 90
	          case 5:
	            rotate = 90;
	            scaleY = -1;
	            break;
	
	          // rotate right 90
	          case 6:
	            rotate = 90;
	            break;
	
	          // flip horizontal + rotate right 90
	          case 7:
	            rotate = 90;
	            scaleX = -1;
	            break;
	
	          // rotate left 90
	          case 8:
	            rotate = -90;
	            break;
	        }
	      }
	
	      if (options.rotatable) {
	        imageData.rotate = rotate;
	      }
	
	      if (options.scalable) {
	        imageData.scaleX = scaleX;
	        imageData.scaleY = scaleY;
	      }
	
	      _this.clone();
	    },
	
	    clone: function () {
	      var _this = this;
	      var element = _this.element;
	      var url = _this.url;
	      var crossOrigin;
	      var crossOriginUrl;
	      var image;
	      var start;
	      var stop;
	
	      if (_this.options.checkCrossOrigin && isCrossOriginURL(url)) {
	        crossOrigin = element.crossOrigin;
	
	        if (crossOrigin) {
	          crossOriginUrl = url;
	        } else {
	          crossOrigin = 'anonymous';
	
	          // Bust cache when there is not a "crossOrigin" property
	          crossOriginUrl = addTimestamp(url);
	        }
	      }
	
	      _this.crossOrigin = crossOrigin;
	      _this.crossOriginUrl = crossOriginUrl;
	      image = createElement('img');
	
	      if (crossOrigin) {
	        image.crossOrigin = crossOrigin;
	      }
	
	      image.src = crossOriginUrl || url;
	      _this.image = image;
	      _this._start = start = proxy(_this.start, _this);
	      _this._stop = stop = proxy(_this.stop, _this);
	
	      if (_this.isImg) {
	        if (element.complete) {
	          _this.start();
	        } else {
	          addListener(element, EVENT_LOAD, start);
	        }
	      } else {
	        addListener(image, EVENT_LOAD, start);
	        addListener(image, EVENT_ERROR, stop);
	        addClass(image, CLASS_HIDE);
	        element.parentNode.insertBefore(image, element.nextSibling);
	      }
	    },
	
	    start: function (event) {
	      var _this = this;
	      var image = _this.isImg ? _this.element : _this.image;
	
	      if (event) {
	        removeListener(image, EVENT_LOAD, _this._start);
	        removeListener(image, EVENT_ERROR, _this._stop);
	      }
	
	      getImageSize(image, function (naturalWidth, naturalHeight) {
	        extend(_this.imageData, {
	          naturalWidth: naturalWidth,
	          naturalHeight: naturalHeight,
	          aspectRatio: naturalWidth / naturalHeight
	        });
	
	        _this.ready = true;
	        _this.build();
	      });
	    },
	
	    stop: function () {
	      var _this = this;
	      var image = _this.image;
	
	      removeListener(image, EVENT_LOAD, _this._start);
	      removeListener(image, EVENT_ERROR, _this._stop);
	
	      removeChild(image);
	      _this.image = null;
	    },
	
	    build: function () {
	      var _this = this;
	      var options = _this.options;
	      var element = _this.element;
	      var image = _this.image;
	      var container;
	      var template;
	      var cropper;
	      var canvas;
	      var dragBox;
	      var cropBox;
	      var face;
	
	      if (!_this.ready) {
	        return;
	      }
	
	      // Unbuild first when replace
	      if (_this.built) {
	        _this.unbuild();
	      }
	
	      template = createElement('div');
	      template.innerHTML = Cropper.TEMPLATE;
	
	      // Create cropper elements
	      _this.container = container = element.parentNode;
	      _this.cropper = cropper = getByClass(template, 'cropper-container')[0];
	      _this.canvas = canvas = getByClass(cropper, 'cropper-canvas')[0];
	      _this.dragBox = dragBox = getByClass(cropper, 'cropper-drag-box')[0];
	      _this.cropBox = cropBox = getByClass(cropper, 'cropper-crop-box')[0];
	      _this.viewBox = getByClass(cropper, 'cropper-view-box')[0];
	      _this.face = face = getByClass(cropBox, 'cropper-face')[0];
	
	      appendChild(canvas, image);
	
	      // Hide the original image
	      addClass(element, CLASS_HIDDEN);
	
	      // Inserts the cropper after to the current image
	      container.insertBefore(cropper, element.nextSibling);
	
	      // Show the image if is hidden
	      if (!_this.isImg) {
	        removeClass(image, CLASS_HIDE);
	      }
	
	      _this.initPreview();
	      _this.bind();
	
	      options.aspectRatio = max(0, options.aspectRatio) || NaN;
	      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;
	
	      if (options.autoCrop) {
	        _this.cropped = true;
	
	        if (options.modal) {
	          addClass(dragBox, CLASS_MODAL);
	        }
	      } else {
	        addClass(cropBox, CLASS_HIDDEN);
	      }
	
	      if (!options.guides) {
	        addClass(getByClass(cropBox, 'cropper-dashed'), CLASS_HIDDEN);
	      }
	
	      if (!options.center) {
	        addClass(getByClass(cropBox, 'cropper-center'), CLASS_HIDDEN);
	      }
	
	      if (options.background) {
	        addClass(cropper, CLASS_BG);
	      }
	
	      if (!options.highlight) {
	        addClass(face, CLASS_INVISIBLE);
	      }
	
	      if (options.cropBoxMovable) {
	        addClass(face, CLASS_MOVE);
	        setData(face, DATA_ACTION, ACTION_ALL);
	      }
	
	      if (!options.cropBoxResizable) {
	        addClass(getByClass(cropBox, 'cropper-line'), CLASS_HIDDEN);
	        addClass(getByClass(cropBox, 'cropper-point'), CLASS_HIDDEN);
	      }
	
	      _this.setDragMode(options.dragMode);
	      _this.render();
	      _this.built = true;
	      _this.setData(options.data);
	
	      // Call the built asynchronously to keep "image.cropper" is defined
	      setTimeout(function () {
	        if (isFunction(options.built)) {
	          addListener(element, EVENT_BUILT, options.built, true);
	        }
	
	        dispatchEvent(element, EVENT_BUILT);
	        dispatchEvent(element, EVENT_CROP, _this.getData());
	
	        _this.complete = true;
	      }, 0);
	    },
	
	    unbuild: function () {
	      var _this = this;
	
	      if (!_this.built) {
	        return;
	      }
	
	      _this.built = false;
	      _this.complete = false;
	      _this.initialImageData = null;
	
	      // Clear `initialCanvasData` is necessary when replace
	      _this.initialCanvasData = null;
	      _this.initialCropBoxData = null;
	      _this.containerData = null;
	      _this.canvasData = null;
	
	      // Clear `cropBoxData` is necessary when replace
	      _this.cropBoxData = null;
	      _this.unbind();
	
	      _this.resetPreview();
	      _this.previews = null;
	
	      _this.viewBox = null;
	      _this.cropBox = null;
	      _this.dragBox = null;
	      _this.canvas = null;
	      _this.container = null;
	
	      removeChild(_this.cropper);
	      _this.cropper = null;
	    },
	
	    render: function () {
	      var _this = this;
	
	      _this.initContainer();
	      _this.initCanvas();
	      _this.initCropBox();
	
	      _this.renderCanvas();
	
	      if (_this.cropped) {
	        _this.renderCropBox();
	      }
	    },
	
	    initContainer: function () {
	      var _this = this;
	      var options = _this.options;
	      var element = _this.element;
	      var container = _this.container;
	      var cropper = _this.cropper;
	      var containerData;
	
	      addClass(cropper, CLASS_HIDDEN);
	      removeClass(element, CLASS_HIDDEN);
	
	      _this.containerData = containerData = {
	        width: max(
	          container.offsetWidth,
	          Number(options.minContainerWidth) || 200
	        ),
	        height: max(
	          container.offsetHeight,
	          Number(options.minContainerHeight) || 100
	        )
	      };
	
	      setStyle(cropper, {
	        width: containerData.width,
	        height: containerData.height
	      });
	
	      addClass(element, CLASS_HIDDEN);
	      removeClass(cropper, CLASS_HIDDEN);
	    },
	
	    // Canvas (image wrapper)
	    initCanvas: function () {
	      var _this = this;
	      var viewMode = _this.options.viewMode;
	      var containerData = _this.containerData;
	      var imageData = _this.imageData;
	      var rotated = abs(imageData.rotate) === 90;
	      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
	      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
	      var aspectRatio = naturalWidth / naturalHeight;
	      var canvasWidth = containerData.width;
	      var canvasHeight = containerData.height;
	      var canvasData;
	
	      if (containerData.height * aspectRatio > containerData.width) {
	        if (viewMode === 3) {
	          canvasWidth = containerData.height * aspectRatio;
	        } else {
	          canvasHeight = containerData.width / aspectRatio;
	        }
	      } else {
	        if (viewMode === 3) {
	          canvasHeight = containerData.width / aspectRatio;
	        } else {
	          canvasWidth = containerData.height * aspectRatio;
	        }
	      }
	
	      canvasData = {
	        naturalWidth: naturalWidth,
	        naturalHeight: naturalHeight,
	        aspectRatio: aspectRatio,
	        width: canvasWidth,
	        height: canvasHeight
	      };
	
	      canvasData.oldLeft = canvasData.left = (containerData.width - canvasWidth) / 2;
	      canvasData.oldTop = canvasData.top = (containerData.height - canvasHeight) / 2;
	
	      _this.canvasData = canvasData;
	      _this.limited = (viewMode === 1 || viewMode === 2);
	      _this.limitCanvas(true, true);
	      _this.initialImageData = extend({}, imageData);
	      _this.initialCanvasData = extend({}, canvasData);
	    },
	
	    limitCanvas: function (sizeLimited, positionLimited) {
	      var _this = this;
	      var options = _this.options;
	      var viewMode = options.viewMode;
	      var containerData = _this.containerData;
	      var canvasData = _this.canvasData;
	      var aspectRatio = canvasData.aspectRatio;
	      var cropBoxData = _this.cropBoxData;
	      var cropped = _this.cropped && cropBoxData;
	      var minCanvasWidth;
	      var minCanvasHeight;
	      var newCanvasLeft;
	      var newCanvasTop;
	
	      if (sizeLimited) {
	        minCanvasWidth = Number(options.minCanvasWidth) || 0;
	        minCanvasHeight = Number(options.minCanvasHeight) || 0;
	
	        if (viewMode > 1) {
	          minCanvasWidth = max(minCanvasWidth, containerData.width);
	          minCanvasHeight = max(minCanvasHeight, containerData.height);
	
	          if (viewMode === 3) {
	            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
	              minCanvasWidth = minCanvasHeight * aspectRatio;
	            } else {
	              minCanvasHeight = minCanvasWidth / aspectRatio;
	            }
	          }
	        } else if (viewMode > 0) {
	          if (minCanvasWidth) {
	            minCanvasWidth = max(
	              minCanvasWidth,
	              cropped ? cropBoxData.width : 0
	            );
	          } else if (minCanvasHeight) {
	            minCanvasHeight = max(
	              minCanvasHeight,
	              cropped ? cropBoxData.height : 0
	            );
	          } else if (cropped) {
	            minCanvasWidth = cropBoxData.width;
	            minCanvasHeight = cropBoxData.height;
	
	            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
	              minCanvasWidth = minCanvasHeight * aspectRatio;
	            } else {
	              minCanvasHeight = minCanvasWidth / aspectRatio;
	            }
	          }
	        }
	
	        if (minCanvasWidth && minCanvasHeight) {
	          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
	            minCanvasHeight = minCanvasWidth / aspectRatio;
	          } else {
	            minCanvasWidth = minCanvasHeight * aspectRatio;
	          }
	        } else if (minCanvasWidth) {
	          minCanvasHeight = minCanvasWidth / aspectRatio;
	        } else if (minCanvasHeight) {
	          minCanvasWidth = minCanvasHeight * aspectRatio;
	        }
	
	        canvasData.minWidth = minCanvasWidth;
	        canvasData.minHeight = minCanvasHeight;
	        canvasData.maxWidth = Infinity;
	        canvasData.maxHeight = Infinity;
	      }
	
	      if (positionLimited) {
	        if (viewMode) {
	          newCanvasLeft = containerData.width - canvasData.width;
	          newCanvasTop = containerData.height - canvasData.height;
	
	          canvasData.minLeft = min(0, newCanvasLeft);
	          canvasData.minTop = min(0, newCanvasTop);
	          canvasData.maxLeft = max(0, newCanvasLeft);
	          canvasData.maxTop = max(0, newCanvasTop);
	
	          if (cropped && _this.limited) {
	            canvasData.minLeft = min(
	              cropBoxData.left,
	              cropBoxData.left + cropBoxData.width - canvasData.width
	            );
	            canvasData.minTop = min(
	              cropBoxData.top,
	              cropBoxData.top + cropBoxData.height - canvasData.height
	            );
	            canvasData.maxLeft = cropBoxData.left;
	            canvasData.maxTop = cropBoxData.top;
	
	            if (viewMode === 2) {
	              if (canvasData.width >= containerData.width) {
	                canvasData.minLeft = min(0, newCanvasLeft);
	                canvasData.maxLeft = max(0, newCanvasLeft);
	              }
	
	              if (canvasData.height >= containerData.height) {
	                canvasData.minTop = min(0, newCanvasTop);
	                canvasData.maxTop = max(0, newCanvasTop);
	              }
	            }
	          }
	        } else {
	          canvasData.minLeft = -canvasData.width;
	          canvasData.minTop = -canvasData.height;
	          canvasData.maxLeft = containerData.width;
	          canvasData.maxTop = containerData.height;
	        }
	      }
	    },
	
	    renderCanvas: function (changed) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	      var imageData = _this.imageData;
	      var rotate = imageData.rotate;
	      var aspectRatio;
	      var rotatedData;
	
	      if (_this.rotated) {
	        _this.rotated = false;
	
	        // Computes rotated sizes with image sizes
	        rotatedData = getRotatedSizes({
	          width: imageData.width,
	          height: imageData.height,
	          degree: rotate
	        });
	
	        aspectRatio = rotatedData.width / rotatedData.height;
	
	        if (aspectRatio !== canvasData.aspectRatio) {
	          canvasData.left -= (rotatedData.width - canvasData.width) / 2;
	          canvasData.top -= (rotatedData.height - canvasData.height) / 2;
	          canvasData.width = rotatedData.width;
	          canvasData.height = rotatedData.height;
	          canvasData.aspectRatio = aspectRatio;
	          canvasData.naturalWidth = imageData.naturalWidth;
	          canvasData.naturalHeight = imageData.naturalHeight;
	
	          // Computes rotated sizes with natural image sizes
	          if (rotate % 180) {
	            rotatedData = getRotatedSizes({
	              width: imageData.naturalWidth,
	              height: imageData.naturalHeight,
	              degree: rotate
	            });
	
	            canvasData.naturalWidth = rotatedData.width;
	            canvasData.naturalHeight = rotatedData.height;
	          }
	
	          _this.limitCanvas(true, false);
	        }
	      }
	
	      if (canvasData.width > canvasData.maxWidth ||
	        canvasData.width < canvasData.minWidth) {
	        canvasData.left = canvasData.oldLeft;
	      }
	
	      if (canvasData.height > canvasData.maxHeight ||
	        canvasData.height < canvasData.minHeight) {
	        canvasData.top = canvasData.oldTop;
	      }
	
	      canvasData.width = min(
	        max(canvasData.width, canvasData.minWidth),
	        canvasData.maxWidth
	      );
	      canvasData.height = min(
	        max(canvasData.height, canvasData.minHeight),
	        canvasData.maxHeight
	      );
	
	      _this.limitCanvas(false, true);
	
	      canvasData.oldLeft = canvasData.left = min(
	        max(canvasData.left, canvasData.minLeft),
	        canvasData.maxLeft
	      );
	      canvasData.oldTop = canvasData.top = min(
	        max(canvasData.top, canvasData.minTop),
	        canvasData.maxTop
	      );
	
	      setStyle(_this.canvas, {
	        width: canvasData.width,
	        height: canvasData.height,
	        left: canvasData.left,
	        top: canvasData.top
	      });
	
	      _this.renderImage();
	
	      if (_this.cropped && _this.limited) {
	        _this.limitCropBox(true, true);
	      }
	
	      if (changed) {
	        _this.output();
	      }
	    },
	
	    renderImage: function (changed) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	      var imageData = _this.imageData;
	      var newImageData;
	      var reversedData;
	      var reversedWidth;
	      var reversedHeight;
	      var transform;
	
	      if (imageData.rotate) {
	        reversedData = getRotatedSizes({
	          width: canvasData.width,
	          height: canvasData.height,
	          degree: imageData.rotate,
	          aspectRatio: imageData.aspectRatio
	        }, true);
	
	        reversedWidth = reversedData.width;
	        reversedHeight = reversedData.height;
	
	        newImageData = {
	          width: reversedWidth,
	          height: reversedHeight,
	          left: (canvasData.width - reversedWidth) / 2,
	          top: (canvasData.height - reversedHeight) / 2
	        };
	      }
	
	      extend(imageData, newImageData || {
	        width: canvasData.width,
	        height: canvasData.height,
	        left: 0,
	        top: 0
	      });
	
	      transform = getTransform(imageData);
	
	      setStyle(_this.image, {
	        width: imageData.width,
	        height: imageData.height,
	        marginLeft: imageData.left,
	        marginTop: imageData.top,
	        WebkitTransform: transform,
	        msTransform: transform,
	        transform: transform
	      });
	
	      if (changed) {
	        _this.output();
	      }
	    },
	
	    initCropBox: function () {
	      var _this = this;
	      var options = _this.options;
	      var aspectRatio = options.aspectRatio;
	      var autoCropArea = Number(options.autoCropArea) || 0.8;
	      var canvasData = _this.canvasData;
	      var cropBoxData = {
	            width: canvasData.width,
	            height: canvasData.height
	          };
	
	      if (aspectRatio) {
	        if (canvasData.height * aspectRatio > canvasData.width) {
	          cropBoxData.height = cropBoxData.width / aspectRatio;
	        } else {
	          cropBoxData.width = cropBoxData.height * aspectRatio;
	        }
	      }
	
	      _this.cropBoxData = cropBoxData;
	      _this.limitCropBox(true, true);
	
	      // Initialize auto crop area
	      cropBoxData.width = min(
	        max(cropBoxData.width, cropBoxData.minWidth),
	        cropBoxData.maxWidth
	      );
	      cropBoxData.height = min(
	        max(cropBoxData.height, cropBoxData.minHeight),
	        cropBoxData.maxHeight
	      );
	
	      // The width/height of auto crop area must large than "minWidth/Height"
	      cropBoxData.width = max(
	        cropBoxData.minWidth,
	        cropBoxData.width * autoCropArea
	      );
	      cropBoxData.height = max(
	        cropBoxData.minHeight,
	        cropBoxData.height * autoCropArea
	      );
	      cropBoxData.oldLeft = cropBoxData.left = (
	        canvasData.left + (canvasData.width - cropBoxData.width) / 2
	      );
	      cropBoxData.oldTop = cropBoxData.top = (
	        canvasData.top + (canvasData.height - cropBoxData.height) / 2
	      );
	
	      _this.initialCropBoxData = extend({}, cropBoxData);
	    },
	
	    limitCropBox: function (sizeLimited, positionLimited) {
	      var _this = this;
	      var options = _this.options;
	      var aspectRatio = options.aspectRatio;
	      var containerData = _this.containerData;
	      var canvasData = _this.canvasData;
	      var cropBoxData = _this.cropBoxData;
	      var limited = _this.limited;
	      var minCropBoxWidth;
	      var minCropBoxHeight;
	      var maxCropBoxWidth;
	      var maxCropBoxHeight;
	
	      if (sizeLimited) {
	        minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
	        minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
	
	        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height
	        minCropBoxWidth = min(minCropBoxWidth, containerData.width);
	        minCropBoxHeight = min(minCropBoxHeight, containerData.height);
	        maxCropBoxWidth = min(
	          containerData.width,
	          limited ? canvasData.width : containerData.width
	        );
	        maxCropBoxHeight = min(
	          containerData.height,
	          limited ? canvasData.height : containerData.height
	        );
	
	        if (aspectRatio) {
	          if (minCropBoxWidth && minCropBoxHeight) {
	            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
	              minCropBoxHeight = minCropBoxWidth / aspectRatio;
	            } else {
	              minCropBoxWidth = minCropBoxHeight * aspectRatio;
	            }
	          } else if (minCropBoxWidth) {
	            minCropBoxHeight = minCropBoxWidth / aspectRatio;
	          } else if (minCropBoxHeight) {
	            minCropBoxWidth = minCropBoxHeight * aspectRatio;
	          }
	
	          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
	            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
	          } else {
	            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
	          }
	        }
	
	        // The minWidth/Height must be less than maxWidth/Height
	        cropBoxData.minWidth = min(minCropBoxWidth, maxCropBoxWidth);
	        cropBoxData.minHeight = min(minCropBoxHeight, maxCropBoxHeight);
	        cropBoxData.maxWidth = maxCropBoxWidth;
	        cropBoxData.maxHeight = maxCropBoxHeight;
	      }
	
	      if (positionLimited) {
	        if (limited) {
	          cropBoxData.minLeft = max(0, canvasData.left);
	          cropBoxData.minTop = max(0, canvasData.top);
	          cropBoxData.maxLeft = min(
	            containerData.width,
	            canvasData.left + canvasData.width
	          ) - cropBoxData.width;
	          cropBoxData.maxTop = min(
	            containerData.height,
	            canvasData.top + canvasData.height
	          ) - cropBoxData.height;
	        } else {
	          cropBoxData.minLeft = 0;
	          cropBoxData.minTop = 0;
	          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
	          cropBoxData.maxTop = containerData.height - cropBoxData.height;
	        }
	      }
	    },
	
	    renderCropBox: function () {
	      var _this = this;
	      var options = _this.options;
	      var containerData = _this.containerData;
	      var cropBoxData = _this.cropBoxData;
	
	      if (cropBoxData.width > cropBoxData.maxWidth ||
	        cropBoxData.width < cropBoxData.minWidth) {
	        cropBoxData.left = cropBoxData.oldLeft;
	      }
	
	      if (cropBoxData.height > cropBoxData.maxHeight ||
	        cropBoxData.height < cropBoxData.minHeight) {
	        cropBoxData.top = cropBoxData.oldTop;
	      }
	
	      cropBoxData.width = min(
	        max(cropBoxData.width, cropBoxData.minWidth),
	        cropBoxData.maxWidth
	      );
	      cropBoxData.height = min(
	        max(cropBoxData.height, cropBoxData.minHeight),
	        cropBoxData.maxHeight
	      );
	
	      _this.limitCropBox(false, true);
	
	      cropBoxData.oldLeft = cropBoxData.left = min(
	        max(cropBoxData.left, cropBoxData.minLeft),
	        cropBoxData.maxLeft
	      );
	      cropBoxData.oldTop = cropBoxData.top = min(
	        max(cropBoxData.top, cropBoxData.minTop),
	        cropBoxData.maxTop
	      );
	
	      if (options.movable && options.cropBoxMovable) {
	
	        // Turn to move the canvas when the crop box is equal to the container
	        setData(_this.face, DATA_ACTION, cropBoxData.width === containerData.width &&
	          cropBoxData.height === containerData.height ? ACTION_MOVE : ACTION_ALL);
	      }
	
	      setStyle(_this.cropBox, {
	        width: cropBoxData.width,
	        height: cropBoxData.height,
	        left: cropBoxData.left,
	        top: cropBoxData.top
	      });
	
	      if (_this.cropped && _this.limited) {
	        _this.limitCanvas(true, true);
	      }
	
	      if (!_this.disabled) {
	        _this.output();
	      }
	    },
	
	    output: function () {
	      var _this = this;
	
	      _this.preview();
	
	      if (_this.complete) {
	        dispatchEvent(_this.element, EVENT_CROP, _this.getData());
	      }
	    },
	
	    initPreview: function () {
	      var _this = this;
	      var preview = _this.options.preview;
	      var image = createElement('img');
	      var crossOrigin = _this.crossOrigin;
	      var url = crossOrigin ? _this.crossOriginUrl : _this.url;
	      var previews;
	
	      if (crossOrigin) {
	        image.crossOrigin = crossOrigin;
	      }
	
	      image.src = url;
	      appendChild(_this.viewBox, image);
	      _this.image2 = image;
	
	      if (!preview) {
	        return;
	      }
	
	      _this.previews = previews = document.querySelectorAll(preview);
	
	      each(previews, function (element) {
	        var image = createElement('img');
	
	        // Save the original size for recover
	        setData(element, DATA_PREVIEW, {
	          width: element.offsetWidth,
	          height: element.offsetHeight,
	          html: element.innerHTML
	        });
	
	        if (crossOrigin) {
	          image.crossOrigin = crossOrigin;
	        }
	
	        image.src = url;
	
	        /**
	         * Override img element styles
	         * Add `display:block` to avoid margin top issue
	         * Add `height:auto` to override `height` attribute on IE8
	         * (Occur only when margin-top <= -height)
	         */
	
	        image.style.cssText = (
	          'display:block;' +
	          'width:100%;' +
	          'height:auto;' +
	          'min-width:0!important;' +
	          'min-height:0!important;' +
	          'max-width:none!important;' +
	          'max-height:none!important;' +
	          'image-orientation:0deg!important;"'
	        );
	
	        empty(element);
	        appendChild(element, image);
	      });
	    },
	
	    resetPreview: function () {
	      each(this.previews, function (element) {
	        var data = getData(element, DATA_PREVIEW);
	
	        setStyle(element, {
	          width: data.width,
	          height: data.height
	        });
	
	        element.innerHTML = data.html;
	        removeData(element, DATA_PREVIEW);
	      });
	    },
	
	    preview: function () {
	      var _this = this;
	      var imageData = _this.imageData;
	      var canvasData = _this.canvasData;
	      var cropBoxData = _this.cropBoxData;
	      var cropBoxWidth = cropBoxData.width;
	      var cropBoxHeight = cropBoxData.height;
	      var width = imageData.width;
	      var height = imageData.height;
	      var left = cropBoxData.left - canvasData.left - imageData.left;
	      var top = cropBoxData.top - canvasData.top - imageData.top;
	      var transform = getTransform(imageData);
	      var transforms = {
	            WebkitTransform: transform,
	            msTransform: transform,
	            transform: transform
	          };
	
	      if (!_this.cropped || _this.disabled) {
	        return;
	      }
	
	      setStyle(_this.image2, extend({
	        width: width,
	        height: height,
	        marginLeft: -left,
	        marginTop: -top
	      }, transforms));
	
	      each(_this.previews, function (element) {
	        var data = getData(element, DATA_PREVIEW);
	        var originalWidth = data.width;
	        var originalHeight = data.height;
	        var newWidth = originalWidth;
	        var newHeight = originalHeight;
	        var ratio = 1;
	
	        if (cropBoxWidth) {
	          ratio = originalWidth / cropBoxWidth;
	          newHeight = cropBoxHeight * ratio;
	        }
	
	        if (cropBoxHeight && newHeight > originalHeight) {
	          ratio = originalHeight / cropBoxHeight;
	          newWidth = cropBoxWidth * ratio;
	          newHeight = originalHeight;
	        }
	
	        setStyle(element, {
	          width: newWidth,
	          height: newHeight
	        });
	
	        setStyle(getByTag(element, 'img')[0], extend({
	          width: width * ratio,
	          height: height * ratio,
	          marginLeft: -left * ratio,
	          marginTop: -top * ratio
	        }, transforms));
	      });
	    },
	
	    bind: function () {
	      var _this = this;
	      var options = _this.options;
	      var element = _this.element;
	      var cropper = _this.cropper;
	
	      if (isFunction(options.cropstart)) {
	        addListener(element, EVENT_CROP_START, options.cropstart);
	      }
	
	      if (isFunction(options.cropmove)) {
	        addListener(element, EVENT_CROP_MOVE, options.cropmove);
	      }
	
	      if (isFunction(options.cropend)) {
	        addListener(element, EVENT_CROP_END, options.cropend);
	      }
	
	      if (isFunction(options.crop)) {
	        addListener(element, EVENT_CROP, options.crop);
	      }
	
	      if (isFunction(options.zoom)) {
	        addListener(element, EVENT_ZOOM, options.zoom);
	      }
	
	      addListener(cropper, EVENT_MOUSE_DOWN, (_this._cropStart = proxy(_this.cropStart, _this)));
	
	      if (options.zoomable && options.zoomOnWheel) {
	        addListener(cropper, EVENT_WHEEL, (_this._wheel = proxy(_this.wheel, _this)));
	      }
	
	      if (options.toggleDragModeOnDblclick) {
	        addListener(cropper, EVENT_DBLCLICK, (_this._dblclick = proxy(_this.dblclick, _this)));
	      }
	
	      addListener(document, EVENT_MOUSE_MOVE, (_this._cropMove = proxy(_this.cropMove, _this)));
	      addListener(document, EVENT_MOUSE_UP, (_this._cropEnd = proxy(_this.cropEnd, _this)));
	
	      if (options.responsive) {
	        addListener(window, EVENT_RESIZE, (_this._resize = proxy(_this.resize, _this)));
	      }
	    },
	
	    unbind: function () {
	      var _this = this;
	      var options = _this.options;
	      var element = _this.element;
	      var cropper = _this.cropper;
	
	      if (isFunction(options.cropstart)) {
	        removeListener(element, EVENT_CROP_START, options.cropstart);
	      }
	
	      if (isFunction(options.cropmove)) {
	        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
	      }
	
	      if (isFunction(options.cropend)) {
	        removeListener(element, EVENT_CROP_END, options.cropend);
	      }
	
	      if (isFunction(options.crop)) {
	        removeListener(element, EVENT_CROP, options.crop);
	      }
	
	      if (isFunction(options.zoom)) {
	        removeListener(element, EVENT_ZOOM, options.zoom);
	      }
	
	      removeListener(cropper, EVENT_MOUSE_DOWN, _this._cropStart);
	
	      if (options.zoomable && options.zoomOnWheel) {
	        removeListener(cropper, EVENT_WHEEL, _this._wheel);
	      }
	
	      if (options.toggleDragModeOnDblclick) {
	        removeListener(cropper, EVENT_DBLCLICK, _this._dblclick);
	      }
	
	      removeListener(document, EVENT_MOUSE_MOVE, _this._cropMove);
	      removeListener(document, EVENT_MOUSE_UP, _this._cropEnd);
	
	      if (options.responsive) {
	        removeListener(window, EVENT_RESIZE, _this._resize);
	      }
	    },
	
	    resize: function () {
	      var _this = this;
	      var restore = _this.options.restore;
	      var container = _this.container;
	      var containerData = _this.containerData;
	      var canvasData;
	      var cropBoxData;
	      var ratio;
	
	      // Check `container` is necessary for IE8
	      if (_this.disabled || !containerData) {
	        return;
	      }
	
	      ratio = container.offsetWidth / containerData.width;
	
	      // Resize when width changed or height changed
	      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
	        if (restore) {
	          canvasData = _this.getCanvasData();
	          cropBoxData = _this.getCropBoxData();
	        }
	
	        _this.render();
	
	        if (restore) {
	          _this.setCanvasData(each(canvasData, function (n, i) {
	            canvasData[i] = n * ratio;
	          }));
	          _this.setCropBoxData(each(cropBoxData, function (n, i) {
	            cropBoxData[i] = n * ratio;
	          }));
	        }
	      }
	    },
	
	    dblclick: function () {
	      var _this = this;
	
	      if (_this.disabled) {
	        return;
	      }
	
	      _this.setDragMode(hasClass(_this.dragBox, CLASS_CROP) ? ACTION_MOVE : ACTION_CROP);
	    },
	
	    wheel: function (event) {
	      var _this = this;
	      var e = getEvent(event);
	      var ratio = Number(_this.options.wheelZoomRatio) || 0.1;
	      var delta = 1;
	
	      if (_this.disabled) {
	        return;
	      }
	
	      preventDefault(e);
	
	      // Limit wheel speed to prevent zoom too fast (#21)
	      if (_this.wheeling) {
	        return;
	      }
	
	      _this.wheeling = true;
	
	      setTimeout(function () {
	        _this.wheeling = false;
	      }, 50);
	
	      if (e.deltaY) {
	        delta = e.deltaY > 0 ? 1 : -1;
	      } else if (e.wheelDelta) {
	        delta = -e.wheelDelta / 120;
	      } else if (e.detail) {
	        delta = e.detail > 0 ? 1 : -1;
	      }
	
	      _this.zoom(-delta * ratio, e);
	    },
	
	    cropStart: function (event) {
	      var _this = this;
	      var options = _this.options;
	      var e = getEvent(event);
	      var touches = e.touches;
	      var touchesLength;
	      var touch;
	      var action;
	
	      if (_this.disabled) {
	        return;
	      }
	
	      if (touches) {
	        touchesLength = touches.length;
	
	        if (touchesLength > 1) {
	          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {
	            touch = touches[1];
	            _this.startX2 = touch.pageX;
	            _this.startY2 = touch.pageY;
	            action = ACTION_ZOOM;
	          } else {
	            return;
	          }
	        }
	
	        touch = touches[0];
	      }
	
	      action = action || getData(e.target, DATA_ACTION);
	
	      if (REGEXP_ACTIONS.test(action)) {
	        if (dispatchEvent(_this.element, EVENT_CROP_START, {
	          originalEvent: e,
	          action: action
	        }) === false) {
	          return;
	        }
	
	        preventDefault(e);
	
	        _this.action = action;
	        _this.cropping = false;
	
	        _this.startX = touch ? touch.pageX : e.pageX;
	        _this.startY = touch ? touch.pageY : e.pageY;
	
	        if (action === ACTION_CROP) {
	          _this.cropping = true;
	          addClass(_this.dragBox, CLASS_MODAL);
	        }
	      }
	    },
	
	    cropMove: function (event) {
	      var _this = this;
	      var options = _this.options;
	      var e = getEvent(event);
	      var touches = e.touches;
	      var action = _this.action;
	      var touchesLength;
	      var touch;
	
	      if (_this.disabled) {
	        return;
	      }
	
	      if (touches) {
	        touchesLength = touches.length;
	
	        if (touchesLength > 1) {
	          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {
	            touch = touches[1];
	            _this.endX2 = touch.pageX;
	            _this.endY2 = touch.pageY;
	          } else {
	            return;
	          }
	        }
	
	        touch = touches[0];
	      }
	
	      if (action) {
	        if (dispatchEvent(_this.element, EVENT_CROP_MOVE, {
	          originalEvent: e,
	          action: action
	        }) === false) {
	          return;
	        }
	
	        preventDefault(e);
	
	        _this.endX = touch ? touch.pageX : e.pageX;
	        _this.endY = touch ? touch.pageY : e.pageY;
	
	        _this.change(e.shiftKey, action === ACTION_ZOOM ? e : null);
	      }
	    },
	
	    cropEnd: function (event) {
	      var _this = this;
	      var options = _this.options;
	      var e = getEvent(event);
	      var action = _this.action;
	
	      if (_this.disabled) {
	        return;
	      }
	
	      if (action) {
	        preventDefault(e);
	
	        if (_this.cropping) {
	          _this.cropping = false;
	          toggleClass(_this.dragBox, CLASS_MODAL, _this.cropped && options.modal);
	        }
	
	        _this.action = '';
	
	        dispatchEvent(_this.element, EVENT_CROP_END, {
	          originalEvent: e,
	          action: action
	        });
	      }
	    },
	
	    change: function (shiftKey, originalEvent) {
	      var _this = this;
	      var options = _this.options;
	      var aspectRatio = options.aspectRatio;
	      var action = _this.action;
	      var containerData = _this.containerData;
	      var canvasData = _this.canvasData;
	      var cropBoxData = _this.cropBoxData;
	      var width = cropBoxData.width;
	      var height = cropBoxData.height;
	      var left = cropBoxData.left;
	      var top = cropBoxData.top;
	      var right = left + width;
	      var bottom = top + height;
	      var minLeft = 0;
	      var minTop = 0;
	      var maxWidth = containerData.width;
	      var maxHeight = containerData.height;
	      var renderable = true;
	      var offset;
	      var range;
	
	      // Locking aspect ratio in "free mode" by holding shift key
	      if (!aspectRatio && shiftKey) {
	        aspectRatio = width && height ? width / height : 1;
	      }
	
	      if (_this.limited) {
	        minLeft = cropBoxData.minLeft;
	        minTop = cropBoxData.minTop;
	        maxWidth = minLeft + min(containerData.width, canvasData.left + canvasData.width);
	        maxHeight = minTop + min(containerData.height, canvasData.top + canvasData.height);
	      }
	
	      range = {
	        x: _this.endX - _this.startX,
	        y: _this.endY - _this.startY
	      };
	
	      if (aspectRatio) {
	        range.X = range.y * aspectRatio;
	        range.Y = range.x / aspectRatio;
	      }
	
	      switch (action) {
	        // Move crop box
	        case ACTION_ALL:
	          left += range.x;
	          top += range.y;
	          break;
	
	        // Resize crop box
	        case ACTION_EAST:
	          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&
	            (top <= minTop || bottom >= maxHeight))) {
	
	            renderable = false;
	            break;
	          }
	
	          width += range.x;
	
	          if (aspectRatio) {
	            height = width / aspectRatio;
	            top -= range.Y / 2;
	          }
	
	          if (width < 0) {
	            action = ACTION_WEST;
	            width = 0;
	          }
	
	          break;
	
	        case ACTION_NORTH:
	          if (range.y <= 0 && (top <= minTop || aspectRatio &&
	            (left <= minLeft || right >= maxWidth))) {
	
	            renderable = false;
	            break;
	          }
	
	          height -= range.y;
	          top += range.y;
	
	          if (aspectRatio) {
	            width = height * aspectRatio;
	            left += range.X / 2;
	          }
	
	          if (height < 0) {
	            action = ACTION_SOUTH;
	            height = 0;
	          }
	
	          break;
	
	        case ACTION_WEST:
	          if (range.x <= 0 && (left <= minLeft || aspectRatio &&
	            (top <= minTop || bottom >= maxHeight))) {
	
	            renderable = false;
	            break;
	          }
	
	          width -= range.x;
	          left += range.x;
	
	          if (aspectRatio) {
	            height = width / aspectRatio;
	            top += range.Y / 2;
	          }
	
	          if (width < 0) {
	            action = ACTION_EAST;
	            width = 0;
	          }
	
	          break;
	
	        case ACTION_SOUTH:
	          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&
	            (left <= minLeft || right >= maxWidth))) {
	
	            renderable = false;
	            break;
	          }
	
	          height += range.y;
	
	          if (aspectRatio) {
	            width = height * aspectRatio;
	            left -= range.X / 2;
	          }
	
	          if (height < 0) {
	            action = ACTION_NORTH;
	            height = 0;
	          }
	
	          break;
	
	        case ACTION_NORTH_EAST:
	          if (aspectRatio) {
	            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
	              renderable = false;
	              break;
	            }
	
	            height -= range.y;
	            top += range.y;
	            width = height * aspectRatio;
	          } else {
	            if (range.x >= 0) {
	              if (right < maxWidth) {
	                width += range.x;
	              } else if (range.y <= 0 && top <= minTop) {
	                renderable = false;
	              }
	            } else {
	              width += range.x;
	            }
	
	            if (range.y <= 0) {
	              if (top > minTop) {
	                height -= range.y;
	                top += range.y;
	              }
	            } else {
	              height -= range.y;
	              top += range.y;
	            }
	          }
	
	          if (width < 0 && height < 0) {
	            action = ACTION_SOUTH_WEST;
	            height = 0;
	            width = 0;
	          } else if (width < 0) {
	            action = ACTION_NORTH_WEST;
	            width = 0;
	          } else if (height < 0) {
	            action = ACTION_SOUTH_EAST;
	            height = 0;
	          }
	
	          break;
	
	        case ACTION_NORTH_WEST:
	          if (aspectRatio) {
	            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
	              renderable = false;
	              break;
	            }
	
	            height -= range.y;
	            top += range.y;
	            width = height * aspectRatio;
	            left += range.X;
	          } else {
	            if (range.x <= 0) {
	              if (left > minLeft) {
	                width -= range.x;
	                left += range.x;
	              } else if (range.y <= 0 && top <= minTop) {
	                renderable = false;
	              }
	            } else {
	              width -= range.x;
	              left += range.x;
	            }
	
	            if (range.y <= 0) {
	              if (top > minTop) {
	                height -= range.y;
	                top += range.y;
	              }
	            } else {
	              height -= range.y;
	              top += range.y;
	            }
	          }
	
	          if (width < 0 && height < 0) {
	            action = ACTION_SOUTH_EAST;
	            height = 0;
	            width = 0;
	          } else if (width < 0) {
	            action = ACTION_NORTH_EAST;
	            width = 0;
	          } else if (height < 0) {
	            action = ACTION_SOUTH_WEST;
	            height = 0;
	          }
	
	          break;
	
	        case ACTION_SOUTH_WEST:
	          if (aspectRatio) {
	            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
	              renderable = false;
	              break;
	            }
	
	            width -= range.x;
	            left += range.x;
	            height = width / aspectRatio;
	          } else {
	            if (range.x <= 0) {
	              if (left > minLeft) {
	                width -= range.x;
	                left += range.x;
	              } else if (range.y >= 0 && bottom >= maxHeight) {
	                renderable = false;
	              }
	            } else {
	              width -= range.x;
	              left += range.x;
	            }
	
	            if (range.y >= 0) {
	              if (bottom < maxHeight) {
	                height += range.y;
	              }
	            } else {
	              height += range.y;
	            }
	          }
	
	          if (width < 0 && height < 0) {
	            action = ACTION_NORTH_EAST;
	            height = 0;
	            width = 0;
	          } else if (width < 0) {
	            action = ACTION_SOUTH_EAST;
	            width = 0;
	          } else if (height < 0) {
	            action = ACTION_NORTH_WEST;
	            height = 0;
	          }
	
	          break;
	
	        case ACTION_SOUTH_EAST:
	          if (aspectRatio) {
	            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
	              renderable = false;
	              break;
	            }
	
	            width += range.x;
	            height = width / aspectRatio;
	          } else {
	            if (range.x >= 0) {
	              if (right < maxWidth) {
	                width += range.x;
	              } else if (range.y >= 0 && bottom >= maxHeight) {
	                renderable = false;
	              }
	            } else {
	              width += range.x;
	            }
	
	            if (range.y >= 0) {
	              if (bottom < maxHeight) {
	                height += range.y;
	              }
	            } else {
	              height += range.y;
	            }
	          }
	
	          if (width < 0 && height < 0) {
	            action = ACTION_NORTH_WEST;
	            height = 0;
	            width = 0;
	          } else if (width < 0) {
	            action = ACTION_SOUTH_WEST;
	            width = 0;
	          } else if (height < 0) {
	            action = ACTION_NORTH_EAST;
	            height = 0;
	          }
	
	          break;
	
	        // Move canvas
	        case ACTION_MOVE:
	          _this.move(range.x, range.y);
	          renderable = false;
	          break;
	
	        // Zoom canvas
	        case ACTION_ZOOM:
	          _this.zoom((function (x1, y1, x2, y2) {
	            var z1 = sqrt(x1 * x1 + y1 * y1);
	            var z2 = sqrt(x2 * x2 + y2 * y2);
	
	            return (z2 - z1) / z1;
	          })(
	            abs(_this.startX - _this.startX2),
	            abs(_this.startY - _this.startY2),
	            abs(_this.endX - _this.endX2),
	            abs(_this.endY - _this.endY2)
	          ), originalEvent);
	          _this.startX2 = _this.endX2;
	          _this.startY2 = _this.endY2;
	          renderable = false;
	          break;
	
	        // Create crop box
	        case ACTION_CROP:
	          if (!range.x || !range.y) {
	            renderable = false;
	            break;
	          }
	
	          offset = getOffset(_this.cropper);
	          left = _this.startX - offset.left;
	          top = _this.startY - offset.top;
	          width = cropBoxData.minWidth;
	          height = cropBoxData.minHeight;
	
	          if (range.x > 0) {
	            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
	          } else if (range.x < 0) {
	            left -= width;
	            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
	          }
	
	          if (range.y < 0) {
	            top -= height;
	          }
	
	          // Show the crop box if is hidden
	          if (!_this.cropped) {
	            removeClass(_this.cropBox, CLASS_HIDDEN);
	            _this.cropped = true;
	
	            if (_this.limited) {
	              _this.limitCropBox(true, true);
	            }
	          }
	
	          break;
	
	        // No default
	      }
	
	      if (renderable) {
	        cropBoxData.width = width;
	        cropBoxData.height = height;
	        cropBoxData.left = left;
	        cropBoxData.top = top;
	        _this.action = action;
	
	        _this.renderCropBox();
	      }
	
	      // Override
	      _this.startX = _this.endX;
	      _this.startY = _this.endY;
	    },
	
	    // Show the crop box manually
	    crop: function () {
	      var _this = this;
	
	      if (_this.built && !_this.disabled) {
	        if (!_this.cropped) {
	          _this.cropped = true;
	          _this.limitCropBox(true, true);
	
	          if (_this.options.modal) {
	            addClass(_this.dragBox, CLASS_MODAL);
	          }
	
	          removeClass(_this.cropBox, CLASS_HIDDEN);
	        }
	
	        _this.setCropBoxData(_this.initialCropBoxData);
	      }
	
	      return _this;
	    },
	
	    // Reset the image and crop box to their initial states
	    reset: function () {
	      var _this = this;
	
	      if (_this.built && !_this.disabled) {
	        _this.imageData = extend({}, _this.initialImageData);
	        _this.canvasData = extend({}, _this.initialCanvasData);
	        _this.cropBoxData = extend({}, _this.initialCropBoxData);
	
	        _this.renderCanvas();
	
	        if (_this.cropped) {
	          _this.renderCropBox();
	        }
	      }
	
	      return _this;
	    },
	
	    // Clear the crop box
	    clear: function () {
	      var _this = this;
	
	      if (_this.cropped && !_this.disabled) {
	        extend(_this.cropBoxData, {
	          left: 0,
	          top: 0,
	          width: 0,
	          height: 0
	        });
	
	        _this.cropped = false;
	        _this.renderCropBox();
	
	        _this.limitCanvas();
	
	        // Render canvas after crop box rendered
	        _this.renderCanvas();
	
	        removeClass(_this.dragBox, CLASS_MODAL);
	        addClass(_this.cropBox, CLASS_HIDDEN);
	      }
	
	      return _this;
	    },
	
	    /**
	     * Replace the image's src and rebuild the cropper
	     *
	     * @param {String} url
	     * @param {Boolean} onlyColorChanged (optional)
	     */
	    replace: function (url, onlyColorChanged) {
	      var _this = this;
	
	      if (!_this.disabled && url) {
	        if (_this.isImg) {
	          _this.element.src = url;
	        }
	
	        if (onlyColorChanged) {
	          _this.url = url;
	          _this.image.src = url;
	
	          if (_this.built) {
	            _this.image2.src = url;
	
	            each(_this.previews, function (element) {
	              getByTag(element, 'img')[0].src = url;
	            });
	          }
	        } else {
	          if (_this.isImg) {
	            _this.replaced = true;
	          }
	
	          // Clear previous data
	          _this.options.data = null;
	          _this.load(url);
	        }
	      }
	
	      return _this;
	    },
	
	    // Enable (unfreeze) the cropper
	    enable: function () {
	      var _this = this;
	
	      if (_this.built) {
	        _this.disabled = false;
	        removeClass(_this.cropper, CLASS_DISABLED);
	      }
	
	      return _this;
	    },
	
	    // Disable (freeze) the cropper
	    disable: function () {
	      var _this = this;
	
	      if (_this.built) {
	        _this.disabled = true;
	        addClass(_this.cropper, CLASS_DISABLED);
	      }
	
	      return _this;
	    },
	
	    // Destroy the cropper and remove the instance from the image
	    destroy: function () {
	      var _this = this;
	      var element = _this.element;
	      var image = _this.image;
	
	      if (_this.ready) {
	        if (_this.isImg && _this.replaced) {
	          element.src = _this.originalUrl;
	        }
	
	        _this.unbuild();
	        removeClass(element, CLASS_HIDDEN);
	      } else {
	        if (_this.isImg) {
	          removeListener(element, EVENT_LOAD, _this.start);
	        } else if (image) {
	          removeChild(image);
	        }
	      }
	
	      removeData(element, NAMESPACE);
	
	      return _this;
	    },
	
	    /**
	     * Move the canvas with relative offsets
	     *
	     * @param {Number} offsetX
	     * @param {Number} offsetY (optional)
	     */
	    move: function (offsetX, offsetY) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	
	      return _this.moveTo(
	        isUndefined(offsetX) ? offsetX : canvasData.left + Number(offsetX),
	        isUndefined(offsetY) ? offsetY : canvasData.top + Number(offsetY)
	      );
	    },
	
	    /**
	     * Move the canvas to an absolute point
	     *
	     * @param {Number} x
	     * @param {Number} y (optional)
	     */
	    moveTo: function (x, y) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	      var changed = false;
	
	      // If "y" is not present, its default value is "x"
	      if (isUndefined(y)) {
	        y = x;
	      }
	
	      x = Number(x);
	      y = Number(y);
	
	      if (_this.built && !_this.disabled && _this.options.movable) {
	        if (isNumber(x)) {
	          canvasData.left = x;
	          changed = true;
	        }
	
	        if (isNumber(y)) {
	          canvasData.top = y;
	          changed = true;
	        }
	
	        if (changed) {
	          _this.renderCanvas(true);
	        }
	      }
	
	      return _this;
	    },
	
	    /**
	     * Zoom the canvas with a relative ratio
	     *
	     * @param {Number} ratio
	     * @param {Event} _originalEvent (private)
	     */
	    zoom: function (ratio, _originalEvent) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	
	      ratio = Number(ratio);
	
	      if (ratio < 0) {
	        ratio = 1 / (1 - ratio);
	      } else {
	        ratio = 1 + ratio;
	      }
	
	      return _this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, _originalEvent);
	    },
	
	    /**
	     * Zoom the canvas to an absolute ratio
	     *
	     * @param {Number} ratio
	     * @param {Event} _originalEvent (private)
	     */
	    zoomTo: function (ratio, _originalEvent) {
	      var _this = this;
	      var options = _this.options;
	      var canvasData = _this.canvasData;
	      var width = canvasData.width;
	      var height = canvasData.height;
	      var naturalWidth = canvasData.naturalWidth;
	      var naturalHeight = canvasData.naturalHeight;
	      var newWidth;
	      var newHeight;
	      var offset;
	      var center;
	
	      ratio = Number(ratio);
	
	      if (ratio >= 0 && _this.built && !_this.disabled && options.zoomable) {
	        newWidth = naturalWidth * ratio;
	        newHeight = naturalHeight * ratio;
	
	        if (dispatchEvent(_this.element, EVENT_ZOOM, {
	          originalEvent: _originalEvent,
	          oldRatio: width / naturalWidth,
	          ratio: newWidth / naturalWidth
	        }) === false) {
	          return _this;
	        }
	
	        if (_originalEvent) {
	          offset = getOffset(_this.cropper);
	          center = _originalEvent.touches ? getTouchesCenter(_originalEvent.touches) : {
	            pageX: _originalEvent.pageX,
	            pageY: _originalEvent.pageY
	          };
	
	          // Zoom from the triggering point of the event
	          canvasData.left -= (newWidth - width) * (
	            ((center.pageX - offset.left) - canvasData.left) / width
	          );
	          canvasData.top -= (newHeight - height) * (
	            ((center.pageY - offset.top) - canvasData.top) / height
	          );
	        } else {
	
	          // Zoom from the center of the canvas
	          canvasData.left -= (newWidth - width) / 2;
	          canvasData.top -= (newHeight - height) / 2;
	        }
	
	        canvasData.width = newWidth;
	        canvasData.height = newHeight;
	        _this.renderCanvas(true);
	      }
	
	      return _this;
	    },
	
	    /**
	     * Rotate the canvas with a relative degree
	     *
	     * @param {Number} degree
	     */
	    rotate: function (degree) {
	      var _this = this;
	
	      return _this.rotateTo((_this.imageData.rotate || 0) + Number(degree));
	    },
	
	    /**
	     * Rotate the canvas to an absolute degree
	     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()
	     *
	     * @param {Number} degree
	     */
	    rotateTo: function (degree) {
	      var _this = this;
	
	      degree = Number(degree);
	
	      if (isNumber(degree) && _this.built && !_this.disabled && _this.options.rotatable) {
	        _this.imageData.rotate = degree % 360;
	        _this.rotated = true;
	        _this.renderCanvas(true);
	      }
	
	      return _this;
	    },
	
	    /**
	     * Scale the image
	     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()
	     *
	     * @param {Number} scaleX
	     * @param {Number} scaleY (optional)
	     */
	    scale: function (scaleX, scaleY) {
	      var _this = this;
	      var imageData = _this.imageData;
	      var changed = false;
	
	      // If "scaleY" is not present, its default value is "scaleX"
	      if (isUndefined(scaleY)) {
	        scaleY = scaleX;
	      }
	
	      scaleX = Number(scaleX);
	      scaleY = Number(scaleY);
	
	      if (_this.built && !_this.disabled && _this.options.scalable) {
	        if (isNumber(scaleX)) {
	          imageData.scaleX = scaleX;
	          changed = true;
	        }
	
	        if (isNumber(scaleY)) {
	          imageData.scaleY = scaleY;
	          changed = true;
	        }
	
	        if (changed) {
	          _this.renderImage(true);
	        }
	      }
	
	      return _this;
	    },
	
	    /**
	     * Scale the abscissa of the image
	     *
	     * @param {Number} scaleX
	     */
	    scaleX: function (scaleX) {
	      var _this = this;
	      var scaleY = _this.imageData.scaleY;
	
	      return _this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);
	    },
	
	    /**
	     * Scale the ordinate of the image
	     *
	     * @param {Number} scaleY
	     */
	    scaleY: function (scaleY) {
	      var _this = this;
	      var scaleX = _this.imageData.scaleX;
	
	      return _this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);
	    },
	
	    /**
	     * Get the cropped area position and size data (base on the original image)
	     *
	     * @param {Boolean} rounded (optional)
	     * @return {Object} data
	     */
	    getData: function (rounded) {
	      var _this = this;
	      var options = _this.options;
	      var imageData = _this.imageData;
	      var canvasData = _this.canvasData;
	      var cropBoxData = _this.cropBoxData;
	      var ratio;
	      var data;
	
	      if (_this.built && _this.cropped) {
	        data = {
	          x: cropBoxData.left - canvasData.left,
	          y: cropBoxData.top - canvasData.top,
	          width: cropBoxData.width,
	          height: cropBoxData.height
	        };
	
	        ratio = imageData.width / imageData.naturalWidth;
	
	        each(data, function (n, i) {
	          n = n / ratio;
	          data[i] = rounded ? round(n) : n;
	        });
	
	      } else {
	        data = {
	          x: 0,
	          y: 0,
	          width: 0,
	          height: 0
	        };
	      }
	
	      if (options.rotatable) {
	        data.rotate = imageData.rotate || 0;
	      }
	
	      if (options.scalable) {
	        data.scaleX = imageData.scaleX || 1;
	        data.scaleY = imageData.scaleY || 1;
	      }
	
	      return data;
	    },
	
	    /**
	     * Set the cropped area position and size with new data
	     *
	     * @param {Object} data
	     */
	    setData: function (data) {
	      var _this = this;
	      var options = _this.options;
	      var imageData = _this.imageData;
	      var canvasData = _this.canvasData;
	      var cropBoxData = {};
	      var rotated;
	      var scaled;
	      var ratio;
	
	      if (isFunction(data)) {
	        data = data.call(_this.element);
	      }
	
	      if (_this.built && !_this.disabled && isPlainObject(data)) {
	        if (options.rotatable) {
	          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
	            imageData.rotate = data.rotate;
	            _this.rotated = rotated = true;
	          }
	        }
	
	        if (options.scalable) {
	          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
	            imageData.scaleX = data.scaleX;
	            scaled = true;
	          }
	
	          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
	            imageData.scaleY = data.scaleY;
	            scaled = true;
	          }
	        }
	
	        if (rotated) {
	          _this.renderCanvas();
	        } else if (scaled) {
	          _this.renderImage();
	        }
	
	        ratio = imageData.width / imageData.naturalWidth;
	
	        if (isNumber(data.x)) {
	          cropBoxData.left = data.x * ratio + canvasData.left;
	        }
	
	        if (isNumber(data.y)) {
	          cropBoxData.top = data.y * ratio + canvasData.top;
	        }
	
	        if (isNumber(data.width)) {
	          cropBoxData.width = data.width * ratio;
	        }
	
	        if (isNumber(data.height)) {
	          cropBoxData.height = data.height * ratio;
	        }
	
	        _this.setCropBoxData(cropBoxData);
	      }
	
	      return _this;
	    },
	
	    /**
	     * Get the container size data
	     *
	     * @return {Object} data
	     */
	    getContainerData: function () {
	      var _this = this;
	
	      return _this.built ? _this.containerData : {};
	    },
	
	    /**
	     * Get the image position and size data
	     *
	     * @return {Object} data
	     */
	    getImageData: function () {
	      var _this = this;
	
	      return _this.ready ? _this.imageData : {};
	    },
	
	    /**
	     * Get the canvas position and size data
	     *
	     * @return {Object} data
	     */
	    getCanvasData: function () {
	      var _this = this;
	      var canvasData = _this.canvasData;
	      var data = {};
	
	      if (_this.built) {
	        each([
	          'left',
	          'top',
	          'width',
	          'height',
	          'naturalWidth',
	          'naturalHeight'
	        ], function (n) {
	          data[n] = canvasData[n];
	        });
	      }
	
	      return data;
	    },
	
	    /**
	     * Set the canvas position and size with new data
	     *
	     * @param {Object} data
	     */
	    setCanvasData: function (data) {
	      var _this = this;
	      var canvasData = _this.canvasData;
	      var aspectRatio = canvasData.aspectRatio;
	
	      if (isFunction(data)) {
	        data = data.call(_this.element);
	      }
	
	      if (_this.built && !_this.disabled && isPlainObject(data)) {
	        if (isNumber(data.left)) {
	          canvasData.left = data.left;
	        }
	
	        if (isNumber(data.top)) {
	          canvasData.top = data.top;
	        }
	
	        if (isNumber(data.width)) {
	          canvasData.width = data.width;
	          canvasData.height = data.width / aspectRatio;
	        } else if (isNumber(data.height)) {
	          canvasData.height = data.height;
	          canvasData.width = data.height * aspectRatio;
	        }
	
	        _this.renderCanvas(true);
	      }
	
	      return _this;
	    },
	
	    /**
	     * Get the crop box position and size data
	     *
	     * @return {Object} data
	     */
	    getCropBoxData: function () {
	      var _this = this;
	      var cropBoxData = _this.cropBoxData;
	      var data;
	
	      if (_this.built && _this.cropped) {
	        data = {
	          left: cropBoxData.left,
	          top: cropBoxData.top,
	          width: cropBoxData.width,
	          height: cropBoxData.height
	        };
	      }
	
	      return data || {};
	    },
	
	    /**
	     * Set the crop box position and size with new data
	     *
	     * @param {Object} data
	     */
	    setCropBoxData: function (data) {
	      var _this = this;
	      var cropBoxData = _this.cropBoxData;
	      var aspectRatio = _this.options.aspectRatio;
	      var widthChanged;
	      var heightChanged;
	
	      if (isFunction(data)) {
	        data = data.call(_this.element);
	      }
	
	      if (_this.built && _this.cropped && !_this.disabled && isPlainObject(data)) {
	
	        if (isNumber(data.left)) {
	          cropBoxData.left = data.left;
	        }
	
	        if (isNumber(data.top)) {
	          cropBoxData.top = data.top;
	        }
	
	        if (isNumber(data.width)) {
	          widthChanged = true;
	          cropBoxData.width = data.width;
	        }
	
	        if (isNumber(data.height)) {
	          heightChanged = true;
	          cropBoxData.height = data.height;
	        }
	
	        if (aspectRatio) {
	          if (widthChanged) {
	            cropBoxData.height = cropBoxData.width / aspectRatio;
	          } else if (heightChanged) {
	            cropBoxData.width = cropBoxData.height * aspectRatio;
	          }
	        }
	
	        _this.renderCropBox();
	      }
	
	      return _this;
	    },
	
	    /**
	     * Get a canvas drawn the cropped image
	     *
	     * @param {Object} options (optional)
	     * @return {HTMLCanvasElement} canvas
	     */
	    getCroppedCanvas: function (options) {
	      var _this = this;
	      var originalWidth;
	      var originalHeight;
	      var canvasWidth;
	      var canvasHeight;
	      var scaledWidth;
	      var scaledHeight;
	      var scaledRatio;
	      var aspectRatio;
	      var canvas;
	      var context;
	      var data;
	
	      if (!_this.built || !_this.cropped || !SUPPORT_CANVAS) {
	        return;
	      }
	
	      if (!isPlainObject(options)) {
	        options = {};
	      }
	
	      data = _this.getData();
	      originalWidth = data.width;
	      originalHeight = data.height;
	      aspectRatio = originalWidth / originalHeight;
	
	      if (isPlainObject(options)) {
	        scaledWidth = options.width;
	        scaledHeight = options.height;
	
	        if (scaledWidth) {
	          scaledHeight = scaledWidth / aspectRatio;
	          scaledRatio = scaledWidth / originalWidth;
	        } else if (scaledHeight) {
	          scaledWidth = scaledHeight * aspectRatio;
	          scaledRatio = scaledHeight / originalHeight;
	        }
	      }
	
	      // The canvas element will use `Math.floor` on a float number, so floor first
	      canvasWidth = floor(scaledWidth || originalWidth);
	      canvasHeight = floor(scaledHeight || originalHeight);
	
	      canvas = createElement('canvas');
	      canvas.width = canvasWidth;
	      canvas.height = canvasHeight;
	      context = canvas.getContext('2d');
	
	      if (options.fillColor) {
	        context.fillStyle = options.fillColor;
	        context.fillRect(0, 0, canvasWidth, canvasHeight);
	      }
	
	      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage
	      context.drawImage.apply(context, (function () {
	        var source = getSourceCanvas(_this.image, _this.imageData);
	        var sourceWidth = source.width;
	        var sourceHeight = source.height;
	        var canvasData = _this.canvasData;
	        var params = [source];
	
	        // Source canvas
	        var srcX = data.x + canvasData.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;
	        var srcY = data.y + canvasData.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;
	        var srcWidth;
	        var srcHeight;
	
	        // Destination canvas
	        var dstX;
	        var dstY;
	        var dstWidth;
	        var dstHeight;
	
	        if (srcX <= -originalWidth || srcX > sourceWidth) {
	          srcX = srcWidth = dstX = dstWidth = 0;
	        } else if (srcX <= 0) {
	          dstX = -srcX;
	          srcX = 0;
	          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);
	        } else if (srcX <= sourceWidth) {
	          dstX = 0;
	          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);
	        }
	
	        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {
	          srcY = srcHeight = dstY = dstHeight = 0;
	        } else if (srcY <= 0) {
	          dstY = -srcY;
	          srcY = 0;
	          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);
	        } else if (srcY <= sourceHeight) {
	          dstY = 0;
	          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);
	        }
	
	        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));
	
	        // Scale destination sizes
	        if (scaledRatio) {
	          dstX *= scaledRatio;
	          dstY *= scaledRatio;
	          dstWidth *= scaledRatio;
	          dstHeight *= scaledRatio;
	        }
	
	        // Avoid "IndexSizeError" in IE and Firefox
	        if (dstWidth > 0 && dstHeight > 0) {
	          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));
	        }
	
	        return params;
	      }).call(_this));
	
	      return canvas;
	    },
	
	    /**
	     * Change the aspect ratio of the crop box
	     *
	     * @param {Number} aspectRatio
	     */
	    setAspectRatio: function (aspectRatio) {
	      var _this = this;
	      var options = _this.options;
	
	      if (!_this.disabled && !isUndefined(aspectRatio)) {
	
	        // 0 -> NaN
	        options.aspectRatio = max(0, aspectRatio) || NaN;
	
	        if (_this.built) {
	          _this.initCropBox();
	
	          if (_this.cropped) {
	            _this.renderCropBox();
	          }
	        }
	      }
	
	      return _this;
	    },
	
	    /**
	     * Change the drag mode
	     *
	     * @param {String} mode (optional)
	     */
	    setDragMode: function (mode) {
	      var _this = this;
	      var options = _this.options;
	      var dragBox = _this.dragBox;
	      var face = _this.face;
	      var croppable;
	      var movable;
	
	      if (_this.ready && !_this.disabled) {
	        croppable = mode === ACTION_CROP;
	        movable = options.movable && mode === ACTION_MOVE;
	        mode = (croppable || movable) ? mode : ACTION_NONE;
	
	        setData(dragBox, DATA_ACTION, mode);
	        toggleClass(dragBox, CLASS_CROP, croppable);
	        toggleClass(dragBox, CLASS_MOVE, movable);
	
	        if (!options.cropBoxMovable) {
	
	          // Sync drag mode to crop box when it is not movable
	          setData(face, DATA_ACTION, mode);
	          toggleClass(face, CLASS_CROP, croppable);
	          toggleClass(face, CLASS_MOVE, movable);
	        }
	      }
	
	      return _this;
	    }
	  };
	
	  Cropper.DEFAULTS = {
	
	    // Define the view mode of the cropper
	    viewMode: 0, // 0, 1, 2, 3
	
	    // Define the dragging mode of the cropper
	    dragMode: 'crop', // 'crop', 'move' or 'none'
	
	    // Define the aspect ratio of the crop box
	    aspectRatio: NaN,
	
	    // An object with the previous cropping result data
	    data: null,
	
	    // A selector for adding extra containers to preview
	    preview: '',
	
	    // Re-render the cropper when resize the window
	    responsive: true,
	
	    // Restore the cropped area after resize the window
	    restore: true,
	
	    // Check if the current image is a cross-origin image
	    checkCrossOrigin: true,
	
	    // Check the current image's Exif Orientation information
	    checkOrientation: true,
	
	    // Show the black modal
	    modal: true,
	
	    // Show the dashed lines for guiding
	    guides: true,
	
	    // Show the center indicator for guiding
	    center: true,
	
	    // Show the white modal to highlight the crop box
	    highlight: true,
	
	    // Show the grid background
	    background: true,
	
	    // Enable to crop the image automatically when initialize
	    autoCrop: true,
	
	    // Define the percentage of automatic cropping area when initializes
	    autoCropArea: 0.8,
	
	    // Enable to move the image
	    movable: true,
	
	    // Enable to rotate the image
	    rotatable: true,
	
	    // Enable to scale the image
	    scalable: true,
	
	    // Enable to zoom the image
	    zoomable: true,
	
	    // Enable to zoom the image by dragging touch
	    zoomOnTouch: true,
	
	    // Enable to zoom the image by wheeling mouse
	    zoomOnWheel: true,
	
	    // Define zoom ratio when zoom the image by wheeling mouse
	    wheelZoomRatio: 0.1,
	
	    // Enable to move the crop box
	    cropBoxMovable: true,
	
	    // Enable to resize the crop box
	    cropBoxResizable: true,
	
	    // Toggle drag mode between "crop" and "move" when click twice on the cropper
	    toggleDragModeOnDblclick: true,
	
	    // Size limitation
	    minCanvasWidth: 0,
	    minCanvasHeight: 0,
	    minCropBoxWidth: 0,
	    minCropBoxHeight: 0,
	    minContainerWidth: 200,
	    minContainerHeight: 100,
	
	    // Shortcuts of events
	    build: null,
	    built: null,
	    cropstart: null,
	    cropmove: null,
	    cropend: null,
	    crop: null,
	    zoom: null
	  };
	
	  Cropper.TEMPLATE = (function (source, words) {
	    words = words.split(',');
	
	    return source.replace(/\d+/g, function (i) {
	      return words[i];
	    });
	  })('<0 6="5-container"><0 6="5-wrap-9"><0 6="5-canvas"></0></0><0 6="5-drag-9"></0><0 6="5-crop-9"><1 6="5-view-9"></1><1 6="5-8 8-h"></1><1 6="5-8 8-v"></1><1 6="5-center"></1><1 6="5-face"></1><1 6="5-7 7-e" 3-2="e"></1><1 6="5-7 7-n" 3-2="n"></1><1 6="5-7 7-w" 3-2="w"></1><1 6="5-7 7-s" 3-2="s"></1><1 6="5-4 4-e" 3-2="e"></1><1 6="5-4 4-n" 3-2="n"></1><1 6="5-4 4-w" 3-2="w"></1><1 6="5-4 4-s" 3-2="s"></1><1 6="5-4 4-ne" 3-2="ne"></1><1 6="5-4 4-nw" 3-2="nw"></1><1 6="5-4 4-sw" 3-2="sw"></1><1 6="5-4 4-se" 3-2="se"></1></0></0>', 'div,span,action,data,point,cropper,class,line,dashed,box');
	
	  /*Cropper.TEMPLATE = (
	    '<div class="cropper-container">' +
	      '<div class="cropper-wrap-box">' +
	        '<div class="cropper-canvas"></div>' +
	      '</div>' +
	      '<div class="cropper-drag-box"></div>' +
	      '<div class="cropper-crop-box">' +
	        '<span class="cropper-view-box"></span>' +
	        '<span class="cropper-dashed dashed-h"></span>' +
	        '<span class="cropper-dashed dashed-v"></span>' +
	        '<span class="cropper-center"></span>' +
	        '<span class="cropper-face"></span>' +
	        '<span class="cropper-line line-e" data-action="e"></span>' +
	        '<span class="cropper-line line-n" data-action="n"></span>' +
	        '<span class="cropper-line line-w" data-action="w"></span>' +
	        '<span class="cropper-line line-s" data-action="s"></span>' +
	        '<span class="cropper-point point-e" data-action="e"></span>' +
	        '<span class="cropper-point point-n" data-action="n"></span>' +
	        '<span class="cropper-point point-w" data-action="w"></span>' +
	        '<span class="cropper-point point-s" data-action="s"></span>' +
	        '<span class="cropper-point point-ne" data-action="ne"></span>' +
	        '<span class="cropper-point point-nw" data-action="nw"></span>' +
	        '<span class="cropper-point point-sw" data-action="sw"></span>' +
	        '<span class="cropper-point point-se" data-action="se"></span>' +
	      '</div>' +
	    '</div>'
	  );*/
	
	  var _Cropper = window.Cropper;
	
	  Cropper.noConflict = function () {
	    window.Cropper = _Cropper;
	    return Cropper;
	  };
	
	  Cropper.setDefaults = function (options) {
	    extend(Cropper.DEFAULTS, options);
	  };
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return Cropper;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	  if (!noGlobal) {
	    window.Cropper = Cropper;
	  }
	
	  return Cropper;
	
	});


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmMzMGZmMjI0ZWJiOWZkZGI5MmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3NjcmlwdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2F2YXRhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2F2YXRhci5jc3M/NjU4YyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2F2YXRhci5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2Nyb3BwZXIuY3NzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1nL21hc2sucG5nIiwid2VicGFjazovLy8uL3NyYy9pbWcvc2FtcGxlcy5wbmciLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcm9wcGVyanMvZGlzdC9jcm9wcGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQSx5Qzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUYscUJBQW9COztBQUVwQjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBLGlCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFlBQVcsZ0JBQWdCO0FBQzNCLGNBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0EsaUVBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLFVBQVU7QUFDM0UsdUNBQXNDLDJCQUEy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QUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsRUFBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFNBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTs7QUFFQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQiwyQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSwyQ0FBMEM7QUFDMUMsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF3QyxzQ0FBc0M7QUFDOUUscUNBQW9DLHVDQUF1QztBQUMzRSxxQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsUUFBTztBQUNQO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0M7QUFDcEMsc0NBQXFDO0FBQ3JDLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsYUFBYTtBQUNwQyxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7QUFDRjs7QUFFQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFVBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCLHVCQUFzQixjQUFjO0FBQ3BDLGlCQUFnQixXQUFXLFlBQVk7QUFDdkMsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFVBQVUsU0FBUyxNQUFNLGFBQWE7QUFDM0UsY0FBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBLFNBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osa0RBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FB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ZUFBYztBQUNkLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUEsa0NBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsS0FBSTtBQUNKOztBQUVBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CLDZEQUE0RCxlQUFlO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGVBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsZUFBYyxtQ0FBbUM7QUFDakQsZ0JBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0YsRUFBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBLEVBQUM7Ozs7Ozs7QUMzK1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxLQUFLO0FBQy9DLG9EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCLFlBQVk7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLFlBQVk7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7O0FBRUEsNkJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEMsMENBQXlDO0FBQ3pDLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQztBQUMxQyxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekIsdUJBQXNCO0FBQ3RCLHdCQUF1QjtBQUN2QixrQ0FBaUM7QUFDakMsbUNBQWtDO0FBQ2xDLHFDQUFvQztBQUNwQyxzQ0FBcUM7QUFDckMsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQyxxQ0FBb0M7QUFDcEMsc0NBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVULFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPOztBQUVQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDIiwiZmlsZSI6ImF2YXRhci5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDJjMzBmZjIyNGViYjlmZGRiOTJkXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2F2YXRhci5qcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvc2NyaXB0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY3NzICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi9jc3MvYXZhdGFyLmNzc1wiKTtcbiAgdmFyIG1hc2tJbWFnZSAgICAgPSByZXF1aXJlKFwiLi4vaW1nL21hc2sucG5nXCIpO1xuICB2YXIgc2FtcGxlc0ltYWdlICA9IHJlcXVpcmUoXCIuLi9pbWcvc2FtcGxlcy5wbmdcIik7XG5cbiAgdmFyICQgICAgICAgICAgICAgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgdmFyIENyb3BwZXIgICAgICAgPSByZXF1aXJlKCdjcm9wcGVyanMnKTtcblxuICB2YXIgdmVyYm9zZSAgICAgICA9IGZhbHNlO1xuICB2YXIgaW1hZ2VTaXplICAgICA9IG51bGw7XG4gIHZhciBjcm9wcGVyICAgICAgID0gbnVsbDtcbiAgdmFyICRjb250YWluZXIgICAgPSBudWxsO1xuXG4gIHZhciB0ZW1wbGF0ZSAgICAgID0gYFxuICAgIDxkaXYgaWQ9XCJhdmF0YXItY3JvcHBlclwiPlxuICAgICAgPGltZyBpZD1cImF2YXRhci1jcm9wcGVyLXBpY3R1cmVcIiBzcmM9XCJcIiAgLz5cbiAgICAgIDxpbWcgaWQ9XCJhdmF0YXItY3JvcHBlci1tYXNrXCIgICAgc3JjPVwiYCsgbWFza0ltYWdlICtgXCIgICAgIC8+XG4gICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwiYXZhdGFyLWNyb3BwZXItYmFja1wiIGlkPVwiYXZhdGFyLWNyb3BwZXItYmFjay11cGxvYWRcIj4mIzgyNDk7PC9hPlxuICAgICAgPGEgaHJlZj1cIiNcIiBpZD1cImF2YXRhci1jcm9wcGVyLWNyb3BcIj5BdmF0YXIgZXJzdGVsbGVuPC9hPlxuXG4gICAgICA8ZGl2IGlkPVwiYXZhdGFyLWNyb3BwZXItdXBsb2FkXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJhdmF0YXItY3JvcHBlci11cGxvYWQtY3RhXCI+RXJzdGVsbGUgRGVpbmVuIGVpZ2VuZW4gPGI+QlRIVk4yMDIwIEF2YXRhcjwvYj48L2Rpdj5cbiAgICAgICAgPGltZyBzcmM9XCJgKyBzYW1wbGVzSW1hZ2UgK2BcIiBpZD1cImF2YXRhci1jcm9wcGVyLXNhbXBsZXNcIiAvPlxuICAgICAgICA8ZGl2IGlkPVwiYXZhdGFyLWNyb3BwZXItdXBsb2FkLWJ1dHRvblwiPlxuICAgICAgICAgIDxpbnB1dCBpZD1cImF2YXRhci1jcm9wcGVyLXVwbG9hZC1maWxlXCIgdHlwZT1cImZpbGVcIiAvPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJhdmF0YXItY3JvcHBlci11cGxvYWQtZmlsZVwiPkxhZGUgRGVpbiBCaWxkIGhvY2g8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGlkPVwiYXZhdGFyLWNyb3BwZXItcmVzdWx0XCI+XG4gICAgICAgIDxjYW52YXM+PC9jYW52YXM+XG4gICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJhdmF0YXItY3JvcHBlci1iYWNrXCIgaWQ9XCJhdmF0YXItY3JvcHBlci1iYWNrLWNyb3BcIj4mIzgyNDk7PC9hPlxuICAgICAgICA8YSBocmVmPVwiI1wiIGlkPVwiYXZhdGFyLWNyb3BwZXItZG93bmxvYWRcIj5BdmF0ZXIgaGVydW50ZXJsYWRlbjwvYT5cbiAgICAgIDwvZGl2PiAgICBcbiAgICA8L2Rpdj4gICAgXG4gIGBcblxuICBmdW5jdGlvbiBpbml0KHBhcmFtZXRlcnMpIHtcbiAgICBfc2V0dXBDb25maWcoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgdmVyYm9zZTogICAgICBmYWxzZSxcbiAgICAgIGNvbnRhaW5lcjogICAgbnVsbCxcbiAgICAgIGltYWdlU2l6ZTogICAgNjM0XG4gICAgfSwgcGFyYW1ldGVycykpO1xuICAgIF9yZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXR1cENvbmZpZyhvcHRzKSB7XG4gICAgdmVyYm9zZSAgICAgPSBvcHRzWyd2ZXJib3NlJ107XG4gICAgaW1hZ2VTaXplICAgPSBvcHRzWydpbWFnZVNpemUnXTtcblxuICAgICRjb250YWluZXIgID0gJChvcHRzWydjb250YWluZXInXSk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0dXBEb20oKSB7XG4gICAgJGNvbnRhaW5lci5odG1sKCQucGFyc2VIVE1MKHRlbXBsYXRlKSk7XG5cbiAgICAkcGljdHVyZSAgICA9ICRjb250YWluZXIuZmluZChcIiNhdmF0YXItY3JvcHBlci1waWN0dXJlXCIpO1xuICAgICRtYXNrICAgICAgID0gJGNvbnRhaW5lci5maW5kKFwiI2F2YXRhci1jcm9wcGVyLW1hc2tcIik7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgIGlmKHZlcmJvc2UpIGNvbnNvbGUubG9nKFwiUmVuZGVyaW5nIHRvXCIsICRjb250YWluZXIpO1xuXG4gICAgX3NldHVwRG9tKCk7XG4gICAgX3NldHVwQ3JvcHBlcigpO1xuICAgIF9zZXR1cExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldHVwQ3JvcHBlcigpIHtcbiAgICBjcm9wcGVyID0gbmV3IENyb3BwZXIoJHBpY3R1cmVbMF0sIHtcbiAgICAgIGFzcGVjdFJhdGlvOiAxLFxuICAgICAgZ3VpZGVzOiBmYWxzZSxcbiAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICBjcm9wOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjcm9wQm94ID0gJChcIi5jcm9wcGVyLWNyb3AtYm94XCIpWzBdO1xuICAgICAgICAkbWFzay5hdHRyKFwic3R5bGVcIiwgJChjcm9wQm94KS5hdHRyKFwic3R5bGVcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldHVwTGlzdGVuZXJzKCkge1xuICAgICQoXCJib2R5XCIpLm9uKFwiY2xpY2tcIiwgXCIjYXZhdGFyLWNyb3BwZXItY3JvcFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF9jcm9wKCk7XG4gICAgfSk7XG5cbiAgICAkKFwiYm9keVwiKS5vbihcImNsaWNrXCIsIFwiI2F2YXRhci1jcm9wcGVyLWRvd25sb2FkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBfZG93bmxvYWQodGhpcyk7XG4gICAgfSk7XG5cbiAgICAkKFwiYm9keVwiKS5vbihcImNoYW5nZVwiLCBcIiNhdmF0YXItY3JvcHBlci11cGxvYWQtZmlsZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgX3VwbG9hZCh0aGlzKTtcbiAgICB9KTtcblxuICAgICQoXCJib2R5XCIpLm9uKFwiY2xpY2tcIiwgXCIjYXZhdGFyLWNyb3BwZXItYmFjay11cGxvYWRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkKFwiI2F2YXRhci1jcm9wcGVyLXVwbG9hZFwiKS5zaG93KCk7XG4gICAgfSk7XG5cbiAgICAkKFwiYm9keVwiKS5vbihcImNsaWNrXCIsIFwiI2F2YXRhci1jcm9wcGVyLWJhY2stY3JvcFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICQoXCIjYXZhdGFyLWNyb3BwZXItcmVzdWx0XCIpLmhpZGUoKTtcbiAgICAgICQoXCIjYXZhdGFyLWNyb3BwZXItZG93bmxvYWRcIikuaGlkZSgpO1xuICAgICAgJChcIiNhdmF0YXItY3JvcHBlci1jcm9wXCIpLnNob3coKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGxvYWQodXBsb2FkZXIpIHtcbiAgICB2YXIgZmlsZSAgICAgID0gdXBsb2FkZXIuZmlsZXNbMF1cbiAgICB2YXIgaW1hZ2VUeXBlID0gL2ltYWdlLiovO1xuICAgIGlmICghZmlsZS50eXBlLm1hdGNoKGltYWdlVHlwZSkpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGNyb3BwZXIucmVwbGFjZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICQoXCIjYXZhdGFyLWNyb3BwZXItdXBsb2FkXCIpLmhpZGUoKTtcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Nyb3AoKSB7XG4gICAgdmFyIGNhbnZhcyA9IGNyb3BwZXIuZ2V0Q3JvcHBlZENhbnZhcyh7XG4gICAgICB3aWR0aDogaW1hZ2VTaXplLFxuICAgICAgaGVpZ2h0OiBpbWFnZVNpemVcbiAgICB9KTtcblxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHZhciBtYXNrID0gbmV3IEltYWdlKCk7XG5cbiAgICB2YXIgbWFzayA9IG5ldyBJbWFnZSgpO1xuICAgIG1hc2sub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLCAwLCAwLCBpbWFnZVNpemUsIGltYWdlU2l6ZSk7XG4gICAgICAkKFwiI2F2YXRhci1jcm9wcGVyLXJlc3VsdFwiKS5maW5kKFwiY2FudmFzXCIpLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICAkKFwiI2F2YXRhci1jcm9wcGVyLXJlc3VsdFwiKS5zaG93KCk7XG4gICAgICAkKFwiI2F2YXRhci1jcm9wcGVyLWRvd25sb2FkXCIpLnNob3coKTtcbiAgICAgICQoXCIjYXZhdGFyLWNyb3BwZXItY3JvcFwiKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgbWFzay5zcmMgPSAkKFwiI2F2YXRhci1jcm9wcGVyLW1hc2tcIikuYXR0cihcInNyY1wiKTsgIFxuICB9XG5cbiAgZnVuY3Rpb24gX2Rvd25sb2FkKGxpbmspIHtcbiAgICBsaW5rLmhyZWYgPSAkKFwiI2F2YXRhci1jcm9wcGVyLXJlc3VsdFwiKS5maW5kKFwiY2FudmFzXCIpWzBdLnRvRGF0YVVSTCgpO1xuICAgIGxpbmsuZG93bmxvYWQgPSBcIkJUSFZOMjAyMC1BdmF0YXIucG5nXCI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGluaXQ6IGluaXRcbiAgfVxufSkoKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYXZhdGFyLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hdmF0YXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2F2YXRhci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hdmF0YXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2Nzcy9hdmF0YXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Nyb3BwZXIuY3NzXCIpLCBcIlwiKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjYXZhdGFyLWNyb3BwZXIsICNhdmF0YXItY3JvcHBlciAqIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbiNhdmF0YXItY3JvcHBlciB7XFxuICB3aWR0aDogNDAwcHg7XFxuICBoZWlnaHQ6IDQwMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbiNhdmF0YXItY3JvcHBlci1waWN0dXJlIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG59XFxuXFxuI2F2YXRhci1jcm9wcGVyLW1hc2sge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHotaW5kZXg6IDE7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuI2F2YXRhci1jcm9wcGVyIGEsICNhdmF0YXItY3JvcHBlciBsYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogNDBweDtcXG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGJhY2tncm91bmQ6ICNmYWFmMDA7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICB0ZXh0LXNoYWRvdzogMHB4IDFweCAxcHggcmdiYSgwLDAsMCwwLjE1KTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICB6LWluZGV4OiAxMDA7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNhdmF0YXItY3JvcHBlci11cGxvYWQge1xcbiAgei1pbmRleDogMTAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIHBhZGRpbmc6IDQwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbiNhdmF0YXItY3JvcHBlci1zYW1wbGVzIHtcXG4gIHdpZHRoOiAzNDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTQwcHg7XFxuICBsZWZ0OiAzMHB4O1xcbn1cXG5cXG4jYXZhdGFyLWNyb3BwZXItdXBsb2FkICNhdmF0YXItY3JvcHBlci11cGxvYWQtY3RhIHtcXG4gIGZvbnQtc2l6ZTogMjhweDtcXG4gIGxpbmUtaGVpZ2h0OiAzNHB4O1xcbn1cXG5cXG4jYXZhdGFyLWNyb3BwZXItdXBsb2FkICNhdmF0YXItY3JvcHBlci11cGxvYWQtYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIGxlZnQ6IDEwcHg7XFxuICByaWdodDogMTBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuI2F2YXRhci1jcm9wcGVyLXVwbG9hZCAjYXZhdGFyLWNyb3BwZXItdXBsb2FkLWJ1dHRvbiBsYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI2F2YXRhci1jcm9wcGVyLXVwbG9hZCAjYXZhdGFyLWNyb3BwZXItdXBsb2FkLWJ1dHRvbiBpbnB1dCB7XFxuICBvcGFjaXR5OiAwLjAxO1xcbiAgdmlzaWJpbGl0eTogMC4wMTtcXG59XFxuXFxuI2F2YXRhci1jcm9wcGVyLXVwbG9hZCAjYXZhdGFyLWNyb3BwZXItdXBsb2FkLWJ1dHRvbiBpbnB1dDpmb2N1cyB7IG91dGxpbmU6IG5vbmU7IH1cXG5cXG4jYXZhdGFyLWNyb3BwZXItY3JvcCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDEwcHg7XFxuICBsZWZ0OiA2MHB4O1xcbiAgcmlnaHQ6IDEwcHg7XFxufVxcblxcbiNhdmF0YXItY3JvcHBlci1yZXN1bHQge1xcbiAgei1pbmRleDogMTEwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIHdpZHRoOiA0MDBweDtcXG4gIGhlaWdodDogNDAwcHg7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jYXZhdGFyLWNyb3BwZXItcmVzdWx0IGNhbnZhcyB7XFxuICB3aWR0aDogNDAwcHg7XFxuICBoZWlnaHQ6IDQwMHB4O1xcbn1cXG5cXG4jYXZhdGFyLWNyb3BwZXItZG93bmxvYWQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgbGVmdDogNjBweDtcXG4gIHJpZ2h0OiAxMHB4O1xcbn1cXG5cXG4jYXZhdGFyLWNyb3BwZXIgYS5hdmF0YXItY3JvcHBlci1iYWNrIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMTBweDtcXG4gIGxlZnQ6IDEwcHg7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxuICBjb2xvcjogI2FhYTtcXG4gIHRleHQtc2hhZG93OiBub25lO1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2Nzcy9hdmF0YXIuY3NzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBDcm9wcGVyLmpzIHYwLjcuMFxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mZW5neXVhbmNoZW4vY3JvcHBlcmpzXFxuICpcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBGZW5neXVhbiBDaGVuXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE2LTAzLTIwVDA2OjE1OjM2LjIzNFpcXG4gKi8uY3JvcHBlci1jb250YWluZXJ7Zm9udC1zaXplOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2RpcmVjdGlvbjpsdHIhaW1wb3J0YW50Oy1tcy10b3VjaC1hY3Rpb246bm9uZTt0b3VjaC1hY3Rpb246bm9uZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7LXdlYmtpdC10b3VjaC1jYWxsb3V0Om5vbmV9LmNyb3BwZXItY29udGFpbmVyIGltZ3tkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7bWluLXdpZHRoOjAhaW1wb3J0YW50O21heC13aWR0aDpub25lIWltcG9ydGFudDtoZWlnaHQ6MTAwJTttaW4taGVpZ2h0OjAhaW1wb3J0YW50O21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7aW1hZ2Utb3JpZW50YXRpb246MGRlZyFpbXBvcnRhbnR9LmNyb3BwZXItY2FudmFzLC5jcm9wcGVyLWNyb3AtYm94LC5jcm9wcGVyLWRyYWctYm94LC5jcm9wcGVyLW1vZGFsLC5jcm9wcGVyLXdyYXAtYm94e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowfS5jcm9wcGVyLXdyYXAtYm94e292ZXJmbG93OmhpZGRlbn0uY3JvcHBlci1kcmFnLWJveHtvcGFjaXR5OjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5jcm9wcGVyLW1vZGFse29wYWNpdHk6LjU7YmFja2dyb3VuZC1jb2xvcjojMDAwfS5jcm9wcGVyLXZpZXctYm94e2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3V0bGluZTojMzlmIHNvbGlkIDFweDtvdXRsaW5lLWNvbG9yOnJnYmEoNTEsMTUzLDI1NSwuNzUpfS5jcm9wcGVyLWRhc2hlZHtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO29wYWNpdHk6LjU7Ym9yZGVyOjAgZGFzaGVkICNlZWV9LmNyb3BwZXItZGFzaGVkLmRhc2hlZC1oe3RvcDozMy4zMzMzMyU7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjMzLjMzMzMzJTtib3JkZXItdG9wLXdpZHRoOjFweDtib3JkZXItYm90dG9tLXdpZHRoOjFweH0uY3JvcHBlci1kYXNoZWQuZGFzaGVkLXZ7dG9wOjA7bGVmdDozMy4zMzMzMyU7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoxMDAlO2JvcmRlci1yaWdodC13aWR0aDoxcHg7Ym9yZGVyLWxlZnQtd2lkdGg6MXB4fS5jcm9wcGVyLWNlbnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtvcGFjaXR5Oi43NX0uY3JvcHBlci1jZW50ZXI6YWZ0ZXIsLmNyb3BwZXItY2VudGVyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2NvbnRlbnQ6JyAnO2JhY2tncm91bmQtY29sb3I6I2VlZX0uY3JvcHBlci1jZW50ZXI6YmVmb3Jle3RvcDowO2xlZnQ6LTNweDt3aWR0aDo3cHg7aGVpZ2h0OjFweH0uY3JvcHBlci1jZW50ZXI6YWZ0ZXJ7dG9wOi0zcHg7bGVmdDowO3dpZHRoOjFweDtoZWlnaHQ6N3B4fS5jcm9wcGVyLWZhY2UsLmNyb3BwZXItbGluZSwuY3JvcHBlci1wb2ludHtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3BhY2l0eTouMX0uY3JvcHBlci1mYWNle3RvcDowO2xlZnQ6MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmNyb3BwZXItbGluZSwuY3JvcHBlci1wb2ludHtiYWNrZ3JvdW5kLWNvbG9yOiMzOWZ9LmNyb3BwZXItbGluZS5saW5lLWV7dG9wOjA7cmlnaHQ6LTNweDt3aWR0aDo1cHg7Y3Vyc29yOmUtcmVzaXplfS5jcm9wcGVyLWxpbmUubGluZS1ue3RvcDotM3B4O2xlZnQ6MDtoZWlnaHQ6NXB4O2N1cnNvcjpuLXJlc2l6ZX0uY3JvcHBlci1saW5lLmxpbmUtd3t0b3A6MDtsZWZ0Oi0zcHg7d2lkdGg6NXB4O2N1cnNvcjp3LXJlc2l6ZX0uY3JvcHBlci1saW5lLmxpbmUtc3tib3R0b206LTNweDtsZWZ0OjA7aGVpZ2h0OjVweDtjdXJzb3I6cy1yZXNpemV9LmNyb3BwZXItcG9pbnR7d2lkdGg6NXB4O2hlaWdodDo1cHg7b3BhY2l0eTouNzV9LmNyb3BwZXItcG9pbnQucG9pbnQtZXt0b3A6NTAlO3JpZ2h0Oi0zcHg7bWFyZ2luLXRvcDotM3B4O2N1cnNvcjplLXJlc2l6ZX0uY3JvcHBlci1wb2ludC5wb2ludC1ue3RvcDotM3B4O2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi0zcHg7Y3Vyc29yOm4tcmVzaXplfS5jcm9wcGVyLXBvaW50LnBvaW50LXd7dG9wOjUwJTtsZWZ0Oi0zcHg7bWFyZ2luLXRvcDotM3B4O2N1cnNvcjp3LXJlc2l6ZX0uY3JvcHBlci1wb2ludC5wb2ludC1ze2JvdHRvbTotM3B4O2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi0zcHg7Y3Vyc29yOnMtcmVzaXplfS5jcm9wcGVyLXBvaW50LnBvaW50LW5le3RvcDotM3B4O3JpZ2h0Oi0zcHg7Y3Vyc29yOm5lLXJlc2l6ZX0uY3JvcHBlci1wb2ludC5wb2ludC1ud3t0b3A6LTNweDtsZWZ0Oi0zcHg7Y3Vyc29yOm53LXJlc2l6ZX0uY3JvcHBlci1wb2ludC5wb2ludC1zd3tib3R0b206LTNweDtsZWZ0Oi0zcHg7Y3Vyc29yOnN3LXJlc2l6ZX0uY3JvcHBlci1wb2ludC5wb2ludC1zZXtyaWdodDotM3B4O2JvdHRvbTotM3B4O3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7Y3Vyc29yOnNlLXJlc2l6ZTtvcGFjaXR5OjF9LmNyb3BwZXItcG9pbnQucG9pbnQtc2U6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi01MCU7Ym90dG9tOi01MCU7ZGlzcGxheTpibG9jazt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2NvbnRlbnQ6JyAnO29wYWNpdHk6MDtiYWNrZ3JvdW5kLWNvbG9yOiMzOWZ9QG1lZGlhIChtaW4td2lkdGg6NzY4cHgpey5jcm9wcGVyLXBvaW50LnBvaW50LXNle3dpZHRoOjE1cHg7aGVpZ2h0OjE1cHh9fUBtZWRpYSAobWluLXdpZHRoOjk5MnB4KXsuY3JvcHBlci1wb2ludC5wb2ludC1zZXt3aWR0aDoxMHB4O2hlaWdodDoxMHB4fX1AbWVkaWEgKG1pbi13aWR0aDoxMjAwcHgpey5jcm9wcGVyLXBvaW50LnBvaW50LXNle3dpZHRoOjVweDtoZWlnaHQ6NXB4O29wYWNpdHk6Ljc1fX0uY3JvcHBlci1pbnZpc2libGV7b3BhY2l0eTowfS5jcm9wcGVyLWJne2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUFRTUFBQUFsUFcwaUFBQUFBM05DU1ZRSUNBamI0VS9nQUFBQUJsQk1WRVhNek16Ly8vL1RqUlYyQUFBQUNYQklXWE1BQUFyckFBQUs2d0dDaXcxYUFBQUFISFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JHYVhKbGQyOXlhM01nUTFNMjZMeXlqQUFBQUJGSlJFRlVDSmxqK00vQWdCVmhGLzBQQUg2L0QvSGtEeE9HQUFBQUFFbEZUa1N1UW1DQyl9LmNyb3BwZXItaGlkZXtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjB9LmNyb3BwZXItaGlkZGVue2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNyb3BwZXItbW92ZXtjdXJzb3I6bW92ZX0uY3JvcHBlci1jcm9we2N1cnNvcjpjcm9zc2hhaXJ9LmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZHJhZy1ib3gsLmNyb3BwZXItZGlzYWJsZWQgLmNyb3BwZXItZmFjZSwuY3JvcHBlci1kaXNhYmxlZCAuY3JvcHBlci1saW5lLC5jcm9wcGVyLWRpc2FibGVkIC5jcm9wcGVyLXBvaW50e2N1cnNvcjpub3QtYWxsb3dlZH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2Nzcy9jcm9wcGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XHJcblxyXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpXHJcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQW5vQUFBSjZDQVlBQUFDL3F1OE1BQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBTjlaSlJFRlVlTnJzM1FlOEhHZDVMLzVuZDQrcVpSWExSVzZ5Y1pWN3d3VjNzTUdZSGpxWWt0QnV1Q1MwRUhyTmhVQzR1WkEvb2VVU3lzVVlRZ3NHUWpPR0dEREcyT0FxdVhjYnkxMldaTW1TcGQzOXY3TjdjSlYwOXB5enV6T3orLzErUGk4R2ZJNDArOHc3TzcrWmVlZDlLODBrQUFBWU9GVWxBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUFROUpRQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFFUFNVQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFCRDBsQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFBUTlKUUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBRVBTVUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBQkQwbEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQVE5SlFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQUVQU1VBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUJEMGxBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUFROUpRQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFFUFNVQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFCRDBsQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFBUTlKUUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBRVBTVUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBQkQwbEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQVE5SlFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQUVQU1VBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUJEMGxBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUFROUpRQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFFUFNVQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFCRDBsQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFBUTlKUUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBRVBTVUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBQkQwbEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQVE5SlFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQUVQU1VBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUJEMGxBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUFROUpRQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFFUFNVQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFCRDBsQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFBUTlKUUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBRVBTVUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBQkwzVUtsckhiV3BxYzFPYmw5cXVxUjJlMmpOU2UyMXE3MDd0UzZtZG5kbzlCZHZQSDdUdlN0bk82bURmemgyQXo5bHRadzFBVFo0enhtZGNsbHB0QUQ3bnN3cncvZmpXQWZtKytNTVluL1BOUS9UZCtjTSs5WjEvS2NNNVpFVFdIWmQxcVMwZi9lLzNwbmJkSm41Mnk5UU9TZTJZMUk1SzdiRFVaaW9oMEFYelJyOVR6aTM1NTdpa0FOdXdlQUQ2dzFhcEhleXdlTkJwcVQxVEdSNjZvMGR2M0pYYXoxSjdiMnBQSEwzejh0VFV2cGphSGNvRFROTEpBL0FaYmt6dHZweTNZY2tBMVBFcHp1ZVA4TU1DOUN0QmJ3aXRHdzErcjBsdDI5Uk9TdTI3cWExWEdtQUNUaHFRejNGNWpuOTM5bVRtMWdHbzRWTWREbyt3T3JVZktJT2dsNmRHYW1lazl2eG9qL1g3MTlRZVVCWmdIQTVOYmY0QWZJNGxRL3AzZDBzMkZ1c3BEb2ZIT0UwSkJMMml1Q20xTjZhMlcycmZVQTVnSE4vZlR4NkF6NUhuT0wxTEI2QisyZGk4clIwT2o1SGRUTGxiR1FTOUlyazV0WmVtZGtKcU55Z0gwSUZCR0tkMzJaRCszZDNpc2UyR1pjT2l2cTBNZ2w0Ui9USzEvVlA3bGxJQVl4aUVSM1o1aHExQmVPTlcwTnU0cnl1Qm9GZFVLMU43VVdydlRLMnBITUJHTEVqdG9KSi9odXhweHZLYy91NnlqOUdiazlvUkRvT05PbnUwZndsNkZOWS9wZmFLMU9wS0FXekVJTHg5bThlZHRUdWovRk5kblJqbXc5MlU3RWJKZndoNkZOM1hVbnRWdUxNSGJKaHhlaE96eEw0ZkNrUC9rcU9nVnc1ZlRlMTl5Z0Jzd0pHcGJWN3l6N0JrU1A3T2JqdEo5eC9UaGFsZEllaFJCaDlKN1QrVkFYaVU3TkhkaVNYL0RJdUg1Ty9zcG4xVDIwSDM3OGhRdjVRaDZKWExhMk13Wm5FSHVxdnNiMTdtRWJyS2ZrZlAzYnpPRGZYalcwR3ZYTzVKN1UzS0FBeFkwTHQ5OVB0dDBNTmxOeG1mMTdsclVqdFAwS01zdnBQYWZ5c0Q4REFMVTl1cjVKK2huOEhydHRTV2xiaFdNMU03V3JjZmw2RzlxeWZvbGRPN2xBQjRGSTl2TzFmMnBjK2VsTm8wWFg1Y3ZobnRkZVlGUFVyaDk2bWRwUXpBQUFXOUpRUDZkL1dDOFhuanR6U0c5R21Zb0ZkZW4xWUM0R0dPVFcyR29EY1VRYy80dklrWnlzZTNnbDU1L1NENlAzZ1pLSzdwcVIwdjZIWGtzaExYYWRmUnh2aDlON1cxZ2g1bHNTNjE3eWtEOERCbGZueDdWN1Jma3VpSE1vL1JjemR2NHU1TjdhZUNIbVh5WXlVQUJpVG9aZnB4cCsybTFGYVd1RWJHNTAzTzBEMitGZlRLN1d3bEFCNW1qOVFlVitMdDc4ZWJ0MlYrYkRzMTJtL2NNbkhmVCswK1FZK3l1Q08xcTVVQmVKZ3kzOVZiTWlCL1I2OGNFKzA1OUppNE5URmt3NTRFdmZJN1Z3bUFBUWw2L2Jpalozd2VRN1gycmFCWGZsY3BBZkF3SjZRMnBhVGI3bzdlcGhtZjF4MW5wbmJuc0h6WWtaSnU5ODZwZlhJai8yNTF0RitmWHA3YS9hbmRITzExN2k2TzlxUE9RWE85WXhaNG1NMml2VHhXR1NlSHpiNjMvNVRhOWozNjg1dXBYVjdTL2JwamF2dnEzbDJ4UHRyTGliNWUwQ3V1T2FrOVp3Sy9kMFcwQjJKK09iVXJCVDFnUUowYzVWMEZZSEVQZzk0TnFhMHFhVjJlb2x0MzFkZUhKZWdOMjZQYlJhbTlJOXB2WFdVN2VjRUFmS1piSGEvQW81VDVFVjh2SDYyV2VYemUwM1RycnNwbXJiaEowQnZzei8yUzFDNU03ZENTZjViVmpsZmdVZlpQYmJ1U2Juc3ZYOGdvNjlRcXRUQ3RTaThNeFp4NncvNHlSblpINzR6VWRpbnhaMWpyV0FVMm9LeDM5UzRyNlovZFMwZW1ObGVYRnZRRXZZbkpEcDR2bFhqN2w5dUZ3QWFVZFNxTzdORnRzMGQvOWlVbHJZbnhlYjF4Y1pSN0FtMUJieHlPaTNJdkJnN3dhQ2VXOURzK1c3WGd4aDc4dWZWb3Y1QlhSc2JuOWM3QXo2azNZaDgvNkpUVXppcmhkcy9vNEdmK09pYjJsdkprWlMrS1BMM2svV0xieUc5TjRkMGNsa3pDdk5TT1NPMmNFbTU3ZGxkdjV5Ny9tZGRGT1llNmJKWGFnYnB6ejJTUGJ6OHM2QTJINDBxNjNiTTYrSmtGa2M4YnhvTXdwbVNxTDFsSzdLU1NCcjNMZW5DUldOYUprck9WVGp4OTY1M3NBdURjMFl1aWdhVHpQQ1I3SWFPTXM4bHZhZGNCRzFIV2NYcTltQWJGK0R3MlpxQmZ5aEQwSGxJcmFXamF6cTRETnVLUTFPYVhjTHQ3TWNWS0dRZmRWNkxjYXhlWHhiZWlQWVpUMEJzQ1UwdTR6WHZZYmNBbXZ1UExHQlN5bHlZYWdsNGNISjdhOU1OdFVkNlZaQVM5Y1ZwWHdtM2UyMjRETnFHTWovNnlkY3E3dWJ6aitpam5HN2ZldHUyZmdYMThLK2c5Skx0NnZLT0UyLzBFdXc3WWhPeU9YcVdFMjkzTmNYcFhsdlJDM3ZpOC92bE9ET2dDQklMZVE2NGJ2ZW9yayt5TjJ3UHNPbUFUdG81eXZqbmV6YmRreS9qWWRxNEwrYjVha2RxUEJ2R0RtVjdsSVdXY2d1RHA5aUVENEN0ZC92T3VVTkxIeUI0QlhsaXliZTVtT0N2ajFDb25SUHNsUWZvbmUzejdYRUZ2Y0oxZXdtMStudDNHQVBnckplaTU3QkhnUjBxMnpZc0wrbWYxTTV6VFgvOFY3VHQ3c3dmcFEzbDAyNVl0dC9QRGttMXo5amptMlhZZDBJRWpVNXRUc20yK1BMbzNuS2FNUWU4azNiYnYxa1E1Yi9vSWVoMTRXNVJ2Zk40Ym9welR3UUQ5bHoyOWVWTEp0amw3ZWVLYUx2dzVEM1Rweittbi9WTGJYcmZOeGNDdGZTdm9SWHc2Mm0vYmxFazJBZXFiN0RwZ0hNcjRLTEFiNC9TeU1adGxtd3pYM2J6OG5CbmxuSUZEME51SVQ1VTBNSDB3eXZjWUJzaFhHYWZxNk1heVpXVjhiSHV5N3BxYjdLTGcyNEplK1dXMzhaODFHdklhSmR2MjQ2UDkyQlpnUEJhbXRrL0p0bmxKUWY2TWZwcVoydEc2YTY0RzZ2SHRNQVc5KzFMN1FXb3ZURzFSbE8vbGk4eFcwWjZLb3VJNEJDYWdiSGYxdXZIb3RteEJMNXRXWlJqSFg3KzBRTnVTVGJkMjQ2QVV0cXpUcXl5UGpiOFprdzNnWFJYdEpYUnVHOTFaMllGK2NaUnpadlEveXc3ODc2VzJrM01WTUVIWk9MMVBsbWg3cnhyOTNwNHlSRUZ2V01mbnZTNktkU2N0bTFQdm5ZSmVmbTVJN1MrRzZBQ1ludG8zVXp2S2VRcVloR05TbXpGNklWd0dmMTZqZHI4Si92N3ExSzR0MlQ0YTF2RjUyVTJNYkNXUTN4VmtlMDRibEtEbnJkdmkyenpheTdJOFN5bUFTWm9XNVp0bVpUSjM1TEtRMkN6Ulo5MHR0VjJHdUgrK3BFRGJzampLK1NLUG9GY3llNlgyaHhKK01RUEZWYlpIZzVNWnAxZTJFL1d3djIzN29vTGxrb0Y0S1VQUUs2YnNaWXUvVGUyODFQWlFEbUNJdzhSa3d0cGxKZnVzd3o1L1hyYmkwd2tGMnA3L2lITGRFUmIwU3VMeHFaMGQ3VG4rWmlrSDBHVmxleng0YVU2LzIyL1pZL1VuNnA3eDRnSnR5L1dwL1Y3UW8xdXkrYTIrRysyN2VFY3FCOUJEWmJxcmQxMjAxeUNkaURLOWNadTlLRE5UMTR6blJiR21semxOMEdPeTlYOU9hcjhjdmZKOGJwZ2pEK2k5TWowaXpDYTF2MklDdjVmTm5WcW11ZENzaHRHV3JmcFVwT1g2dmhYbFcwSlAwQ3RBelk5TDdYT3BMWTMyM0hoUEZQQ0FQc3BlOENyVHBMd1RHYWRuZkY1NUZlbnhiYmJ1N1MvS1hNd1IvYWx2VnlpbnBIYmlhS2licXlSQWpqYUw5akpidnh6Z29GZW1OMjUzalBJdFQ5ZEx6eHJ0bzZzS3NqM1oyN2RQS1dzeDNkSHJqNnl6L2piYWQrKytrTnBaTWZFeEp3RGRVS1pIaFJPNU8xZW1vUGRVM2ZFUnNrbTluMU9nN2ZsZW1jL1pnbDUvWkxPN1owdXduWnJhMjZOOVYyK0wwU3VFYkRtaXBVb0U5Rm1aSGhVTytxTmJRZSt4aWpSNThvcG9MMXdnNkRFdTJSSkVQMC90cmFudE1QcWwrKzFvRHp3RzZMVnNXYkh0UzdLdE4wVDc1WXBlaDhNODFLSTlySWRIeW02RXpDdlE5cFIyOG1SQnJ4aXljSGRHYWk5TWJWRnEveDd0dTRBQXZWU1dPMG5acExXWGorUG43MDN0VHlYNWJObDBXck4xeGNlWU1ucE9MSXJzanQ1eVFZOXV1RHExMTZaMllHcS9VZzVBMEd0WjBxT2Z0UStLcTBodjM2Nk45bGc5UVkrdWZxa2RuOXFyb3podkhnR0RKWHRrV0J2QW9HZDgzbUE0TnJWdEM3UTkzeEQwNklVdnBYWll5YTVRZ1hMSXBubzZvaVRiT3A0eGQyVloraXhiMi9VZzNYQ1RHYVZJTDJXY0dlMTU5UVE5dWk2N09zM0djWGlVQzNSYldlNG9qZWRpdHl3dlltUXY0WmtzZjlPSzlQZzJHMC8vVFVHUFhsa3grcVh3QTZVQWhqRG8zVHo2UGRqcHhiSGFENFpEVTl1dFFOdFR1clZ2QmIxeXlRYUR2aWkxM3lnRjBDVUhwN1pWU2JhMWt3QjNkMnEzbCtDelpIZnlucUw3ZGFSSWQvVituOXAxZ2g2OWxNM09uUzBQYzVWU0FGMDZENVFsY0Z6YXBaOHBnc2VudHFYdTE1RlRDclk5L3lIbzBXdlpIRkhabmIyMVNnRjB3U0NOMDF1aTVnTW5tMS8yZ0FKdFQ2a21UeGIweXV1aTFONmxERUFYWkhmMHl2QlNRQ2NoenZpOHdmVGlndlhEc3R3NUxtM1F5N1o3emtiYXlCQjEvRTlGZXcxZGdNbklwdms0ZUVDQ1hobnU2R1hUMmh5dTI0M0xTd3UyUGFWNUthT3NRUzliby9IZWpiUjEwVjQrYkZscXQ0eW03bXpwa2srbTlzclVkaDJnamw5UDdZMk9mNkFMeW5DSGFXbHE5NHp4TTVlVTRITThPY296VVhWUkxJejJOR05Ga1kzVGF3cDYrYW1OWGpGbEMzYnZtOXJUVW50emFsOUo3WnJSOW8rcDdUd0FuL1hYcWYzU2R3QXdCRUV2czZrNThtNGJ2Y2hYNjhGVXBNbVRiNHlTVEhjMnJHUDBzcnQ2MmZpMmJGM1pmMHR0aTVKL25vODYvb0ZKeWxiSW1GT0M3YnhzZ3Y5TzBDdS9GeFlzdDV3bDZCVmZOcDd2ZGRFZTUzWklpVC9IbWFPaEZXQXkzNGNubG1BN04zVkhyd3dENUxPaFI5dnBiaE95ZFVuNnFLQlhRRHVrOW90b1ArWXRxNi9halpUVW5DNjN6WlIwd2s0dWVkQmJyTVlENzhWS0lPaE41bVR6bmRTbWxuVDd2MmtYVWxMM2RybjlsNUpPMkVrbDJNWk52VlY3bVJvUHZPZVcrRHd0NkJYQW5xbTl0cVRibmoyNnZjNHVCQ1loZTdwUjlDY2JkNlYyNXdSQ1lCSE1TdTFvM1d4U3Nwc3lUMWNHUVc4eVhsUGliVC9UN2dNbXFReDNuRFkwRnUvbTFKWVhmTHVmR081R2RZUEh0NExlcEJ3WTdRR2ZaWFMrM1FkTVVsbkg2UzFSMjZIeHpEQVdWOUNicEgxS3V0MFgyWFhBSkdXUEZtY1dmQnN2Ni9EL0t4cmo4N3BqUm1wL29ReUMzbVNVZFY2OUsrdzZZSkttcGZha0VnYTlvcjl4dTBkcXUraGVYZk1TSlJEMEpxT3NTOVBjRjhVZm93SVVYOUh2UEcxb21iTkwxWFNvWk12SWJhRU1ndDVFclM3eHR2L0o3Z01tcWVoanlaWS82cnN1VzNQMGNqVWRLbE5TZTRFeUNIb1RkVnVKdC8wQnV3K1lwRjFIVzVFOS9QRnR0dTdvcWdKdmEvWTQvRGpkcXVzOHZoWDBKaVM3TXJ5cXhOdC9yMTBJZEVIUjcwQXQyY2gvTDZJczVNM1VwYnJ1bU5TMlZ3WkJiN3l1VEcyRk1nQkRya3pqOUl6UEc5NE04eUpsRVBURzYvU1NiNys1aFlCdXlONjhuVmJnN2J0c0kvKzlpSXpQNjUyWEtvR2dOeDcxMUw1UThzOHd5MjRFdWlCNzFGams1Ym9lSHU2S1BMWEtqcW50cFR2MXpDR3A3YTRNZ2w2blBoL2xYeTkydnQwSWRNblRDcnh0SzZQOUVrWjJnVjdrT1VUZHplczlTNklKZWgzSlZwVjRSOGsvUTdhRzRsWjJKZEFsVHluNDlpMGV2VGkvdjhEYitGVGRxT2M4dmhYMHhuUkJ0QWZMcmlyNTU5ZzV0WXJkQ1hUSnZ0Ris5RmhVMmVQYklyOXhPNUxhQ2JwUnp5Mks5anIxQ0hxUHNUYTFqNlYyWkdwM0RNRG4yVWVYQnJxc3lIZjFsaFE4NkdYbmx0bTZVRjk0ZkN2b1BjSU5xWDA0MmdNNDN6VWErQWJCUWJvMDBHVkZIcWVYVGF0UzVCY3hQTGJ0SDVNbmI4VElnSDZ1YkhtY2JPTGpiRDY4dTFPN09iWHJVN3M0dFhPaVBWZmVJRHBLbHdhNkxKdG1KVnYvdTE3QWJWczhldUV1NkxGdzlCejRXNlVZaktDWEJUWmowUjVwZW1wSEtBUFFaWE9qL1FqeU53WGN0bXpKeDNzS1dyZHR3cml4Zm51Sm9QZFlYc1lZckt0dVMrd0F2ZkFVSlJpMzdBVS9OeVQ2NndWeWphQTM2QjBjb0JlZXBnVGo1ckZ0LzIyZDJwT1ZRZEFiUk5tZHZPY3BBOUFqMlNOSWMzUjJMcnVUNXk1b1ByeDlLK2dOcEplbnRya3lBRDA4VjdoRDFibER3eXBGZWZtTGFDOGVnS0EzVUZlT2IxWUdvTWRPVW9LT0NjWDVtWlBhTTVSQjBCc2syVzNxUmNvQTlDSG9lYmxBMEN2TGVSRkJieUJNUyswanlnRDB3WmFwSGFJTVk1cVgybUhLa0t2c2p0NHNaUkQwQnNFN1VudWNNZ0I5Y3JJU2pDbDc2N09tRExtYWtkcHpsRUhRSzd2OVUzdTNNZ0I5Wkp6ZTJEeTJMWVpUbEVEUUs3TnNPcFhUb3Yzb0ZxQmZzdFYzNWlxRE1Gd0NKMFI3dUlHZ3B3U2w5RytwN2FzTVFKOWxqeVJQVklhTk9pQzE3WlNoRUthRStXVUZ2Wko2ZjJvdlV3WWdKOGJwYlp5N2VjWGk4YTJnVnpxdlQrMUR5Z0FJTTBJd1l6b3F0UjBFUGNvaW14VDVNOG9BNUd6NzFQWlRoc2ZJcHZNNFVoa0tsM0ZlcEFnVVhUWkI2Y2RTKzJTWXJCUW9CbmYxSGlzYi9HL3ByZUo1aWFCSGtXVnZ0MzAvMnZQbEFSU0ZSNVRDYjFsa2szenZJZWhSUk5ramdJdFNlNlpTQUFWemRHcWJLWVB3V3hKRHZTU2FvRmM4MlpkbjlwajJONm50cEJ4QUFXV1BLSitrREEvSzdoanRyQXlGTmRTUGJ3Vzk0c2pHMzJYVHBsd1o3UmN2N0J1Z3lLd0E4UkIzODRwdFVXb0hDWHJrNmRtcFhaRGFxZEYrb3cxQTBDc1A0L09LYjJnZjN3cDYrY21XTVh0TmFwZWxkbnBxQnlvSlVDSzdwTGE3TXNUMDFJNVhCa0ZQME9QUHNwY3NQcHZhMHRTK2tOcGVTZ0tVbEx0NkVjZW1Oa01aQ205aHRGOGlFdlRvdW1uUlhodnlVNm5kbU5wdm83M0N4V3lsQVFTOTBqTStyenlHOHFXTUVmdTk2N1pJN2REVWpranRtR2d2d1RKZFdZQUJkUHpveGV6YUlhNkI4WG5sOGZ6VTNwaGFYZEJqVTJxcGJaWGFndFMyaWZacjlka2JQWHVQdHEyVkNCZ1MyVmpqN05IbHo0ZjA4MmRUWUJsK1V4N1orVGw3d3ZhellRdDYzN1B2TjJydTZEK3p4NnhUUndOZTFqenk3dnlnS252L21sbnc3VHN0dFhXNjJpUHNPd0Q5YnRzU2JXczI3K2ZWUTlyWEZwUm9XMThkeFg1cHBGODNTZjRsdFN1RzZMc3dLczNFZVFFQVlQQzRNd1VBSU9nQkFDRG9BUUFnNkFFQUlPZ0JBQ0RvQVFBZzZBRUFDSG9BQUFoNkFBQUllZ0FBQ0hvQUFBaDZBQUFJZWdBQWdoNEFBSUllQUFDQ0hnQUFnaDRBQUlJZUFBQ0NIZ0NBb0FjQWdLQUhBSUNnQndCQWI0d29BVUFYMU8rUDV2MDNSenh3ZDZzMUg3Z3pZdDN5OUMrYTBXejk4eUdWNnJTSTJvejBYOUpYOE1pc3FFemJPbUxxVmhFenRvdEs5cy9xVlBWczFsTTliNGxJTlcydStWT3E1YjJwcnN1aTJWanp5RnBXcHFUYXpZdVlNaThxMHhkRVROOGhLak4zVXNQTTJqdWl1ZmIyOWo5Yi9mS2VpS3grOVRXUHJlUEk3S3hqcG42NTJVTjljdnAybzMxenZscG0xcTlNZmZLbWlOVTN0NC92MUI5ajNiTHNDSDlVTFdlMSttTld0OHIwN1ZOL1hCZ3hiUnRCRDZBVUdtdWplZStGcWYyeDNWWmRFN0hxMmhSR2J1M2UzNUVDUzJYV29xaHN2bmU3emRrdktuTVBTeWZoNlFNYTZoclJYSjVxZXM4NXFaMGJ6UldYUnZPK0sxS3QxMDNzejZ2VTBzbjFjVkdabmVvMjc3Q296RDh5L2ZPSXdRMS9hMjZMeHIzblJYUFpIeUpXTEU1OU12WEgxZGVsWUhKZmQvNzg2cFNvYkxaYnEwL0c3SDFUbjB4OWMrN2owLy9lWTNDUDgzUmgwYmo3MSszK2VHOVcxeVdUTzhaSE5tOGZ5M01QU24zeDhOUW5qMDAxM2FVdkg2WFNUSHh6QTJ3MGhiU0QzZTAvanNidFAwa24wL1BTLzdXKy81dVJuV3hib2VXNHFHNTFRbFMyUEs0VmFFcXJ2aWJWODBmUnZQVTcwYmpqalBiZHBsNnF6V3pYYmJ2blJuWGJaN2Z2dUpUVitoV3BabWUyK21RejFhNTFKemtQMDdhSjZwYkhwejU1ZEZTMmZWWlVaaXdzOTVHKzZyclVINzhiamFXbnArUDgzTllGU0U4RFdBcDZsVzJlSHRYdFg5Q3FZZnAvQkQyQWZuN3BOMjc2Y2pSdi9ITDcwV0hSVE5zcUJaWVVXblo0U1FwOXgvYnNKTkgxdXE2OEloclhmeVlhTjMrdC9UZzJEOVZwclpOcjlYR3ZqOG9XUjVha1E5WlRzUHRKTkc3OFVnckkvelh4dTUyOURDN3pEbStIbHF4UFR0K3VKSFZkSDQxYi96TWFOL3hiTk8vOFpYNjFTNkd2dXROcm9ycno2N3IrcUZ6UUEzajQ5LzdkdjRuNkZmK1F2dlRQTE0wMlZ6YmZKNnE3dlRtRnZwY1Y5dkZ1YzhVbDBiajhnNjI3SlJIRk9lMVU1aDhWdFVVZmlzcFdKeFJ6NTlidmI0V1F4dFgvWE13TGpnMEc2U2twOEwwd3FydStOU3B6RHk1dXdFc1hjWTJyUGhyTjFkY1haN3RxbTZXdzk1cW83ZkdlMXNXY29BZlFyZS85ZS84UTljdmVHODA3ZmxiZUQ1Rk9ETmtKSXJ0VFZaanhhR3Z2alBxU3QwZmpwdjlYcUlEM21KUGgxaWRGYmY5UEZXZmNXV05kTks3L2JOU3YvbGhyREY1WlpRRzZ0dmRIb3pMdjBPSWM2M2VjRWZWTDNoak4rNjRzYnVGR1pxVmorZDNwQXU1dHJlQXM2QUZNMVByN1VzQjdaelN1KzJ5aGc4aTR2dGhUV0trZDhKbDBrajB4MzZ4eTgybnBoUHEzclRjVFN5R0Y0OXFpRDBSMTkzZmtPdjR4R3dkYXYrQ3Zvcm55c29FNXpLbzd2U3BxKzN3ODN6ZDRVeitzWC93MzBiamw2K1U1bGpmZksycUhuQnFWdVljSWVnRGpQcUd1dUNUcXYzOWUrODNaQVZUZDVRM3A1UHJQL1grY1cxOFY5UXRmVjZvVDZpTk9qUE9QanBGRHZ4VXhmZHQrOThqV284VDY1ZTl2amNrYk9OTVh4TWpCWDJuZFBlMzdzWDdQNzZKKy9ndmJVL2FVcmtPT3BPUDRvMUhkN2U5aUltTnhCVDFnS0dWanhlcC9lR2xyRE5RZ3k4WkkxUTQvUFNvemR1elBDWFgxalZFLzk1bXRLVkpLSDBvTy8zN3JUZWYrZE1pMVVmL2p5NlB4cDI4UCtKRlhpZHFpRDBaMTBmdWlYeThRTlc3OFl0UXZmbjBoWDJBWjE0WGI5aStLV2dySzQ3MXdFL1NBNFF0NTJTUEZDMTdSOCtrVENuTnFuYjVkMUk3OGFXdGV1WjZHdkJUdTZ1ZWNYSjZYQnNaU214RWpoMzAzS3R1YzNOdS9wNzQ2MXYvdUdkRzg2NytINWhpc0xueGwxQTc2WXM4ZmtUZXUrRkRVci9qZzRCekw4NCtOa1NOK0VERmxqcUFIc01Fdi9xWGZpL3A1engrYWtQZWdxVnZHeURHL2JvMzU2VlhJVzMvMmt5SWV1R3ZBRXNtVXFCMzJuYWd1ZUZhUDBuRTloYnlubC9zbG9JbVdkc2RUV3VQUGVuVm5yNzdrbmRHNCtwOEc3OEp0M21FeGN1UVpIWWM5YTkwQ1E2TzUvS0tvLytHVTRRdDVtUlRBNnVlY0ZKRXRpZFh0dXE2K01kYi85c21ERi9KYVZ3YnJvbjcraTZONTk5bTlDU09Ydm5rb1ExNnJ0Tm1kOWNWdjc4MmZmYzMvR2NpUTF6cmVscDBYNjg5TkZ4Nk5Cd1E5Z0FkbGI5ZWU5NEtCSDVPM3lSUEUvVGZIK3F3RzNSem92MzVsMUg5M2NrOENaR0drUHJQKzk4OXBMUzNXMVRDU3JjSnczYWVIK3JCc1hQUFAwZmpUTjd2N1oyWjM3UmYvL1dBZnkzZi9PdW9YdmtiUUEzandYSDM1ZXdmMjdkcnhuU0IrRTQyclA5Njl1bDd3cW1pdXZIendDL2ZBM2VsQzRYbmR1MURJN3JCZTlOY096S3dQWGZRL3V2WTJiUE8rcTZMK3gxZkVvRXlWdE1sQWUvT3A2VUxoTTRJZVFEWitiTmp2bkR6aXhIckZoMXBMdkUzNlJIUEQvNDNHcmQ4Wm5uNjAvT0tvTCtuT25hTDY1ZThiekVmZEU3RnVlVFF1ZlVzWGtrLzJtUDFGcmJ2M1EzTXNMMzVyK241YkxPZ0J3NjJSblZRSGNWNnlDUmRrYlRTdS9JZkpoWjdWTjBUOTByY09YK211Kzh5azM0N05IZ0UzYnZpQ2Z2and1cVlMaHVieUN5Y1hlcTc2U0dzYzduQVY3b0dvLy9GbHJTWGRCRDFnS0dXckN6U1dmbDhoSG4xK3VQbHJrM3FVM2Jqa2phMkprWWRSL2FMWGR6d1Fmb08xdStZVExqdzJWTmRzb3VpSkh1ZjNYZDJhYkhvb3YrT1dYeHlOYXo4bDZBRkRHbWl1LzV3aWJQRHNVRSsxK2JlSi9lb2RQNHZHYlQ4YzN0TGRkMlU2c2Y1L0Uvdmw5U3RTeVA2cS9yZWh1dDcybzlhZDRnbUZ4RXZmTktud1hmcVFuTTBWdVBaT1FROFl0cFMzTGhxM2ZFTWRObGFlVzc0Mi9qdEx6VVpyZnJKaFY3L3FIeVBXM1R2K21tZDNsNGRvRE5rNE8xYzBiejUxL0w5MTE2K2llZnRQaHJ0MDJkdnZWMzFZMEFPRzdMUng5NjlhYjB1eUVXdHVhNzJGTzc2Z2N2cndqWVBha0JUeUpuSlhyL21uNzZqZHB2clhyZDhkZitnZW9KVXZKbFc3NnorZmp1bWxqL24vUjVRR0dOZ3Z2dHQvbXU4RzFLWkhkWnRuUkdYK2tSSFR0bWxOemRGY2VVVTBiL3QrYTB4UklXcDAxMWxSMi9MNHpuLys2by9wV0g4T0dOZjlhMVIzZjF2YXo1dDFXTHdIb25IbkwzTGQ1c3FzM2FPeTRKbnBuM3UydHp0ZENEV1gvYTRWNEtPK0p2K0xzK1dYcEcyNkoyTHFGcDM5L0xMZlJ6UDFZZHI5cTM3dEo2TzJ6OGNGUFdBNGpQZHVWVGUxRmlEZjc1TVIwN2Q5N0wvYzU1OWE0N1RxRi85TjdpODBqS2RHelh2T1RTZlc4M01xNkpTbzd2cVdxTzd3a3FoTTM3NjFSbXB6N1cydFIzYjFLejhTc1c1Wi83Y3BoYVJzYUVCMXA4NG1ybTI5VlpyWC9oN1pQR29IZkRyVjcyV3BkbzkrbVBmR3FLMjlzeldmWFRiWmNNNUhiVFR1T2J2akplYzI5UkpDejBQejVudEZkYy8zUm1XTEowUmx5aGF0Tll1YnE2NXUzZWx0M1BxZitXUzlHLzQ5YW9zKzFGcW4rY0ZEeDZrQUdNeXIyM1dUbnE1aHdwbGt4NWRIN2RCdmJEamt0YzRRMWFndS9Nc1lPZUwwNk5VNm54MWJlY1U0VGlLZnorbU1PcEpxOWFPb3BZQmNtWE5neExTdFduZDhLcHZ2SGRYZC9pNUdqanUzNHp0QVhlOW00M2paSjgrUVBITGtUMU8vZk1VR1F0Nm9WTlBhNGQrTjZuYlB6Zi9ZWFhGWlp6K1h3bWxlOHpoVzVoMGVJOGVmbjRMelM2TXk4M0h0ZFdmVDhWNlpmMnpVRGt0MVhQU0JmR3FYTG5nYWYvcldJM2Uvc3dFd2lKcjMzOVFLZTMyWHZ1eHJCMzZ1b3dCWDJlckUxaDJxWE91MDV0Yk83aktsbjJua05MNnN1dXNibzdMMWt6ZGV4MWw3UkczZlQrUlR2M3N2aU9iS0paMzk3S3A4SHRkWGQzOTdWTFk0c3BQNEVyWDlQOTBhY3BCcm4reXdUcTFBazhlYnRpazQxdzQ1ZFpPUDdHdDd2ajhxY3grZno4WEhUVjhSOUlBaGtOTVl1Tm91Zjl2NW1LM3NTM2puMStZZml0ZmNOdmJKWStrUDgzbnNXQm1KMm01anIwWlIzZkdVcU16WU1aOFQ2ODFmNjZ6TzkrV3dCRjkxYXRSMkhjZkUxdWxDcGJyTjAzTHVqMHM3cS9zdFg4dGwrNnJiUGI4MTFuSFQvYllhMVQzeWVUdTk5Ulp5ZGdFbjZBR0RMSzkxYlN2amZQVFZ1dE5TcWVWYnJQVXJ4NjduMG56R0hGVzJPaUdGandVZEJjTEs5aS9NcDY5bEx6SjBZdFcxL2EvZmxzZU4rN0YyWmY1eE9mZkhEaTRvVWhoczN2UDdmSUxlRHFkMDluTUxuaEV4TWp1UEh2bUlQaW5vQVlNWjlQSllSelI5cVdlUEVjZDMxcGlhVHNSYkZqdm9OZGZuOWdaemRadVR4dkd6SitmVDE3STNxVHU0Zzl4Y2Uzdi9nOTdjUThmL1M1MEU2NTcyeCtWai9ramp0djlxQlpyK2Q4Z3A2ZUxqU1IzKzdMU29qdU9OOW01cTEwZlFBd1paRHBQU1ZtYnZIUk41dWFLUzg1aW9HSm0xNllDeTdBOGQzZlhyU1UyM09LcnpuNTEzK01aZk51aDEyTXZtYkJ4TC9mNysxMi96dlNjUVpxYm0yeDg3R1ByUVViMTdVYzg1QnozaWpkWXhmMzcrVWZuMHg3dCsvZUQ2dDRJZU1KaHlPS25HeUp3SmZDUFhPeG9qMTFQVmFXT2NWUE9hcHFhU3d2Tys0d3FzbFptNzVIUmlIU3Q0TkNNYWEvdGZ3U2x6eC85TGErOG9kSC9zck42OXVwamJ2NmMvMzczdnYxWFJ2TGM5NjRCNTlJQ0JWSmw3VUZRWHZyTFBmK2NoNHc4SUt5L0xKUUE4WXJ2SGVIVGN5T3Z1eWN5ZEkyb3p4L2M3bSsrZHkvak1NY053dXZEb2QzOXMyV3pYOFgrV3ZLYUIrZk0rbkxiMXByZHY5UTNSdlArV25JTGVQdVA3aGRsNzUxYkg3SzVuWmQ2aGdoNHdtRnFUMkhZNGtXMmVtcmY5TU44TnlCNURiZkxFMmt3bmpIUHkyYllzNkkwNzJPeWN6MzVjZldNS0h6ZHYvTTNmRkZockIzK2wrQWRPc3hITjIzK2M3emFNc2Qvem5BZzladTQwdm1EWW10eDc1TUhIcVAwTmVyK04yTzF0SHQwQzVIbFNiZHo0cFZ3M29UTEdIWjhzd09TeTZrUzJiUk9ZTGlXdktWWmF0UnFBTllDemtQZndxVG55NlpPN0ZMYk9sUmtMeC9rTHRSVDJ0c3UxUHdwNkFEbkpKbnh0NWpEbHhpUE9RMk85bFRtT2xUTzZib3hIZUJ2K25XM3kyOTQ4YTlVbDlhcyttdnMyWkk4Yk54bGdTdGNudDg1bFUxc1hhZlhWZ2g1QVBpbHZiVFF1ZjEvK0o5VXREaC9qcEhwWmZ0czJrUmNKSnZJNzNUcXg1bGlycm5USnBhZEg4NTV6OHQySTJzeW96TjV2akVDOVJKL3NyRWUyUXJHZ0I1Q0Q3TTVKWHBNNlArTEVOY2JjYzgyVmwrZTNjVlBuOWVkRTNMV2dkM2w1TytUNis2Snh5WnR5MzR4cXR0UmRaUk92RDlSWFIzUDFUVGtkTENreWpXeGV1ajRwNkFIMCs4dDMyWG5SdVBJaitZZTh1WWVNT2Vhb3VmcTYvRGF3YkhmMDhxelZaQzg4THZuYjl2clFlZmZKTVZhV2FhNitQbktaS0hreWZTdkhQaG1wVHdwNkFQMzB3RDFSUC8vRnVieUY5MmpaK3JCanluRmdmdGtlM2NiYU95TWE2MHJYSlJzM254cU5tNzZTLzRiVU5vdnFnbWR2K21mdUwxbC96UHZpWTgxU1FRK2dmOSs2NjJQOStTOGN2U3RSZ0pQcXdsZU52Y2w1VHA3YndRb0pqemtaVCtEUldsZDM4UU4zbHF0TExqcy82aGU5cmhEYlVsMzRpaFNLNWhTM3ZoUHNXNVV4VnA3cDdjWEg3WUllUUo5T3FWRy84TFhSdlBNWHhUaXA3dnpxTVUrcTBYaWdkUWN5TjFNbXNOSkkzc3QzclZsYW5oNjU2cHBZZis3VEkrcHI4dCtZU2kycXU3eXgyUFh0WU1XT3J2WGpidTFqZC9RQStxTys1QjNGZUR5V3FXMFd0VDNlTS9aSm9tUjNwOXFmYldhK2YzL2V5NGQxR2dEdXZ5WHE1enkxL2JpNUNCY2VDMThabGMwWGpiM2R1ZDVobmxHKzR5SHRYMEVQb09jaDc1M1J1UHAvRnljTDdmR096dWIyV3JmY3podHZnS3F2S2tmSU8vdjQzT2R3ZkhpQXF1NzFEeDBlVEt0MHN2SHM2L1VyTElFRzBNT3YyYWhmK25mUnVQYVRoZG1pYkMzWTZ1NXY3K3lIczBlM2VhcE9LZDh1WDM5ZnNYdms2dXVqL3RzbkZ5ZmtaVGx2NzM5c0x4VTJBUFhkOEVHWFk5UnFyQlgwQUhwelJxMUgvY0xYRk9keGJldUVVNDNhUVYvc2ZLeFJPa25rbXdBMm0rRHZ6WWlvMzU5YnVDOXNsMXl4dVBXNHRybm1UOFhwa3ZPUDdteHMzb01mSXNmNlRuUllRSjR2WXdoNkFEMndma1dzUCsrRjBiempaNFhhck5xaUQwVmxpeU02LzRYY3d0SWtaUzlrNUxYdEJYM2NuYjBFdFA2ODV4VnIrNmJNaTlvaHA3WW5JdTc0Mk1wdit5dDV2K2d6RWZVMWdoNUFWMCtvcTIrTStyblBqT2FLUzR1VmZSWThLNnA3dm1lY0g2WmhodzZBeGcxZmlQb2xieWpZSEgrVkdIbjgxNk15YzJjN3FNY0VQWUJ1aGJ5Ny9ydDFKeThldUt0UTIxV1p2Vy9VRHZscTYrUTZ2bC8wdmw2NUU5NjZxQzkrYXpTdSszVGhOcTIyejhlaXNzMVQ3U05CRDZBVUVTOGExLzVMT3FuK2ZXdHNYcUZDM295RlVYdkNUeVk0bDFmRnJoMnZpYzYxMXUwZXVlYlcxZ29zemJ0L1U3d1M3ZnJtemw4SWVzd3ZUOVhIQkQyQVBscTNMT29YdkNvYVMwOHYzclpOM1RKcVIvNHNoYjBkSnZiN09VNzAyazRyRXd6TjYxYmt0ODBGbUd1dGVjY1pzZjZQTHl2TUhIbVB5R2s3bmhLMS9UNHhpZnJtTjA5aWM2TDlLcy9sRHRNeExPZ0JUUFNMLzU1em92NkhVNks1K29iQ2JWczJYVVh0cURNNm1vUzJzTmF2bk9pZXliSHdPWjVXVTZDb1gvNkJhRnoxMFNqaTI3L1ZIVjhldFlPL0hKTzZVNXhuZldPQ1kxWnpuaEpHMEFPWXlBbjF5djhWalNzL1VyaEh0UStHdkdQT2lzcG11MDN5RERIYnZoNTN6ZktaU2lOYnpxeDEwYkhzdkVLV3BmcTR2NDdhQVorTlNROEh5SE9xa2hLcXBHTlkwQU1ZenduMXZxdWpmc0Vyb25uUHVjWDhZcCs5ZjlTZThLT0pQNjU5K0o4MWRWNEpkMUMrYndwWHBzN3Y5d2R1djFWNzZWc0x1MnBFZGRFSG9wWmFOOFo4OXIrK0R5OTFzM3pIdzVSNWdoNUFwd0dpY2Qybm9uN1p1d3M3djF4bDY2ZkV5R0hmN3Q2ZHVIU1NhQTErejJ1RmpJbE0yTHgrUmI0N29aT2w1YnJWSmUrL3FUVXBkL09Pbnhmem1LbE9pZHFCL3plcUMvK3lsUFY5Yk45YTNyOSszQzNURndoNkFHT2VVTE83ZUJlK0twcDNuMTNZYmF6dThqZFIyL2NUWFY4MnJKSk9yTm5hcVBtY1dDZHdoeXJudWVJcTB4YjBvMGRHNDRaL2ovcml2NXZFT01aZUI5NnRZdVRRYjBabHl5ZDIrYzlka045bm1tRGZhcTVmbFdOLzNGclFBOWpFTjNRMHJ2bEUxSy80UUd1RytVS3FUVy9mTmRueDVUMjZJN0J0UkU1QnI3bnUzbkUvN010K0o3KzBQYTNuYnlxMzFxcTk4TFd0bFM2S3FqTHYwS2dkOXQyb3pOaXhCOEZsbS93KzJFVDdWcDU5Y3ZwMmdoN0FCaytveXk5T0o5UlhSL1BlUHhiM2hMclpMdTBUNnB3RGUvZDNUTjgrbW5GK2VVNnNPWjVVS3pPMjcyR0gvUFBRZ2Zla2k0N1ZoZTJUMVoxZkY3WDlQOVc3K1FSN1dlTmVYVVNzVzVaZm54VDBBQjZsc1RicVYzNDRHbGQ5TE4vNXI4WTZvV2J6a1Izd3VZaVJ6WHY3RjIyK1YwUmVjd1NXTE9qRjVudjNKbUNzdkt3MVYyTnoyZStMZTl4TW1kdStzN3o5QzNvY3BuZHN2M21ieDVRbFdjRE9IdCtPYzNoRW5uZVpLK240RmZRQS92eUZmTSs1N2JGNEt5OHY3a2FtazF3MlRVWFBIdFUrNWtTUjN6eDh6UW5jQ2NuMXBEcXJ5N1ZLb2FKeDljZGFGeDY1dlJEVHllZWVmMVRVRGprdEtqTjM2bHVkbS9mK0liK0xqMmxibGVqaVk1R2dCNUJOUzVFOUVtdGMrNmtvNGtTekQ1N2d0ancrYWdkL0taMVFIOWZIT3dMNzVQZUJIN2huQWlmaUhCK1R6ZTVlcmJJZ1U3L2cxZEZjY1VseGo1dnExS2p0OVE5UjNlMXQ2Y1BYK3Rnbjk4NHQ2R1VYSDVYeEJyMko5T011WFJSbVN5QUtlc0JRYTk1NVpudHdld0ZYdDNoUWJVYlU5dmw0VkhkNVEvUjcvZG5LckQxSC84NGNBdkNhVzhlL1AvTjZRemphajhrbWY5RnhmK3Zsbit3bG9DSk94djNnWjUxN1NMcm8rRW9LdC91V3M4NFRsZld2V1h1TXIwOU9vQjkzczA2Q0hqQ2MxdDNibXA2aWNlT1hDcjJabFMyUGk5cUJYMGlCYS9mODdnck0zaWVhS3hiM1A0VGZmOU1FVHNRMzUxT242clJVcHdNbTkzbnYrbFY3WHJ4VjF4UzNRNmJQV1Z2MC9xanUvdmJjbGlPcmJIRkVmaGVHcVgrTjYxSXJtLzRtcDBlM2xYbEhDSHJBY0dvc1BUM3FGLy9QaURWTGk3dVJVN2VJMmo3L082bzcvVlgwK3k3ZWhzSm1Ma0h2dnFzbjhEdFg1WFJTUGJ3MTFjMkVyRjhSOVNYdmlNYjFueS8yUmNkV1QycTlBRlFaNXgydG5nU1k3SVdJSE9aTUhHLy9ta2dmN3Q1eGUydzdtL3ZLQjRiRzJ0dWpmdjRMby83N3Z5aDB5TXZlcUoxeXdoVXA1TDBxOTVEWE9tRnNjWFErZi9INmxlTytxOWRjdVNTbmsrb3hFd3NPdC8wbzF2OWkzMktIdktuelc0OXBSNDQ2TS9lUTE1SUNkV1hlWWZuODNlUHNYODJWaS9QN0hwbmY3cFB1NkFGRG9YSHpWNk4rNlZ2eUd4amRTVmpZZk8rbzdmK3ZyVHNuaFFxZVd4NGZlWTBXYXk0N3Z6V2d2S09memU2MnJGdWVUNDNtanpQb1BYQjM2bzl2U3YzeXRBSWZOWlgydkhoN2Z6aUZ2UzJMdFdXcDNzMjdmOXYvNzVGbDUwVnRuUDAzbC9wa1kydEhKNWQyUnc4WWFOa2RvZlcvT3pucWYzeGxjVVBleU9aUjIvZi94TWlUTGk1Y3lHdVp2aUFxcy9mUFovL2QvZXZPZi9hdVgrVlRuOXFNRkR5TzdUd3MzUElmc2U3TVJZVU9lZGs0dUpIalU2ZzU4UE9GQzNtdDhMTDFVL1A1aTljc0hkZmoyT1pkdjg1bi8yMXowa05mTDA0RHdLQnFYUCs1MXRpbndxNEhPbnBDcmUzM0w2MnI3N3plR0cydHp6ckcrTExLdHMvT1phcVA1cTNmaThqcTA4RWo3TVp0Mzg4cGREeWxGZmJHRGdtM1JmMmkvNUcyOHdmRlBXZ3ExYWp1K2Q2b0x2ekxWczF6ZVJ1OU9yVzFvc01tTjNQKzBhMXhySGxjdkRWVFA2dGtVOHFNOVhPcnJzMXRlcHpxZ21jL1ZLdG00blFBREtKMVA1cWIyNk84TWhrNStyOWJjL1J0OHFTMVluR3MvK1YrK1d6ZkUzNFVsVzJldHVudFM0RmsvYzkzYlMwVjFtKzF4NThXMVIxZU9uWVF2ZWtyVWIvZ3IzUzRzYkxtbkFOaTVJa1hqZmx6OVl0ZUY0MGJ2dEQvN1p1MWU0eWNjRVVyRkc5eSt4Yi9mVFN1K2VmK0YzRGExakhscWJjK09MZWhSN2NBakgxeW03MXZibzl2NjR2Zm52NWp6YVppWGpTeThaYzVoTHlvYlJiVmJaK2pnK1NndXNNcHVmeTkyYVBiYk4zaE1YL20ray9uVkpjWFAySUNhMEVQZ001T0lEdS9KcDhUNjhvbHNmNjg1N1plWUhoc0Nydy82cGU4cVRWbFRpNDEyZkdsS2V6TjFEbnl1UGpZOHRqYzNnS3VMM2w3Nnc3dGhpWVNieTYvT09xL08zbU1pNU1lOXNtZEhubWNHcU1IUUdjbmtJV3ZUQ2U0ZDdXV2pPdDcyTHY5SjdIdVp6dEZkZXNUSTZadm56WW1uYjdXM0I2TnUzNFpzZmJPL0dyeXVQK3BZK1FYOVZMOVg5OSttNzdmR3V0YWorRWJWMzJzUFlIemxIbnB1RmpkdXBQWHZPdXN5R3NweGV4dDVNcnMvUVE5QUNaZ1pIWnJ1bzNHdFovTTUrOVBBYk94OVB1RktVZGxxeE9qTXVkQS9TTFBpNCtkWGhQMUt6NlUyK29UemZ1dWJMWEMxR1AzeDc0azR0RXRBSjJmU0haN1Myc1pMQ0pxZTc1SEVYSy8rSmdWMVYzZnBBN1JIa2RiWGZCTVFRK0FTWnhNWnV6b2NXV00zczBiNDAxbCtoUzRkMzFMYS9XT29iOEkyL3Nqc2FGcGlBUTlBTVozWXMzdVpBM3ppYlZTaTlxK0g5Y1JpbUxLbk5RbjN6L2NGeDViUGpHcUM1NjE0UUNvaHdBd0x0bmFwM3QvZEdnL2ZuV1hOMFJsemtINlFlSDJ5WkNPbDZ5TVJPMkFqVS9sSXVnQk1QNFQ2ODZ2YWQxRkdMcHo2c3lkbzdiWFIzU0F3dTJZV3RRTy9uSXI5QXliMnA3dmE2MlRMZWdCME0wemE5UU8rWC90YVNXR0tVeGtuM2xrbHQxZnhOMHo1OEFVd2o4MFhKOTVpeU9pdXVlN04zMVJwbXNBTUtHVHpJd2RZK1NRVTRmbTg5YjIvc2VvekQvV2ppK3c2aDd2aXNvMkp3L0hoODJHVUJ6NnpUSHZZZ3A2QUV3ODdDMTRldFQyK2RqZ0I0Z2RYeGJWM2YvZURpOStqNHlSeDM5ams0OHlCNk5EVG8yUnc3K1hMcllXanYyak9nVUFrenJuN1A2TzFtRDRnWTBPVzUwUXRZTytHQnVhdW9JQ3l0N0NmY0tQbzVLdG9ES1FIYklhdFVPKzJsb0ZvNlBqVTQ4QVlMSnErLzlyVkIvMzF3TVk4cDRVSTBmOG9IVUhoUkx0dDVrN1JlMllzd1l2N0dVaDcrQ3ZSblg3RjNWK0lhWTdBTkNGTTFEVUR2aHNWUGQ4NzhCOG91cDJ6NCtSSi93a3BkaVpkbThaZStSbXUwWHR1SE9qc3ZsZUEzSTFOU05xaDM4dnFqdWVNcjUrckNzQTBMV3d0OWYvYWoxV2l0cjBjb2U4UmUrUDJtSGZjaWV2N0QxeXhnNHhrb1c5QlU4ditlZFlHQ1BIL0dhamt5SUxlZ0QwTHlUdCtQSVlPVGE3azdKUCtUWisrb0lZZWNLUG83Ym9RMkZNM29BWW1SMGpoLzhnYXZ0OHZKVEJ2YnJ0YzJMa2lYK015dHhESnZiN2VnQUEzVmFaYzBDTUhQK0hxR2JMcFpYazVGcGQrTXFZOHFSTGgyZDZqcUhxa05YV1c5TlpuNnhzOFlSeWJQTzByYU4yeUttdHg3VXhkY3VKOTJ0N0g0Q2VxRTJQMmw0ZmpwRVVucXJiUGErNEdXRCtVVEZ5N0cramR2QlhKblZDcFFSNWIvWis3WDJkdmJVNmM2ZkNIamRaS0oxeTRwV3RhWDBtZlFGanR3UFEwNVByckQyaWR0aDNZdVNKRjBaMWg1Y1VacG1xeWxZbnhzaVJaOFRJTVdkSFpZc2o3YWpoNlpIdDRRVW5YaFcxZy82OU9DOXJUSm1iQXQ3Ylk4cVRyMnMvWms3L3V5dWZ0cG5ZNmNBZ1d2K2JZOUovckZTSXNXNGdaQ2U3dVkvdjMxKzQ1clpvM1BUbGFOenk5V2l1V056ZlUveU1IYU9Td21aMXAxZTNBbWcvTlc3N1FUUXVmNzhPTithRndaN3RGUi82cGhuTnUzOFRqUnUrR0kybHA2ZnZqQlY5L0xEVnFHeDVmQXFlcjRqcTlpL295UnZlZ2g0QXVXbmVkMlUwYi85cE5PNzhlVHJabmhPeGJsbVhVK3pNcU13N0xLcGJuUmlWYlo2YUF1M0I0U1VMTnA3RzEwYnpyck9pY2NjWjBienpsK2xDNU5MVVNldGR2dGhZbU1MZHNWSForc2xSM2ZxcHJiRjRQYzJTZ2g0QUJZbDlLZmhkM1Q2NXJsZ1N6VlhYUm5QTkxSRnJibzNtQTh2YUliRHh3S1BPWWlPdFIxeVZxZlBTQ1hPYjFuUWFzZG11VVptMVYxVG03TmQrODdkU1Uxb21wcjRxbXNzdlRuMHk5Y2VWbDBYY2YxTTA3MDk5Y3UyZDBjejY0N3A3TjN4eE1XVmVheTNhbUxGZE85ak4yalAxeFVXcFR4N2Nlck83bndROUFJQUI1V1VNQUFCQkR3QUFRUThBQUVFUEFBQkJEd0FBUVE4QUFFRVBBRURRQXdCQTBBTUFRTkFEQUVEUUF3QkEwQU1BUU5BREFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBRUVQQUFCQkR3QUFRUThBQUVFUEFBQkJEd0FBUVE4QVFOQURBRURRQXdCQTBBTUFRTkFEQUVEUUF3QkEwQU1BRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUFFUFFBQVFROEFBRUVQQUFCQkR3QUFRUThBQUVFUEFBQkJEd0JBMEFNQVFOQURBRURRQXdCQTBBTUFRTkFEQUVEUUF3QVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFBUTlBQUJCRHdBQVFROEFBRUVQQUFCQkR3QUFRUThBQUVFUEFFRFFBd0JBMEFNQVFOQURBRURRQXdCQTBBTUFRTkFEQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBQkQwQUFFRVBBQUJCRHdBQVFROEFBRUVQQUFCQkR3QUFRUThBUU5BREFFRFFBd0JBMEFNQVFOQURBRURRQXdCQTBBTUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQUVQUUFBUVE4QUFFRVBBQUJCRHdBQVFROEFBRUVQQUFCQkR3QkEwQU1BUU5BREFFRFFBd0JBMEFNQVFOQURBRURRQXdBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUFROUFBQkJEd0FBUVE4QUFFRVBBQUJCRHdBQVFROEFBRUVQQUVEUUF3QkEwQU1BUU5BREFFRFFBd0JBMEFNQVFOQURBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFCRDBBQUVFUEFBQkJEd0FBUVE4QUFFRVBBQUJCRHdBQVFROEFRTkFEQUVEUUF3QkEwQU1BUU5BREFFRFFBd0JBMEFNQUVQUUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBQkQwQUFBUTlBQUFFUFFBQUJEMEFBQVE5QUFBRVBRQUFRUThBQUVFUEFBQkJEd0FBUVE4QUFFRVBBSUQvWDRBQkFNOEFxTnNMN3Nwa0FBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvaW1nL21hc2sucG5nXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBcWtBQUFFekNBSUFBQUNkVVEwb0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUJpTUpKUkVGVWVOcnN2V21NSGRkNU5sanJYWHJmbTkzY3hIMlJTRXJVTGt1eFl0bXhQeWQySE1ld0FRL0dSb0RFUURDVG56WUd5SThFd1NENGdzQi84aWRCSmdrd1FHQUhEcHdZZG1JN1hxUllzbVh0a2tXSkZFV0o0aXF5dWZWKzc2MTludmQ5cWs0WGIzZGZVcDN2MStTV3BOYnQ2cnFuVHAxejZqenYrcngybG1WVzkrZ2UzYU43ZEkvdTBUMysyeHgyRi91N1IvZm9IdDJqZTNTUEx2WjNqKzdSUGJwSDkrZ2UzYU9ML2QyamUzU1A3dEU5dWtmMzZHSi85K2dlM2FON2RJL3UwVDI2Mk44OXVrZjM2QjdkbzN0MGp5NzJkNC91MFQyNlIvZm9IdDJqaS8zZG8zdDBqKzdSUGJwSDkraGlmL2ZvSHQyamUzU1A3dEU5dXRqZlBicEg5L2ovOWZIUC8velBTWkxnUTVxbXRyMnlJOWw2OEZlN09IaE5wVkx4ZmIrcUJ6NTdlcGhyY0wzak9MZ3lpaUpjNExvdVR1SVcrSG45K3ZVVEowNk1qNDkvNjF2Zit2YTN2ejA2T3JwNzkrN2YrWjNmK2Z6blB6ODlQYzN2cmo0V0ZoYWVmZlpadE5uZjMrOFZCeTRPd3hCM1FRZlFPTTZnUzdnWHJ1Y2RjUVpmTVgzR1NUd0xiOEhud25sOGtSZnpNbjQyangvSE1VNnlFWjdFWi96TTlNQjloNGFHZUFidDNMaHhnOWVZdTVnYmNXdzV5T2drcnpGL05SY1BEQXhndU5ZY2dWYXJOVHM3aTBiWUJ4NThCSjdCWnpPSk9MTGk0TmM1QWx1M2JqVjN2M1RwRWtZVlEyUzZFZXVCS1Z0YVdycHc0Y0l2Zi9uTDExOS8vZno1OC9pVm80ZjIwYjJSa1pGR296RTRPUGk1ejMzdWExLzcydTBzTURSNzllcFY5T0c1NTU1NzY2MjMwRTVGRDk2WEE4ako0bWlqY2F3UWpFWmZYeDhYR082T3FjZDVOcmk4dkh6eDRzVUZQZEREVTZkT25UMTdkbTV1emd3MTIrU3FNNnMzMFFOL3drOE9DSCtpTlRUKzlhOS8vZkRod3gyZTR1Ly8vdS8vOUUvL0ZKM2g4SEtjT1pqbUF6L2pXV3ExR2dacWNuTHlDMS80d3BlLy9PVTFHL1E2M0d6bXlsVUxxeUt6TXR1U2YvS1ZKUUlEMTFXK3ZLejJGNGEvNDF2eXQ4eGlJeXMvaTcvckI5dXhaZW5JbTRQUmQvR1B3L2ZudGlZMVNaYVdHektndHJtWk9aeml3MHIzYmQ3V1dlbjhUWDFHSXhsZkdLdjB2MHkvclUxbmVmZHRzN0t6TEdvdXQxck5LTTNRQjhkMmdxQlZxZFFtcDZmOVNnWFhSbUZ3OGR4Wk8wdHIxVW9ReG92Tk1Fa1Q3RnNEUGJXZWFzMzNQWG5iOGEvanJIU0ZMMHhKS1BON2VoM1BYM01FMGlpSVdrMTVlRnZ1WHp5dlV6eUtkaEdmWkxVa1puSElDeStYNEkyVlpWb2RHTElkR2ZQRzB0S2w4K2VqREJ1RVo4blMxT214OEZiTDJzSUN4UTN3NGlXNjMyR21GaFlYc052VksvNWdYOTF6ZmJTV1liY2RIdlZxOWR1Y3dUUnNwUUhHSkUzaXVCVTBsNXRCSzRweHoxUzJraXpWMGVidEhjdjJmUXlUN2NwT2lQL2pJWjFVTG5HMjNMSGQwL0ZCLzY5ZG1VRmpPaG9jRlYxM21ZVVY1dHFXckM0OG0rYzc4cVBpdUo0dUZMa2t6ZWRiVmt1bUh6RktIdTVSbnBxMUR1bTh2bnZySGZuYmtxMzhpdjVnc1h1M2F2bS95VUZReEZGKzhia3ptcy9FUDNNTmZoSnZ6SXRDRENQQW01UFk5QjNkVDdqRjQyZFBUdytXOGN6TXpMVnIxL0Fyd1B1Tk45NTQ0WVVYL3U3di9nNUFBampwN2UxZHM1TzRrbzBBRExpVkd4akQzczMrWXhNamR2cXl4anhlYnhCbGpZV2hmUzVMUER6RHovd2lRWkdEVUI0S25PUnozZlEybFRDQUEyVmtCVUpGdVRQRUlUUEN0NFRQeGNYRklBandhSHgyUENtN1o3RE5pREpHQWloUFpYa0VjS1plcjJQYzJucUl6OWhZMFBMbXpac1BIRGd3UHorUE8vSytPSTlyQU9INEZpQVpKekZyeldZVDdkeHlnVUdlUU9Ob2hBMVNWc05KekJFWGpCbEpuaW5MTGp4d1RWa3E0aHladlRUU3cwQTdoNHVmemNJelFoNyt4RG5Gci9nV1Z3dGtuUmRmZlBIUW9VTWRKb0kzNG1BYVNjNzBvWXo5WFBhVWZibDRQakQyLzcvZitHZmRXMjBGRXlmSEV6c3JVTnd1dGtuNWd5STlUam5jYlFVZ2RRUE85UC9jQUFzcFFscHlpZjE2a2V2NWdNWmF0WW9YYjNpd2YySnNiR3hrcUY3SHVVcm5TWjFmV1B6WnM4L1B6UzFXcWlMRWNRMXFSMjJ6bkJVUUJaV3BFV1RhWGFJanI2VmtJSDNYM3kxQ0tKOUR6N3VPdHBJS2pzcXJqSjVqNE1NV2tDNWNYTHp3MWkrT0h6cytNOWZzNyt2dHEzcW4zbm5uanYySC9xOC8rNTlUVzdhaW1hdFhMdi94Vi83M3VoM3N1MlA2MUlYclAzM2ovRUtqdFhkeTdPTjM3N3Y3NE1ISkxkTjlnd08xM241ZkZwYk1HOXFXVjhhUnBjbzlBUUM5NmQ1ZjY1dmNzclpHTW5QeCtoc3ZZQmxWSzMzWWVFUWQwZGMreTNVbVlHcVVSR0VVTk9Nd0NNTlcwQW9helJhQTFsTnBLd2tEeS9NUC90WVhhNE1qYU8zczJ5ZS85bi84MGJuWjJSM2JwbVlYbGkvZGFOU3Evc1NtVWR1dEpWSDZzWTgrc1dWaTlPelpkNi9OenMxY3ZySTBlK1BxekdVbnRjWjZhbzhjMkg1azMvYUppWEVyYU43eDRkOGN1ZXZlUWhDNXhkRTgvWGJ6OHNYR2NtTnhidmIwNlhkKzl0S3JiMTI4bERwZU00eG1teTBWQ3JJV1ZJRldxNjllbXhyQVNOa0RQZlZhclJMWjdtQi9mWEc1c1ducjd2LzUxLytQNmcvV3IxNTkrVy8rNHYrT3d4WW1yYiszeC9aOFRCa0VCdUI2dlc5Z3NGN3A2ZlVuTm04ZG1kelNOelE4T0xWNWFHUlNzTUd2WnBZS0VZNkxBYk5reHQxVTVLV2t4NitNOXZkMmZvVEZabXQycVVuWk51TUxrdHJ5YllxWlJLSjBSUXJJZEdjYzZlOFpIK3J2QWorQjNFQ1gyU3NOemhFYXViVVJTc3ZLUFkreWNtazJSQU5JUm5VbTl1L1pzd2NZY004OTl4dy9maHlJVGhQQ2UrKzk5NGQvK0lldnZQTEtuL3pKbjBCaFdoUDhJUFZDL1FVR0VQL01IZEYvWWdaMWNWd0FyWXRRUVF6RzlYdzA3djRHZWcxU2xwKzZERG5tMGRpNEVaTDRYRzNBWDFibDJUZGpSVEJmTndOWWhtMER3QjJBQjQ4UDBNVlBZQ2N1NWhNbHhWSFZuWWVReHIrVzdUUnJpaGNZSXFyeXBzL21ZVGwwMjdkdmh5YU5yMlBLamgwN2hzSEhWNEQwbURKOFJtZmVmZmRkek9QdFlEOEJ2cVdITVNId3Z1dzJsWDQrbEJtUXNrQkdvYVJOYURPV0dEVEl2eHI1ekN4T2c4ZG0yRGtYYlNzVGovenpuLy84czUvOTdQRHc4THBxVWpGbFppMlpkVjZlU3RNclBtbUhZZW1FL1FLRUF1bjZQemRYbXJHbEs4NWJpaTc1M2laN25LTlNnR3FLbWFxTE5pK3g3Unh2c1NQS0I1ZTZYSmFydW1nTzJJUWpXSmhmU0xJcmVBaG93ZjI5dlZOVEU3dDJiSitlR08vcDZUaTdtWjFRRXVFdm1laU1LbzJrZUFCUjhUUHRERFprSUxjb1gySm9rQVdCRzJWeVpTNlI0Sytxa09FUjBBTmJVRGlEaEdLbm9odkwvNEFLb25aS3cya3NzaUZ1RklZTHk4dExRUkRocjFrU3lJcXluYjdldWwveGpWSEVsUmtRMHdZNlZmVmM3RFM5TlY4dGxXTHRBRDdKemRPWWtKREdvUXhsbEFEN2sweW1RQ2F4ZzE4R0VtVVllcldhNHpzZUlBdUxtRHVtUmVsR0hoNnZwQjFtK3FBNjRtNGxTVVVPZFZ3SFFrRFliTVg2SnVDWTNMWnQ4LzRENTE5NHJsTDFGNXJMQzh0TExxYWkzdE0vT2hrRjF2VFc3ZHUyVFU1dW1icDgrZkpidnpwMnZyRmM2K3UvTWo5L2RXbjVwUlBuMGxiNDBIMzFpZWxKdEszamVEdGFQNEFkYjZQalZ5cTF2dDd4OGZGTkk4TVhaK2NXdzlSelVveFBxdk9KYnJlODJIZGxoZUhaWXB4MW5UUktzSlAxVkN0MzMzZlVpT1E0bzlkNCtpcFkyTlZEaVB4WTVUNTJ3YmlGTVE2eU9BcXlORTVEMmN1ajNwWmZxV1pPSkY4UlE0UGFkTktFVXFxWU91TUlVKzI1bmVRWWlJRDZCbkpkcDdJR0tUSHJ2S29jSUVZRitVUUpXV2JhbUFPNnh3cndjRGNzMi9iTGtvSFpkdkhXR0JBMVdHaFEwK2hrdE14enF5M3YxOEFTZlBIaGh4OSs1cGxuVHAwNnhXMTBZR0FBZTlEZi9NM2Y0SUkvKzdNL005WmRjd0R6UWoyQUg5QTcwU3dRaU40SDlxZk5uQTRVcEF1QWZlQ0QrR0s1Y293UVk0REI5Tis0T2NyN09FK2lRU1AwOEdMemFPWU10VWtEUEFiMXkrMndiMlc3QlRYam0wMk5hMkEvbmgyWDRTZGFKaXBEVmNPclo4WWM1eW4wNERNaG1kTkV3R3V6ZkhBb3FKWHl1d2JiNkFnQUN1N2V2ZnY4K2ZPUTFVWkhSekZaMFBJNTZlZ0RwK3pHalJ1Yk5tMjY1UUxqRktQUGFBR3pUd0dsRE5KR1V1RzRzUVBsY2NNc3Q5a3R5dG8vL3NRQk5EWVA4emhtRFhPK2pHR21qTTM0RmVQMjVwdHZuajE3dGdQMm05dVZCVnpUbWJMRnFHM2VONEw5QWp1aWRxckNybmdxNnpYSGZiVmk2dDBJOGk2dDZTNDFhTUZLVzVFU0dtaWl4b0VjWm5ON1FRN1R0b0t4WEloTFBPQVgyN1dhcmRiSmQwNmZldS9zdHVtcHUrODhzSGw2azd2dS9xdVlyZHVya3lrMjV3TWhLclNkb2tPQ2d4bE5yaW9FWktyR3F4bkR2R1ppRlJZeGgzWjhHakVzK1NvZVF6YnlOTXY5RlJod1lKdVZxQUNXQkkzNXBibUZaaFJEaE1GRXhxbG9lOEQraXU4Wk5QS3hrbEpSZzBWQUZMOUdKQ1BqcWhRdS8zcVlxRGlKY0tlZzBWaGFuRzh0TFlYTERieG9TUlpWS3ZYcXdNRG8zYTMxZEU4TU05NEVZSnVZWE1RSGlmWkV1cmQxK0ZYZ3lSTFh4NTB0ZVVMODJmRXFIdDQ4SzJ5S3pSeHJ0cFhrUUdkWkkyUGpSKzY1KzdVM2puazkvYnQyN1JpYmFQVDFEdFQ3KzZQRTZ1bnJIUmthaXFKZ2FYWnU2Y3JWNVBxMSt1TENVTVhidDJ1bjNWT0ZmRERVVXczRE9GeHVOV2ZuTUVoMEl0eENIbTgxc3pqUlB2dlZhay8vOFBDV3lkRlQ3ODgwa3FibkpGVzNFc3F3V0FuM1ZwcnhIVm1QbmdnM2FTT0loZ2Q3NzdybjZNcHE5cjMrL3A2ZzBZelNHT0pUUDRRaHk0TmM1bUk4WWhIK2t6Z0xBZ0I2aURjamFEWENWc01WMUxkY1g5ZUFIY3V2TXNIWUhMME11MVprWVNZRzZyWE9KdjAwc3h6ajNiVFRQSXhHWENhV3loUHlrdWhmYzd0QUl0NlJMdWpmaFAzYzlNM1dWbllrbDlWWmN3RTk3bWJqTmlxUlFianlMbG5lclBFVklCT1FZOGVPSGRod3FiYWFHSUp2ZnZPYlc3WnMrZXBYdjlxbWNnSHk4YUxoaTBUNi92NSt0RUR4d2dBQWRVZml2ZEhuakxmZTdOMXRqb3l5Ym1xRW5uTHNnZ0hSMVNwK200aFFIcTZ5c21oUXJTeGhHT0dqakVucnpSR2UvY3FWSzlDMmwvU0EzSFA5K25YMGFuSnlFaUk3TUJVdFlFeXduWENJMEJSZ0RHZW8zeHVieDhxcnFqNXBCa3dZREM2cjQ0eG13RnhBUHNOTTRWZDBBTE53OWVwVjNBNDNRb1BveWUwc01EN1h3c0lDdWswM3Yxa3pyc3VOK0NiSFVIa2NlRm5sWmd1MEFWb3pwN3dHdlRKaEhIeUtzbSsrUEFzVWVzeDg0ZTRZVDhnM2h3OGZYcy9KYUN4RzVZZHFXK2VySXp3NnpLbG4zV0pYc3hSUGM2eFhrN1NWRy9MVlFFMi9zVW9BWWhFdmJsL0VDYVJRcjlQTUtwelAwc2ZFenBFR3NHVXBScnRpVDFlSndGSExLeHJBcXdNNHdGL1BuRHQvZWVicTBjTjNIcmxyUHdYVk5YeXBBcmhaV3VpYTdKMmVGMTl4S2hDWTVaNXdkaG1keWhSRGRGZG1FN242ejdlSnU3ZnMzTFphZjBYcnB3VkR0dXdNS242c01rQWN6TS9PemMzT0x6YXE2ditPQmJERnZKRWx1YVVMb3dNbG02T00yWVp3WUNkNHp3V0pFcDBlNk4zWUFSWnZ6TTVjdURSM1l6WklvamdVWlRPQlRteWxVUWdRY3JjKzhySGg3ZXRpZnpOTUhTK29KMnJ1RUR1Qko5WUNDRUo0akxqQUk5dWhwQ09MM1BIY1N0VU9SVFJOR3ZiTTRrSXJqUHVLQmc4ZnZxdGE4YzY4ZitXT2JaczM5L2RudHJmUWlCcEw4OVBiZHR4NDUyUmo3c3ExOHhlWHJzMHNMaTV1SFI4WkdCaWNucGdhbnhqcUhSa2NtaGdURTg3eVVyemN4S0piTDBEaHBzbHJBdnVqWW5GQlRhOU9RUFVmNnIyeTBCQkJDYzhSV3BFYVdEUUNRQ0FUdTVTdGtsN2R0YkVGVEcyWjJudndjTW14aDRITGVucHFyU0NFaHBJbElmYVhwQUZsUHc2ZEZGZ1JlK0w2d0JqajVrR3oyVmljOHl0MXZyNlFQMUxDdHI2dFltMVJRMUNqRmR3QysrWGRUdmdDNENORFN6TEtreUk3Y28ybHV2cTR0R1FaSkZuYVJYMERBMmJUTHlOQjJ4NVhkazVUWnlvck9tVzkzelRGelRkV0QxZlpOb0F6MjdadCs0M2YrQTFvV3BjdVhhSUdUME0wNE8zYjMvNzJ4ei8rOFhMZ0ZTVURBQld3SEpDR3k2RHkrbm9RNTR3eXgrZzhFL1JuUHBpT0dZMnpMQlBRK0YrK3hxQ0M4ZEFiekNCT200RmEwK1pQUkMvTEZtVW5oUW1zTTBvNVFTSmRQMndGVFFWQmdNSEJTemM3T3d2dGVmUG16WHhTakI1Ym01K2ZwME82cjYrUDJqbE80a3BJQTIxaUNnK2NCeDdUUUdKY0VzYWdqUUhIT0VPMnVIang0cmx6NXlZbUp2YnYzNDgvdmZUU1MvZ0s1SUEySDN3bjg2S0tiamR1M09Ca2NhZ3BuL0dtWENkdEJuTWpIOUNlc2VhWWNCMXlkdWpqTDh1bTViZ0JUcC94YXJXQk54ckJpbnI2NmFlLzlLVXZyYlk1bGVmWGhDYVVSZVEycjByWjI3VlI3QmZJbEdmSnhEMVB3M01lOFpack1Tc2hlN1FMWklxYnVUbUFoZ0RzcCtvNUViV3pDR1BMOTBhMWZPSWVpVzZPbVhvTUJHZjVjaENBNi9VYU5Mam5YbjR0aU1JSDc3M2JhM2RnaUFRU3A1bXZtTXpvUXZuUHlkUTk0Zktsa3gwNUYxRnNOUUZvTEptOUV0V2xRWHhxclhYdElqUXJ6Umd0bUthdVJmTUdMdlpVT1V6U1NBUWZhUDFMODlmbUY1cU5JQkNvRTFUS2VtcGViMC9GTW5LM3hJSmxqbXRIVU83eHNxbjlBSXNrQ2dEd1lhdTVsTVN0QzFldm5Uenhkak5JaDBmSHByYnM2TzFGRzVVNENmR1dMeStJWGNIek84VTl4TFlqUGdmQnhnUmJsTGhoRlB5eHhrUnVpMk1ISFVoRU1hVU1aNHNWd25LcmRUY0tvT21JL2J5MGdQYnQyWFAvemgyL092NVd2TERzVjZwOU5jZVBneDAxZTJUaHl1bW56Mks0cS9XK3ZkTmI3SHAxY21La3IxS0JJRFE0T2p3d01WYnBxN3RlSmVucHgwMlNNUENxdFZ0amY5RE0wbGhFU3pIdVo1N3ZEd3dQVFkrUG5McDhyZEZrT0lqTWhpdkJGN2JPbUt4RHo1WjlyVjZwTEM4dWoyM2Ewajg0VkRLL3AzT0xqYkhCM29IZW5xVXNhYlphbnUvVnF0NXlxMlU3VU1GYzRFQVVTQVFNaEZMWDhRWCtsK2Q3ZW9kRVF0VTNHVk9MNFJOa3RqRlpzbGFhRUJhaTJCaHkxaEsvc2xURWZDZWp4UisvcTQ5SSs1dlpYT1FheFVIZmtnb3g4bFoyVWQ5c1ZRWWcrV0cxM2R2c2ZRUkZjNW5aQWR2MlUyTVZKNXpnQTcyNUpnNEx4NkZEaHo3ODRROS83M3ZmQTZwUitNQlBZTldaTTJlKys5M3ZIamh3d0NnYnhpOEFSUmFJaFd2S3dGL1d0dHNrRXFKakdhck5veG5OMjhnb1pZZHUyYkNNTm8xZWJocGZyZEtWaFNReklBWkt5NGIzc2liS29iaGxYQmpCa3RyMjFxMWJHU2tKalo4dDB3WUEwTUpuYUFXUUJpQmFVVkRBaU9INk5YR2FGZ0tJQ09YRUJ3T05HTGRlUFhBWGlHaFE4U0VOUVBEYXNtVUxQbE1XQWFMZkR2Q2pUWFFKM3pJWWI5enpCdURwZ3pCaVZsbFk0Vnl2YWFreVBvSnlZRXA1R1JoNXRHeFJNS1lkeHYxeEZyQ28zbjMzM2VQSGp6Lzg4TU8zdEdHWXBzcVM3bXJSYmJXQWVMdllML3V4elNoM3h5bzdjSW1QTk9Ncm5CVCs4VXd2RmZ0QVlid0gvaFRJbVZ2aTFTaEs2U0Ezbzh0bVdaamlWVXpJa3dQMGxNU2NBNTNzMTQ0ZDc2M1g3ejUwY05WWU1ISTZ6Vy9EUjg1b0hhYWhYblV3dGJoa0RORzNLR0tyL1RoVHo0Ymd1cGc0SEEyMGsxQTd1c1p0am9JRzhWT2RrNVVrN25LMDBtb3N6YzNPemk4M1lvMFZWU05EV3ZQOW5xcG52TGtDVjVBb3RDL0FyS3J2TGtEWFRWUG9ubk5MQzY3dk5oYVdYai94ZGlPeXhqZHZhVlNxRjY3UEJ1OWZxcnBPeFhPRE9PMnIxUWI2QjB6MHdCcXlwNDEzMGxWalJLcUJES0x4NTNQRElFMFJBVVQ1VkkwL2dhQmxCeTBIemZmV3N5VDJLcjE3NzVvY0hGZ0pPaHVabVB6VVJ6NThoNXMySFgrb2Y2Qy9yeGRQUE5ZLzBCU0haOXdLbzZGaGFQZ2p2anduVU5WTm85aUdST1pKZUtINDUydFY2VUFVM3BZdExtaHBOSCtXbS9rc3U5cmJOekV4T1RsNGFiNDFGOXVKR0N0azVoZzlJcE1nUXJiTkVHVXJUYXpkKzIvS2lxblhLbllTWGJzeE56VTVqcjBtQ29KbUVQYjA5THFXbCtvQ1NUTm9BRUR6Umh4R2xXb2R3OU5ZWHZEOW1sdXB4bllFMVIrVHEwR0tFcjlodXlMcVJVbTIxR3lPK1AzcnY0MEU4cFRTcDRnQ1dDOXBydmpiYWxGU0lacXVBSG1qc3E2L2Y1WCtWTjdPeXE3TmNweFVXZWt2NjJkbGEzWTVlSjVYbWlBdjB3aldHbDNqUjQ4ZUJXNzk1Q2MvZ1FKS255NGQyODg5OXh4MHpWMjdkcFVERW8wbDMyQVZzSTN4NTJZclo2OG9YbERwTi9IWTVob0QrY2IzYjU3UldQN045V1dsMzN3MjMxMnQxYlZaRjlnQm9ydXg3Zk83TkNFd2RJNDk3NEQ5UUhTSVJIaGV2RllBZFh3RmtoRFJseGtRT0FQMEdoa1p3WG42UGlBbzBJei8zbnZ2YmRxMENYOXRBeWRxOWtiaW9SaGhBano1cEVORFE4QjdTQTl2dmZVV0JBNklGL2lWcVp2QThuZmVlZWZCQngrOFphQ2ZSSVhQejlPL3dDNlpLRkhhL0RsUUhDc3pxZ2E1VjBzdGJVNEJ0bXl5Qm5pR01vRjVITjZhc2YyOHRibVhtUlQ4NmNrbm4zem9vWWZXQSt4eVJFdlp6bS9FNG5KS1lWbUMvT0N4ZnBsRlV5WkFNMldXbTZOb0tCWndOYzNiUmVoL0R0UkZsR1BoL3NvTjhxbnEzSG1pbmVhWENlYXFoMTMzeFNKeFRyRTJ6ZlB2S0Y3UUxxK2pscjM4K2h1YnB6ZU5qNDdjUEFuMHZ2dXFWcVVaNVFaVkVrVnp0eGt0Uml1RGlCaVVRdFNLNFRBWU1jdTlHWGFSdnFBOTBQQUIzY3hWVjZkZ2ttbjB0LzV1SjNIUW1KK2ZYVm9PeENkZEFjS25jWkRFTHJBK3Zja1VrOHRKK0hPU3VacU1HQ2ZwUWhpZXZiWndibWJ1MnBYcllaS0ZidldWVjk5b05Gb1pYUWFPMWQ5VGwrQlN5OW16ZWZMQWJ6V20xdDgzZlludFR4bWdrWWNxT0xrZmhMQXF2d3Q4aW5XcVlubDJJWjVtYnRYeEU3L1c3M29yeXdCdjdjR2o5Nlh2djc4Y3hlTlRFeDY2QWMyNVZsZXRObDFhbXZPcUZjanltQkt2VXNWYms4VVMyV2Q3QXM5NGg1eHFSWnpyU1p4YmdqcUw1Skc4SVNKSzRjMzNYUHkvMXRNTFBYNXNlUGpzMVRuc1E3N3R0cXc0WXlpcE9Gb1MyL1ZUT3hmTmFqM1ZnNGVQM2hReEx2ZXYzSmlkeDZ4VXEzYWw0bU03d2Z0WHEvbU5NSUxzZ2xXRVBUQU1tb0QwSklyZGlwaUJtczJsdW0zbnppS05ub1Q0a29pOUo4YjRwb0w5d1hCLy83cFBrMHFhSDYxZVdacFJpazN6c0JOZDRESVJlWklvbzE3U1R1YlYvNDQyL3pZOXhpalRCdGZMdG9FMnAwQVpXYTJia3dONUhnQURuR0NvSFZzMnR0a2RPM1o4NUNNZkFUaTk4c29yN0FOVjI0c1hMd0xxeXRoZlRwMHlkbkorNWhadkNBYXNJalhmR1BhTk85bm9ZZXloeWZzeVFFNmh4T2p1WlVOOVdWOXNDeDFvNjZRSlh6ZDVnTlRwVFpxaVFSb0pzZFlZUm93UEVIMzc5dTNyelJGdzk5U3BVd1IxNk91am82TVlWY2I4VDB4TTRDNFFEbWk0cGc1TnQ0akJJUWdObHk5ZnhuaTJPYzRCcTVBZTJyVGhNdHNCSkFuZy9kVFUxTldyVnpGYzZPZlkyQmc2UERzN2F3SXdLN2RLQjhObG1GQmVhWHo4dEFHWTJURStHbHhXamdHa2ZXSzFnR1ZXWmpuZHpraCtaUWVObVgxcStlVzRoN1lrUUl6Rzg4OC9EekVGRXM5NndNOTFhNElIVjN0OERPVHpHVGVxOXl1Y1ppb0VXUGtIZGJjU3pSeHE3Q3BiS2ZZb291ZG1mVVVDaVMyTFJSbldJSE0yYUJXaEFIa1lkR0ZPeVBMQU8rTVJZRFErTSsvdzFxajhIcnoyK29tUC9mcUgydU9zMWFPYXAvQnJkQUhUQ21qV1YvaFc0TTgwQWdBL25OU2hGaWkrRE8yRVU4UWUwbWVoWVhIRmNLdmxRRHVYY25jWHBUKzFveWhZdkRHM3VOUm94UlhvNzQ0ZGk2VTQ5UVJkSXVQY0tGTHJFNmRJa3NDcUNPTmtickc1RUYrOWNtTnhjV2tKbTk4TTNwek02Zldya1E5MVAxNWNXaDZPMDZHQndWWVFiQjBZOVh2NjFwMC8xNjU1ZGdLVWROd3lMd0FXSm1RTmlTeklGeVF1Q0ozTTgyM1BybVJ4WnFkSjVMaGU0bFhqMktTZzVVZlB4T1RRMUhodGNhbHZlTERTMStkV2E2N2FGZEJ5NzlCVUNuWFk5ZEd3N2FrSHhxZGxKUlBsWC83elpWeUR3SkE1ckh0RVVTYm1BYlVUYWJBY3hoeDdSbTlQdmE5ZTlYMG5hV0V3TlVGVUIwNUNMTGhtc0FaOUIyLzl6dTA3N3RpOTY2YUlwSWpzSlc2anVZei9TME40OGF5czZybVJxR0lwMCszaUZvUzBBSnEvSFZkN3FqVThWeEEwSlpoZmdrT3dWbHpKUUZWWlRWRTZXMjRHelREc3FWYldnWDZNamRyOHhYaVVwVncyZGhGeG1uTGxPM21rcStaeEppcVpkVkcvYktNdTU3VzMyVFBMRzZWeHdaWU4vbFlwVFh3MUhCTDFnVEdNMzI3VDdRQmRPM2Z1ZlBYVlY4dllER2c1ZS9ac2VhODNtaWd1UTFNQVRxcjFSbTJsUG1mUzJ3aXVSZ0lvYjl4dHlqZDdicnpkMVA1WEQ0aVJXdHFHcFJ5T1J3WFVLcGhxakVlZm55a0VHTEdEV2VuTVhGaFlXQUJBZHREN2VkeTRjUVBTRWpSdld2aUI3Z3paUS92UTdKazNieFZwYjd3MW11V0k0ZnJWQVZ1QVZVQ2Q4VW9ZQ1k5OXh2VjBHZUNDbVptWlM1Y3VNZDRROTVxY25FU2YwU3p6OVR0N2xHandaemhlbVllQWsyV0czZlNoTGFSMGRmdGxBWlFReXdoUUl3ZVk2QTJ1Q2pQalhJMmNsN2EwRkVvZTU4K2ZmKzY1NXo3eGlVK3MrU0RHdVdDVnVCektJcTl4TjdSbGRueHc3T2NPUmhrZ3RYTnRKbVBJSGdPVmJWRWlhVXJQSTV6VXpHOHpWczdKUTU2QnR1SUNwUWtlZTNISzdJSGNaNkJOVWtkTUM1NGdKdUs3Z21mMEFMbllWRDNIdmZEK3hSdHpjeU9GV0VRbnZ5Qi9vZkNyNmNDMmlzajFUTUszK0Zsc3gyb0kwTVFyamJDeFJRcXc4NmRRQWNMSjNmOGtBTklJeHJ4L3VYZEI0N3FBcVpDaWcvblphemZ3em9SeHRiZGk1Y3FkN1lxQWxKWFJGR2VFK0NGVitnQnAxbW5Hb1ozRVEyNTJQWTF2TExldUxDLzJlSlhwZ2FISTkvcjZlckxGQlVqdmtBRW5wamN0TERjT0hqa3lOakd4N3NyR2E2T0NpNHM3VTNDbXVNcEFBdzAzczBVZjl0U2dMVzQ5Y1JOZ21ZcnJKWE1ySGpSbCsrYkkwdXJRY1ArbXFTdzZDMDNjU1RNM2pqTEpVS0FiekZGWktNVytKNTRlemV4d1hDNDQ1VkRBOU9LK1llUFdmcmhRUXZCMFhpUnJVbXczU1d4bnNWL3orL3BxdmI0L216VWtBVVJzKzVtYldacmg1RUNlY2NYRllRZXQxc0VqOTFSdU5zY3BVbWYxV2lWS2s2VUdSQWUvWjdoSFFrbmp0Tzc3aTVCSUVySExRZThQZ2lXL3B6ZVZhY2w4eDhkOFpxMkdVKzFKbGVLQkMxM01XMHJyRUNUSndsSmpYZXlYd0wzRUxrbGVJZ0V3dGxKcy9ySXNOSlRGTENJUlFycDhtbXNHTUpjam9jcjViR1UrTzRQQnVJQStlR1BkWlFKNklOd1lxVkcxYWJZRkFFQTM3ZXZyTTRvUjkwcTBjUGZkZC8vd2h6OGtOUElyd1A1MzMzMlhkdXh5bUJWUm42eHdaSHd6ZnZTeVdkNElLK1VjdHJhVWZhTi9teStXY3huSzZNSS9tZnk5c254UVhvUUVjajQ0Um9DWWh4N2lzK0dFd2JlZ2dsTkh4M2xjUUhnR05PS1I3N3Z2dnZYbWlFaTVlL2Z1NmVucGtaRVJ0QWJWSDQzSHVsT2hFZnprT0lpdlRTVU1rMEhBbER6cTNHM05NZytpYlBNdmgyNXdZVURDd0N5TWo0OUQ5VWNuOFJQQUQ2RUJNZ0ZFQVR5TFdRQnJoMFBGTWFRRXlreHR3ZlljVDNJeWx2dFdUazFrRDljTEkyQW5DY2x0SVhnbVlySE11OGNCTVZOdmhMOXlLTUJUVHoyMUh2YTNLZmRsVWRJcWtVRVpHYmV6ZGJGampwOHFLWVhkWFJHWTZKZWp2d2JxTWF4UFg5TEV6dDBBZHU1eVQxSzYvRFhsdjBqcHh6WXB5RStqTzJNQzdOeEs2bXFxSFRrRDZFVlFlVkN4VkNBdVRWcEJkUGI4eFpHU1NVVHpCQjBhNVRPR3MrVktsOG90VHBINFR6b0N0Zms3S1MydnRtWGVOVnV4TTh1dEQzYk9DYWpkRlZES2xMeEEzZWFhelEwd2FUUm1aNjdPTkpwaElvNTJnY1VvU1JrWWtOSXRrRXNuYVpUR2pzU1l4YjZuY3FKdFErV2NXV29tcmhkS3RsbUVmb3hoL2ZiV0w3ZGFkZCtibXA0ZUdCaWNtdG8wT0RKcSswdlQwOXVjOWZQTFJmOTJmQS9hdkhJaWFvS2Y4TmVKMzFxcEQ0ZzJ1dUx4dDBUK0FwRUhvMHEreWFyajFkb2h6YXZqVmR2Y3ZERnJlNVZNU2V0V1ZOWlUxSDVCZVU5alBKU1pTUVFJeHpWREtTa0dVWWhsYm50T1I0Ti9vREdZSXFOQXNzQUlaV0dZcFMwME9OQTNVUGZrL1lPRUF0MUtVeDd5NFJRR3ZZcElWL2pldnJ2YnR5cjFhZ29UQUw3UmJNVXR0N1hnMjJPREE2NkdYVlI5dHhta29veEZRZGhjVHZ1aUxFcGlLSENWQkRkTkFraEZVZXBYTUdxNmRweFVWclFZZXpDaDg0M0d4UENneWdWcjJ1S3NYQmd1UWt4RW9zbHordWpjZC9MWHRuakQweTcybDdaYW84cVVDVzdMQ28yaHRXbXpBWXlOamJWbGVBTjRzTmNERlVnWmEvUXE2SjIwd1pZSkJFbnRkK0RBZ1ljZmZ2aVh2L3lsTWFJQ0lFK2ZQZzBWazlndjhtSVlVcmNqQ25KUE40cTE4ZXRiQlY5ZTJkdHFqTzFsajZ6cGd3SDF0ckRCc2tQWFNBYmxDTEsyM0gzYzVmcjE2N2lTTVhmNGxXdzhRRWVjdjN6NU1ob0hiT01ua0I3N0RiNE9ITVZsUTBORHpKM3JFRG8zTVRIeHlDT1BRSEtpNnN4Qk1ERVFkTnN6SnM1b242UzZ3MmVBTjI2eEpvZ0tLVm0xaXRFMnB2SnlOZ2NuSFhmczAyTjRlUGk5OTk3RHpHTFNhZmpCMUpNY3NLTjVNU0lib0hHRkdEdDhlU0xNMUZnMzB5dWg4NnU3WGVZRG9NaEk4NGExaXZMUEpCR1lFQTFEOU10MVlreEgvQk1HOE5WWFg3MTA2ZExVMUZRSG5keXNFNU1uVWc1RFdjODE5b0gwZmtaYUNSb1dFVXAyN2k4dkl2TVYyaG5rcDViWkl1UXVpWk5XczJWVEdSUjFYSmxuSE5yaTNUVDN0QmMyZnBxTjFUZXYvbTdtMjJzdVBRTzh5UllnRHZma3l0VWJiWkZXZVVaVnFydHVvcDRKeTdGWFFnSFZ3T0FxMTQvYS9ITVdBTjZiZ2tiRytHdmJUbk8zZ0ozVEE5RmVJTG41NmdxT1JhblZ4MjRzM0ZpNHZ0Q0toQWNHT2pVRTNTeU9hcTVYOFNIeXhDV1NWL0VGMUFHSFNWWUR5RWppdXhYRjFsS3JoVTh6Qzh1dEtLNEFyZkhtUUkwUUxjRWJIWjhjbXhDZGRXNXVZYmhhYjU0OU0zZjFRRG1hL1NhMHcxQm5iclhpaThvdG9hb3V5V2x0aSt4K0NUcXNNZXh1NmdybEgyWkJvdEt0Z3BsUnZOclphcnRRejlqNHd2a2VpZXB3M0VTRU1pNHl5UitVbno3ZFNOcUU1aExpa1IyK0VhNXNaRmlNMkZQdGptbCtXUmlJaENnUmlCSWVKOEVDMkVCRHk1TjRRUW1tdHIxNUs0eTlGY0ZOVEF6b3ZTOTJsR2g4Y21Mbi9qdmIyeFMySlhHQTFPcTFaaEJEM3dtYVRzTnZEQTBOTEMwRmRkOXRoYTFZV0pxd1ByRTdOakxmejlKZWVSVTFFZ1NYaTZISjljVk9KVkVGRXY0dnpoUWhjbWt1TlJvRGZXdndMQ2pYVTBGMnFmNzloRllreTRUNUYwbXVZcGh3TXhGaVZZTHNIcVh3TkpNdVpaejM1U1NyOVh6OHF6VWI3SjVRU1lGdFVOem41dWJLK2R5RzZnZHdlT1BHRFVBZFVBZTQyS01IWVpnZWR5eXdpeGN2R2l5azFkcjQ0d0UvdkRzajFjbjNUZ1k2MmdOb1VTOEgyQnZ3TmlGZ0pxK3ZiQlBtQ0JDeHl2bjZKaDNBa1B6VDZWQWVEU2p4ZUJ6ZzNQbno1N2R0MjBZWjZNS0ZDemgvNHNRSm5FZHJKdU1PWUx4NTgyYU1BMkNHbW5HYjdydDZWTW1Ldy9nSkJoYVlhSGFhR1F4WmtBRXpTOU1tVGFMRW12Wm5ORXQ2Z0RaU1BLUENZa2d4bXd3VnBGSG56Smt6VVAwcGg2MlhFVmQyOXVNeEllS3dKMlRvTS9LbGlkODAvaFI2YWt6NFJRZmV3TGJxRW1aMnlndlloTitYeVp2YjRML002WVFudW5idDJpOSs4WXZQZmU1emF3b2N4dXBnaE9ZMU0yS01aTGxCN0U5emRDK3M4eGtqbUN5K2lJbEZwNzJUQjlxVHA4Y2k5YTAxUERRd1BEeVVpbkZUb2dFYVRURXJRUm9RMGRuUGdUbk53KzRLN2hOTHZRRWtvU244OTFtYzVyUTlNVlVEYTJsNU9Zb2ozK0JLcm91ek9JQW1FUlRNKzNiQjMyOFZNZnNtOFFHUTc2cVVsdkdYbkdCQTJPM1Y0aXU0ejc0cHU0R1RiK3BLMkNMY0wybXl0SEM5MFdnbE1mUkphVk9NeGxsYzY2MjVXZGhvTlpNaXY5OHErQTdVTEl4T0pJNHFyMUdZSmw2c1Zua2huY1hxYjh6UEQ3anU3STFyVjN5M3YxN3owN2pYc1NmY3JISCtuU3lJT2s2VFpGTEs2czFFZHFHUlFEbjg5U1FERGdTZ01vM0dreWRTdmdJc0VEdExJcWN3UjkvMFFvNk85Z3dPUmN1TEtrK0lPVUhrSTlmTGF3YUlkVUVGSmxmWWhOVFhJTktSU3pwbFdlYUpGUVdXMVpFTnQ5bTBOVUVDalZoeG9LRWZtbzBwdEVCMlQwKzE1Z216cjZSVXFHWElNWDZjVEhJSWQrL2VQekkydnRwempCWVdGNlBKM3I3K3ZtcllDRUxzRjlEeWc2Q25WbWtHUVg5VitJS3cvNHR6RTBnZk4vMDRGQW5FRWVGU2hDSTdFa3FHVElNTHNlWVNsYVl3N1VFNHQ3aThKdmFubGw3SGhGR3hGV1JGWEFzTlZsa2VFcHVud2lTdXBia0tYYjEvbGMyL2JmY3ZrL2FzSnAzdFRFR1A3WmpZWm13SitEdzdPMHNsK0QwOUFJcU1WTis2ZFN1enpCa01TSTQyWEd5d0g3Q3haODhlWnE3alY3UkE1Q2IyMHd4QUZaYlJaMVM3alVIWTlJRlNCYjNJaEM3NmtvbjZ4RTZtZXhsQm9SeTNhTHdEM1BITFpITTRBOVdXdWp1ZUVSMkRpdi8rKysvak04N2dyL1B6OHlUalE4dG9IK3JzNmRPbkljVFFyWTVmdDJ6WnNsNHRBMHVKY1NCQW9HOVF2dW55R0JnWXdQV2NCWkliRXMvNGpIeHdzdmNZR1dqTmx0RVpWc0ZwbzBrdTgrRUErL0VaOHdXcERpT014OFN0TVd0NHhqSTE4cHFXZVdZaWxITkphT3FBMElBUkk4RUFmVGRFMHpMdk1ybUsxL2FHbDFhcHNiRWJtZ1FqdzVsbmIzc3VHa2lNWkZDMmRxRERQL3ZaejFaamZ6bGt4THFaMzZrdHNML05CckFodlQvTktVaXpvcmFOV3IrZFF1bG5mQndUMzh2QmRuTEZubDA3SDdqdmFNRUFJQU1DcER4Mzd1S3J4NDdQTHk1Z1pHd1RtOE9hSzVwaFQ4M2JFcU84N3IyMkUrZGg4bm1rQVc0aWN4bUVCdnNaakdmblNYNXFaQmYvTnZXd25GQXdSd3hTRkdyb1FjRlBRS2pTNzlMUXI1OEFkUnFKVFJNRUsvZWtUQjNRWUlFTWVMSzhNTDhvdnI5RWdGRjgzOUJSczU2S0J3VWhDS01WVnlXSlp0VllEbG5aaHpvdjczUFdpS09zSlhlYzdPMkYxQ2l5Y3hKTkRmUU9RSm5Ja3AzRGc4UDlQYjViN2F1NFd5WW02clZxaDMzVDk2b2FxS28rZWR0WGhpUUFrTWhRdUhVS1JUOUtXU25BeXNQdk5kZGZ1V3A5S1BLcFhiQXRsYmJPL29IZTBaSGxxQ0ZFUWRxMFpqbmFPYlpMV3FUYVdzUUtraWs5WWI0M3k4dVFxZzhHYW4wbmdRV1kzQVFRV21vVllqS2xoQi9LNk9NTnRJUVZHWUtGc0R5SnN5ZVBteWZ2amdaMTdMM25QbnVWU0l1djF6Mi91Ynk4dU5RYTZLdG1YdHhzeGIyOTlVYXJNVEpZNjNHcVFRVHRScWlWZ21BNUNPcVZlajJKV2trU2FDU0RCb09xZ3phRjlKSDVkcEZITFl3RlNUYS8xQWl4VGF6ZUMvSkFmZ1YzalE3TVRXT01qTWlwbzNLTG1UeEpUQTZtTHVqZkpMU3RSdlN5M3I4bWsxM1pmYjc2WUpVL3V2bWhDci8xMWx1MEJGelh3ekRLVFU5UEE4K0FRRGpKeFBIVlVnV1E1ckhISGpPOUtoZlhNYUhhL0JWbyt2TExMek1aSFhjbkZTQUJualRBeHV4TTJuLytpVUlBK3NBZ2VTQVRwWkRiTkprUWNhRXZZaitDRm9Hdm93TzRMeDRXejA0ZlAzQ09LRGlvQjBTQm1aa1pmSEZzYkl3S1BWbnpPbWpQRUliUVByNUZZUUx0WTl6R3g4Y3hnQ1R6S2JQaEdqV1hMbk9EaFd0bWVSaXpmOW1mYlVRZnJnRmpld2ZlNDdrdVg3NjhiOSsrN2R1M1UxL3ZqUDJVUmZBQlg0VGNnREdabkp5ODc3Nzd0bTNiZHVIQ0Jhd05QSXNKR2pCVFNTR3NBeVYrbVZheUhGNUh3MDlaNGpGQzIrcHdWRk5rMGpnZDhPSDQ4ZU5ZcStVMGs3SWZwSTJub1N3aXJ5bW1iQVQ3SFZMQ0ZsVnRtT0tmMmliNzNzcFpjUXUrZnBySE5UTk9IVGszaDBmV2EvWGhvYUVkZDJ6Ny9vK2Z1bnoxaXA4cjA3YkxZTHljeXFVSXJiZVZwVi9DcDNPK05ISUtZL09NTkhuV2FOVml3WWJTbmJMZWdNdnJHYU1sOUR4TUlCUjNycDE2amxNRUpWcDUyVDlONFhOeThnRStpR3oxR3BpWFJ6elFpSnZhREJUSUpOQXZDcGZtcjErN05qdTNnR1ZWOVQxUjVSTXNMenhqZFc1cHRoV0dwWEFFS3lQQnZaM2hTczhsVFkzWW5VZDZoNERXVlZFbStxMktEMTEvZkdpZ0dhWmJ4a2MzWTIxdW1vUUE3YVZaYjMrOXVqNnZISkN4VnExV3hES0dGNnlxT1dhSjVmcTBObVF4M3A5RVFpYWhZWXYvUkR6bElnRW9uS3U5SXJQRHRYZ2ZBYUpqNDluaW5MNkNycFU3YjdLOCtrR3FHUStXSTA3NWdzaFpLdXpKWUNXVUdyUEdVb2RRZjRud3g3OVozaG9abUZLV1lJQWNMWkkwVnFhVVFQQlpPMGxUUlIxSjkvQ2dWdlQyOU93N2NzL3FQVm9JazZ5a1h2VWJ6U1ZzT0trdjdQL05WdERqMS9IKzkvVDFSZWxTM2FsS0kwR1FpRVppYSttRWxqeGpKakVUbkIyeFYrbUxwbmRtOVNkSjVsNWNXaDRkR2x5VkRwT1JVRUpmQmNhZDJDWjNKVGVLWlZaUkw5dFJRdDg4eGFSN3JHZlZiUHUxTEJ5MGVkTTd5QlBZS3Q1ODg4MDMzbmlEUGxUcy9yVEdzNG9yTGdCNlRVMU5BZit3M29DSTJPc0J6N3dYK2Z0V0pPeVNnWDFOWFpBSG9PVUhQL2dCZHIrSmlRbFRUUlVmeUVWUFBkWHczdU1XMUN4SkxBTk13dmsySnI3YlBBRHFKMCtlUklQTWFBQ1NYZExEMkNjMmJkcUVSOE41cXM0NGczdmgxdlRFMHl2UkljNS84K2JORHovOE1CUHJsL1dBeGd4cENSSVZSaGhEdDMvL2ZnWVRjSUpvQnVlNEdiYWM5U2FkbVg1dElXOWx5TVExVzdac2daeHg1c3daVEJZNno5QjlsbGJxRU5GR1p3MEcvOGFOR3hBWFp2WEFHYlNEem4vKzg1OUhuNTkvL25rOCtPN2R1ekV5YmF3U2tHbHVPUXZsMVdoaUZQRFVaZGJlTmhJcU05cGNJVWJLTVNtajZOdlBmLzd6MWRodnJENWxSYitOeGRrRVRob3FpQTNwL1hta0U2djVXTGtQTTNmSUY4bjVUQjRucEdvc1hLNm5aMnNPa3owME5QRGd2WGYvNEtkUFludGx4YjJVQUp6ekJ4UU9WSk9FempoQnE3QzdXL1NnWkFiNWVudjdvamlyVlgzTjBXTWRQZ0w3U2kwL3RBRTVyQlZHTjlVVE5zbUlLY093SGRieGNSVGFoTldWY2V4NTFyZHc5d0JmcGVTQTcwWVYxNnYzVDA1dkc3T3NnZDZlMFFIMEFSZ1NENDRQWThKSEo2Yk5UcUVDaXhRN29BeFM4L3lLRytKT2tsNmV4cjFWZjJKb2NHcDhZblIwWkhweXdyWGQwTTYyVDAvWGUrdlZXZytHTnc0REg5OVlmNjl4cEF3Q0ZHVFBWZTNmeW5seTdBd1BtMnJsSkZ0cUJ3aW1TcFdnVkx6K2x1Q3BraDlZVWgvSHE2eTV1aXNEdytuQUFIRlJhSkRUTEIrTnpNcXBFbTNod1hYeWRFeTFCSEJGeGtKNFlMV2ErVDNXbE1lRFFBc1ZLaDFqbXFoWkpYWDhpdmpoVmJ6UzNFNk5uRlMva3k0VVdSTVFuNWFXbDNmczJydjVqaDFyV3FvZ2VGVTl5UjljV0E2SEIvcml1QkdGcVFoRGtDYWpXTGlpeFg4Qm9RZlFINmRZLzBMZ2d4Y3hncFFodkFxcFRqVW1KNHMxUUVMdCtNSUxiUWRSTkxjVzlrczRoU3htMnNqU0lsazBLN2doVThhMUdscE1MUU1aeGFYYzNLN1NYMDdvdDI2dWxWS3UybGUydGQ1U0xjWUZRS1p2ZnZPYlVLRVk2bVVhTk1YZ2FiZ0dGa0xyaFZKWUJ2aWRPM2V1V2REdmx0NWxZQklheHgyQk4vaUpSbnJGdGxkaDFEMytoSnNTOVhFbGhIeldGNkR0blNGakc4Z0JJWWZ1aVJNbmR1ellBWmhINDZkUG56NTc5aXlVY3B5QkVJQmY2ZXluczRBa1BJeFl4RTNQblR2SEFJZ08wZklBSkFBa3JrZWYrWUM0STJEMS9mZmZCL3gvLy92Zng0ME9IRGpBb0FlVElOZkcyTGptd1V5L05qWkRxMVM1am41M2lDbEVWbnpHMEVITXdwU1ZZL1JXTHdDeUdrQzV4MG9nNVREYlJMZHhCa0xoUGZmY0F5RUdBNFVSTSsyYkNQLzFPSVBMRVplR0txQk0vMkJtcEZ3ejBFZ0c1YnFGaHZEZmtBM3ppODgrKyt3WHYvakY4b0pzUzNhMWJxNFEwYlpzREZuRkJtdjRrZ0luemJuaHJNU3hWc2o4Y2hhVEZhZTI4YmdYQ3Z5Nng3YXQwd045L2RkbjU2QUR1MWxlTUk4UitIWVJwMVo0UTdVa0duM3dKQVZrdUd3eENrTURBLy9qaVE5bmExU05zNjFDNWN6VVBYMTU1dXBUdi9obEl1RWJ2bDI2aGltTFZrRSttQmU3VndSZ2FyeXQ2UWlKRmZtVnlqMUhEa0Yya2NEM0pQbjQ3LzV2aFMxQ3pDS0VSbGM5NmE2VWhxK2FXTU5VWXI4a2FnSHJFSmdqVkFDT1JxVkZTYVcvTWpFNnZIdnIxS2JwNmFHeEVYRTVaOW53eUtndzVTbnNTVzVBMWlrdVRGVnlLNCtRRkVGTVJhUXdJaXN5NHlBa0NFQ211bUtsc1NqdVFrK2JNZ1pUNGhLcUZXdXRQQUt2cDgvcjdVMjBlaUdtUmI1VEtsSlFLamJpNktUWVRqNkNrTWQ4UEt2MEFVSkFwYnFPM2grUXpaZUJDVlNKYmRmTkNSK1ZvNUMrZEpjRkhqUnZMbytoajhJOWR4MnBWdXZyaFBWbTlaclQxK3N0TkpwUnBKVkdJMm5iNzZtN0lncjVhS1hIOThSQUVZZEoyTFRzNFV4T1FySkk3THgwczk0UVF5TmlRVUgzSk4xTUZoYVhtdENaMm5lRUxLOFhKYkN2TDRwR3lFcVlvTVVvR2F2Z3R0Q3dSVjBUM1dJK2JaclRhc0F6dHZTeUJOQVdhZFdoV1lEWmozLzhZMnp4aGpXUE1YUUVJWHA1cVhUaUFnQVlBQklveVBSclhIRHZ2ZmQyOEg5M3dIN2dLSDVDU1FYWVlOOW5QQjF3QlFvclBsc0ZxVERRMXhTR1orUUJ0RXpvNVozcnJuWTQwRDdnbkFaMjV1d1J2ZkNZMTY1ZHcwODhEaTVBeHdEUE5HbWdKN2pzL1BuenVCNmFQYlJoOUFGL3dnVmtDd0RBejh6TW9NRlg5ZGk3ZHk4YVBIVG9FTVlUV2pJdVkvdVFNRTZkT2tWODNiTm56eDEzM0dIb2JreUlYK2RBUXBOYmI3Qy9YR2lZM29SeFBkQmhCdjI5L2ZiYmpPZm93SUpIMjd0SmMrREZVcitzMWNLWW84TVljR2FGNEJxMGFTSVRtWjZ3VmdXWkZYOC9WeVlET0Jnc3dnQlBJd0dZcFdzQ0NVMUFRRGxLM3hqL2pWVUFuL0YwRkUzV3RJMlovTDJ5R2N4ODRDMHd1U3g2dENHOVA0L2dZd2hXSHNMdkZOdFlhaGwrK055NGFSY01QdGtLOHE0OTAxVXhiV21GRTdzb21TY2g2Ym5qWDZrRW1DcFlWRDh2Rk1oTUtINHJmdUZOMEJLMzN1MjhHRHFMaFBhTWRmMmNvcWl3WXlxcVNvU1hSc1JaNHNSblRCL2pBVEJsbnBNeGcwNVNIWDIvY25zdkpEMEplUjJnUkdDSTVuTmFVS0RQOS9iVWhrYUcra1lHcW4wOTRpVnhpanc5UlNFcGtWRTRJTmJiT0RXZ1Qzc2wxWWVOY3JsU044N3lIR2JIcDFLekxsWGFCVVpFMlB6eTJpK1A1M3VWdmpSYndyQUlhNS9FSXlrcWN4c1ZWVllOSXpFei9iUmlIV0dPbkUxQkN3cUZ2UjcyQjAxUnRXMm1ZTG9TMFdubDJSNHk3TkNLbzZ4Z0pkWTdPMktSNTlyQ3IzYy8rTkNhVzZROGpvMTlJZXZGTyt4RXk0MVdmOVdMclhTNTJScERNeFduNmxqelM0dFlmbEtlUnlZa3pOUUJZMmNWUjhvczRlVVRjY3FTdWo2U3JJTCtKZXBIZ3FqdE9tNnJHU3d1TmRxd240K2IxNHVpWDE4cGZBWDkrZnF3bm9XZEIxVnEyVXVObXVrZU4wZE90U1cydFNIQm1oZDBhUGJKSjUvODRROS95RkFzd2puM1FjTzJSaGdBdkFHeEFOakFBT3FVQUFhb3NNYkIvNEVPdEFZeEFsQUtsUlQ2TjFQZDBLd3BJb2ZPTUJ3UGx3RTRBZGlEZzRPQUhNQ24yZEEzUVBySVNFUGEyTW5SQ3hUZnYzOC8yc2VOeUdBNHBnY0FtMW83bnBvcUw3NXk4T0JCeUNJQW01ZGVlb25tWXY0VnVqVUVGeFB4RGdVYXZYMzY2YWNoeWdEamQrM2FoUVp4STF3QXZKK2Fta0lMdUIzT01DbWYvTDRHaWpvSWZ4U0FqRHhuSXU4SW1mU1M0RjVidDI2bENjZFNxa0hjeXpBb3JGNE12Q21HR25QQndrS0c0UUNmZ2ZwNEtJZ3NHQUhHUTdBSW9mSGk4NExPemlsREE5QldLNUptZjdQa1ZrY0lHck5CMlNoU3Jnb0JrZXU1NTU0clk3OHhHSlREUDFlNzlvM1RoQ0xPQm0zK2RsNjZONmZ4MFhJa2ptVG5wM25vc2lwRnJ1YnJhMTUzRHR1cys1ZDFqdlFxaXVqWWhmS25vZFZXRVlKWC9uN2V0aVRaWTVzR1dOWnJ0US82YnVTOHZQUldXSGxob2lJTzNpN29pSlZOVjA0bys0L0dNbWdFbUtQa2JmRUdiSEc0YjJSbHJBSGZVL0dWdlY1NTZXMm40anAxVFRIQjdUMFJPSFErMUJJa0E1SElQNUtxSjJWLzE3ZjVTNlJoQlkzWmtJR1VBRkZUOEowc0oyS2cyMTh5QUdTQmloTHY1a1MvRG8wc1dyY3V6ZGJjUk8zZWZuZnVhaTdncVVCTEdDeGVNNXRvN1RES010WHF4cEt5cjRnZUoxblFzdnNIMXNIK2xwb1I3RHhZSUNPQnZwamlOVTQ0MGNLSmVWYUpRL2ViU2dwWkhJNU9idHF4OTRDOVZ1aVFocERhUVJEV1lzdXpWWUdyVm9UV0lJaXdzN2hPTDNTaXVsK0J6Rit2dWoxZXhhVmp5UFVjOFUzaVRZMHpKbzBrc1poSlZENXo3RHdUQmUwRVVicXd1RHcrTW5SVHhGa3hFc0pNUWVwQmhveEtBS2p3Vit1NmMwZ1RwVlY5N1pRVTE5MWpsZVYvZFlYWjFTWHR5d2JQTmVFZjgvN3l5eS8vOVYvL05lUElHR3B1L0tubVcwekxCallBNUtCTmtxR1d2RUJmK01JWGpodzVzckduQUg0QVMzQlRJQk4xUWZSbmVIaVkyV2hRc2tuMWo3NEJJMDM4SFQ1TVRFeHMyN2FOWnZrTjNCcDRETUFtTktJUnRNWkNCaGdCUWp2dEhMZzdpeGVnWXlkUG5zUmZvZkhUTVlFL1FSWEdTYlJHWndSNkRyZ0ZoT09DR3pkdTRBd1FGNCtBSGo3enpETXZ2UERDZ1FNSGR1N2N1V1hMRmo3N29VT0hLQURob1ppVlIrWWNDajBkNGp3NGFJWU5xYXdyYzdJWUdJRjJSa2RITVhxWUw5eml0ZGRlKyt4blA4c3NnTlhLQUczK2tNUFlzb0YvVmgxRWd4aDJEQVV1WVB5bW9YN2lCSFd3K3BSTDhCbmVYQk53eHhoK3F1ODBJeG5EZnBrSXNrejFYNjVEd1JZd2hwREQwRGVtbGxnbFlpc1Q0bGRPNVRkNWc0WXlpTmdmQk1HR2JQNjVQaU5KNU5pYnliR21wbmZGWnR2T0M2MWx1VE5lYy9JcE1IUXlhRXBlVGJQQmRENlQ3RmVROGVVd2JKY0NwYkNmOS9mMlpicWtjR1pzWk5qZTBMYVo1VVZWM2NKUXJUZExiYnRzL3VmdEpTYWY2cHVWNXhmUTRQekJYMGs4QTVSWU1Takh5aytTRThDa3ZtUFhmYSt2WGgyc1ZXdGk4eEtFZDIxM3hRVmtDV211QTN4eTdhU3hFQzVXaFNRL1p4MVNTN0xNaUpOZzRmbzFYN1B2cE9kSlduaGZNbHNpL21KSDBzOEVFMU5hb1NWY01RYmlXbFdKekxNQmFPdWJNSnplZnR1dllzTEVjc0RvQ0ZmdEx3azVhblhxRFdtU3JENWxieVJoclpUQVc1dmRUM2p0b0pzbkdhbHpyVHgxVW1JcUlUOUg4cW9JTFVFY1N4eWVxMVluTXVIZ1o5aHNITHIvd2VHeHNmV2lIeGlYaW05VG1FdXMySVd3bWtSTEN3dDFUUjBRazAyVXRvS29Va3ZFbHBCR2tuY250SVYyckptUGt1T1hSR3BNcVdvWVNwSjdBUndadHFYR2NsTXlCbXRsdlY4MWZxZW9ZSkM3dkd6YWsvSnNQdGJ3c1ZqVzB1cFc4bG5MZTFxMmdocjZzN0xHYndLd3lVbkhjSHFBZ2FsVmc1TlE4Z0JMMy96bU4vRUJ1RVZSQUZzSGR2YXlaeFJiTnNDSnVoMUR3Zm5hUWRQOXRWLzd0YTk4NVN2MmhuWVp2TXBBU203NnVDbER0NHd1Ym9vS292OUFVL3FKR2VMSGFuak1EdGl3ekZFbWh3ZDAwWCs4V1dweDl4UDhtTjJBVzBCS09IUG1ETDRDakdmMDNMbHo1NDRkTzRhdlFJUEhzOTk5OTkxWHJseEJJL3YyN2J2enpqdlIrWi8rOUtlN2QrL0dnL3pnQnorQXh2LzQ0NCsvK09LTHYvclZyOUFPem0vYXRBblNCbHJHVnlEb2xBTXpHY3JBMEwvMStvOFJNRWJ2Y25FSEUvQ1BuMmlXSUEzTXh1amhFU0NPWVBSd1IrUEtLUjhjWjRoRUgvbklSMTUvL2ZVMzMzeVQzRWVXSmlXaUhjZ3VkTWxqZk5BQmlBaFdRVWpBYW8yM01PZ1dJWFhHd1dHbysybHFJaDBDVXpad0RicU4vdUF1WmFHV0Y3QlhOQkZSNGtFUGp4OC9qdUg5MEljK3REcjJzOHdXc05vR1FEbUFTdjhHc1o4VWR3cUNPWkZmVXZEZ1VHM0pLK0E2ZWJuU1BJc3V0OWl2dTdtOWQvYkM0bktUM0tsVSszTjNQaUhMc1ZacUJkTy9JQlp0MzYxVWxwdE42TGE3N3RpK29RM0dJa0dSckltOHVtQ3VjRkowSWFOZjdsek90L1NzUk9lYjVzNy9ENjc0azM0b1ptSmtMaHpKbU5aOFo2UzNQdFRYVXhmd3Q2aGY1cnlJU2ljazFYWGxHMW5qL09ubXBUT1NrSzlLcWpER0NIbHBpTlh0OXZUNVhsMFloZEJtSEVsSlk3SDhKd3pXVUU1RlQ2SXFoSXd2bG1URFRLUVFzVVNMOUpOS01SNTczZkFNdTFZVGFyOVdJTWtQWWdnVHhudDlxSVJHYXpJZFdwcVRvV21FQmZwbDZpNVpYbHpUZFptRlFTcE1LU3pyTEpDdnpJUFk3dU04Vk41ekVyVTJKVmxCRlMyV0Voc0NkaFJFUis1N3lGL0hsWUFIZ1JpVlJYWWlWUXFrNElCMktzWHlnYnlKZjZEMVU4aEMvOElnRHVLb0ZqZnNCSzBOMkpMT21FQXcwcktCR0V5UmtQUk5UdTFpamVCRUs0eVdHczJlbXl4UGhmUllQSHN1dEZvbEdkYktUVXBrd3N3ckIzV1BtKzJaNVgyL0xRRFErRllCcU5qQkwraUJyUjhiTkZDSFJsZHNkdGYwZ01LTkx3THpxRjR6cFAreUhvQUtZakFKQWJIRkUvVk5iUnRvcmwvLyt0ZDM3Tml4c1FlWm5wNSs0b2tuMEVPUzdWQURKbFUrT2pPdkIzM0pOQytUaEJpOUluc2RMc1puR3A4L3FQd0UwREs2STdWa0dwTVpjNDQyV1lTWEVoS1FIaWVocndPUWNQRjc3NzEzK3ZScERBamtIdGJuZmZUUlIxOTk5ZFdubjM0YVY2SkxGeTllUkQ4aEVFREx4OFhvSjRZSWtJL2hncVIxOHVSSmpQbisvZnM1RjB3ak5GaEYvcHdPb2Y1V3dSbHN5aTJXMVZ4aUlXbVhxSmVUcUlmZ1NwQ3I2YkVhKy9FbmlJYkFmcXdUTEJnOG1zbXp4NTltWm1iSUJJWHBXRmhZZU9lZGQzQisrL2J0YUFyU1FJY3lBZVdBUkNPbWNNQU4yV0paRnllL01rWVBqL1BLSzYvd2lRd3prbUVJd0RVRy9qRXA2QjZrazBjZWVhU2MrbEUyN0xjRnZwUU5ZK3pHeHYzOUFwSXBkWG4xaE90RzV1cE9Md0YwTE4rbmNWQ09VWERzdkw3UGV0TThPenYvMG12SG9OcDVMZ2V1Uk1DamlwSzlVditOTWZLQ25QUEw4MVpMdksxN2Q5d3hOVG14d2YwbHp4ODBHWW5XU2tXQklrWXhLMm9XMlZsQkhVRGpSdUdOMkloV0kwcE1VbXhockFNb3FZZTl2amRRcS9SVy9XcEZLWElrM0N3V3BodlBsK0J6NVRkeVdYMVBHUXZVVWVBcU1ZOEFlQlpIcVdaVVNpaS83MW1xTXVjMWlKS3NDRE9uZ1o5c0NwcWc2RHFXNzZaaFpFZVN0eWdQRlhjaURyTHJ2ZW5DdkYzRVBCYnJUbk1GYzVOSW52NUI5a2F4RGlXeEZZa0Z3QXJXcnVhSGR6Y05XNm5oNnJHMEFKL3JoRkZpRytvSWtaTWtxcEo4aXBEK1BTVjFIaDRaUG5UUHZmNDY5a09seXhPY1RsZ21XckpDQk1iRHpLL2FRUE13eTZxMjhBUTdVWXBkSTRJWUZLZXBIemJ0dU9ub3NFZXN2VWNxQzlrbWxHMUFpS3pvcUxPaU9GMWNhb3dORFJsKzM4SndWR1RaMm95UEliK0VQSWlicy9sTDFLUmw5Z1dybStEZjdzZzArMW9iWmFsVnNMS2ZQWHNXTUFNY3dqN09xcXdNMm1LdVBDblY2RDdIK2RuWldhamcrQXpBb0ZzZEFJRGRuOWREYzRWR2k4dE9uVHJGSUhac2x4Lzk2RWYvNGkvKzR1alJveHQrRnR3Q3phS3JkQ0hURGdIc0pJa1FOR01nRGJwdEtncGFXaDZYRUlVT015Y3crZUE1SUV4SXcxNWhTQUtNQVlBV1lKcFMwQTBLVDhDVjhmRnhwaHVjT0hFQ1F3bzlIc0FQZ2VuYjMvNDJSZ210UVk1QmYzNzg0eDkvOTd2ZnhRQisrdE9mWm00a0FaZ2VoTU9IRCtNRDFGTzB6RHA3ZkRRU0c3Q2dId1dSRGt3TVZpblR6K2o2TkpDVWs5Y1pWZkRXVzIraGNWcEh1QWJJcDdUR2JsRGdMb3NOTXBXUjdXRE1zUjRBeHZpSi9nUDFMMTI2TkRJeVFtUFNQZmZjWTB3WG5lR2ZTNWREWWVJSlRNbHBVekdTb2crbUdPTFJ1KysrUzlYZktxaUVlSkRRaWJ4TWxBUE9uei8vNXB0dllpNHdVMjBHc0hKK2Z4dkJwZm1WWEVNYnR2a1hDZmUyc0pYUkhaN2t6a3c3eVNQOVdPVlcxU0p1ZWVRQXZsbVgxR1hSbUxseTlhVmZIWnU1Y3NXVG5IakRHR2lVN054V1doVDhUYk04YkUwWWdzTkdBMnZ1Z2Z1T2JNeFBxcHEyaEl6bEhDNWE5WWN4ZDA3QndpN2R6a01aN1pYeVJPcDlkK3lOdW1lWjdwZ3ErUUVnMm5FOERZd0QzUGRXcS8zMVdrOU5YR0dhMXhoSlBKbFlsaVdlVUNyVlc2UTV0WVZkSi9lc09Fb3JHQ3VnNTNVblJWOFZRNFlHUkdLcDVjbG1PYm1SWkNzSVBRMXdyWUk5SUdVNG1wTkhhQ1JRYzRQUXl0YU5CN0g3QjYyWlN4WjVBUlBsTzdhWlc2Qko3VmJCaVNpcEJCSW9KK2w0bHB0bXNjd2o5UHNvZEZicDZLTDNNMEludGZKdVM5aGdCQ3lPNGtRRE9HMngrd3V4ZnVwa0JGVEo3SStDNXZiREI2ZTNidXN3ejQ3V25ZZzBPMFFyWm1TKzdRWlJQRml2aXNTVUJMYmxpNTNGTTFSVXJ1VlVJQUNsVWRPU2VzZ1ZyZFVjYWxhcEk4a0lib1ZFaUs1SVlqSitDOHRpOXU4dGtTNlFlcUlJdGlHMEcwNk0zT2l2S3l1OVZSTE1mMVBzTjJGQUpyRGZLa3F0TUNJUFlBOGRDSm9vZEhjZ0JQZFpZaDYyYjFNNm5mb2NWVVBHT1dPcXNaOWlKOFdXeW5SdHh0aVRHUVlxN0l3ZVVHRy8vT1V2ZitsTFh3TDQvVmVlaFdGMGhxUVc5eVdoSGhBRjNhQk5tRFErZ0NKU3g5QVlUdTRhVnFiWmdML2ZFQXdibzdHaGtHTWNBMlBjMEJQOGlpN2g3bE5UVTdnZVVJUWhmZXl4eHo3NXlVOENZK2dqSVBjUmZuM2lpU2ZRU1Z4dzExMTNQZnJvbzFENm0zcGc5SXdGRzRQNXdBTVA0QU1rSHZTZnhmZG93NmM2Ym1qL2I0bjlIUWpwcUNWajZJYUdoaUQvNFRQZ21iekZqRjVjTTlBUEY5QXhoR2RCbjQ4ZlA4N0ZnN0dDb1BPcFQzMktRUmhQUGZYVXozNzJNNXpIeUFCeDhUaTNwQW91TzZUSzFEMkVlZm9DNkVSZ0ZnTTlNdmZmZi85UGZ2SVRpTEFNQW1Va2lsWFUzV0dTSWZrSzhTdTZnZDVpTG9qOTVmREF0bkRYOWZpdE41N2paNmo3MG9JR0p5c1krSFBPZlFVUWRRRm51VEtqNW5Ucy8yY3ZYSERFNXlHcDNyRXV1OW01eFN2WHIwTkNxL21WSWlPQWFYdUZlN1RRQWpPYTUxVnAwNjB5RHBwUnZWYi90WWNmSEI4YjJTQUVpMUtxWEVGVTYyaDNkYXpDK0tCcEMxb3V0cWd0V0pRa3BDRkFjRzJEZHliYkJSM1dFb2huSlZnWHZ1UGk3ZStyeXc0Z3ptYmxINUpVZnI4aTRvR0x3Wk1WWXptR1gwQWFrZGtGbUN0UmowWlh1QzZOMFhKZWt5V1QxR0h1UWxHM3lFbVZIQU9icXBBVHVFa3JjSUJ6MVdxcUFxbncyenJSK3RCdnVYMzl1RGhyTmRXdHJkcVlLSzl5THlsNWs3RWJXWkZXSU5GNk1uWmtKdzBEN01ScnBQbEJ1bysxM2tuQjYyam5XclViWlRHR1J0Z0JzSGNuVW1iUDA3SjllSDFxVlM5Y21OOXorSjdlOWN0MmtWcllnd3h1SlkwZzduRnFHRDdnZVNEc0M4SzdMTEpGNWdLMDY1V3FwUENKRlNicUh4bDNmSDlwYVFFbzcvczkyRFZWWm81VmJjY0ZzZTFWMVo2VkthTkUxbXlGUzQybXdYNVZUSW9ZVjc0alZ2R1cwRkNpUlErS3V0V1pGaUpLYmJ2TDU5K3UrcStNWjZIWk1GWUxPdG1aTTJlQTBQaU12WjdtNi9MMlJ6czJJOEpZbXBhYkw1VkNLcnZNTzhkWGdFYUVTUUFoOXRZSEgzenc5My8vOXdGc2UvZnUvYTgvQ081MTQ4WU42S1pYcmx4QmgzRUxFdStiT250R0N3UkFZb3NIQUxQbVBlM1loaGwzQTlodkNHaE5OQmtOSWZRNnMyLzBMekJISDNlbmpQSzd2L3U3MElCWm5ROHRRSlVIdUw3MDBrc2YrY2hIQUlHUWlqRHMwRmxaUGUrVlYxNlpuWjA5ZE9nUTR5UllHb0FxTzFuOW9XR3pQZ0xqKzB6Vm4xdm1Makl3d3NUdFd6ZG4rWk9XZ0ZXSTBBME1MekFTcStLTk45NDRjT0JBbWZ1aEhCbUg4ZitYZi9rWGpQQkhQL3JSZSsrOTk1bG5ub0dzZzc1QnN3ZXlvZ1ZhTWo3em1jL2dFYjd6bmU4dzRnL0QwdG5aenhzWjlsL0QwTXlnUW80OHB4aURSakdVSVpZWVJzaFBHRnRLYWZnVHkwVGhKOFFPOUpNMGxCaEQ5QTBUWVI2ZkJTZnhkVXEwcGl6aDZsNjFqVUNINWRTUnoxOERzSnhDYzFuaHcxUHZybDM0Nm5NT1V5MldTMUp6b04zNVM1ZmVPMy9KVTJvV2htcmhiS1hpQSt6U1BESmFFNmRNOUExTG5EUFdQcGN3NVBkSUNxMjN4b1pISG4zb2dmMTdkbXo0bmN4Wit1eVZZVm94T0p2cWEwV2hJdklVSzVZNnRBQ2tSWnIyQnU1YmhkSWVLVitRQk85bnNYTHVRQXp1clZZd0dxN2FGYUJ1K2w3VmMzMjNVdk1jb1FpR1FHQlQyeWVvTWtCVVE1cnNQRmpCVW5PMHAvUjNLcUVrdUUyTWUxa2tHWmFNUCtWRTFvQjZDVlJ6Ni9Mb2dmYkI4UW4vV1pKMjBqUFFGRjZEVmlPem1NV1h1Vm5DVER3bmtWNWxucDBYTzR6RldhN2hJV0pQVVdOUmFpOHZXd09EYmR0OEFvRWcwVW9Ra3VHZ2FLangxNkp3UTcxMldQWUtxMWJTRzBYQXNlMGFSa2J5T3l2Nzd6NWFxYTdQY3FqMWpFSXBuQ2lsQ3NJb3F2c1ZDRzZlTUM1SHRVVERIU1VJSUJPV2hXb1Y4NEMzc3RiVDJ6c3dDSjBsaytoZk5RbUpuaVR4QjVnTEtjdVUwZ29kUzRFa3h3NFRpZllmR3hySU0zT3NuSk9LTkJWbHRiNGN1OHJRMmR6bW53ZVhkQS9MS3FXMEdkUTNSS2VBRStnOWI3LzlOdmI2VFpzMlllL0RkbzlmY1pKZllieTZxVjFiTHFiSHVEbnFlYlJJRTJBVzlYai8vZmVoNEg1SWp6MTc5dnl2ZXBhclY2LysyNy85R3dDR1VXL1l3ZEZuRTNOQWhoOTBIdkI1N2RvMTZIOFhMbHlBVmdjOEFPeXhJRDJnZEdOeC9vUllzK01iaGM4TUtjc1JzUnRBRjBBSVJoV0lDSjJlelB3RU1NQVZ4dVRGRjEvRXMyemJ0bzAraUw2K1BpRHVpUk1uTVBoUFBQSEU5dTNiU1VOazlFNnkvS0lkaUF2QVBEdysrN05tSGFiMXNKK2lXOWtIVkdiRW93TWVjN2RqeHc0T0lGY09CU1ltRkxUcC9SY3ZYdnpSajM2RWxmUGhEMzhZRTRFWmh4eUpaMGVidjlBRFBmell4ejRHNllIaTQyMlNLclpsblJoNXhiaHlNQUs0NlpZdFc2YW5wekhkYzNwZ1pMQlFJV1o5NHh2ZndMM29wOEJYdUhweEFlQ2ZJYUpZbkhSczBlMXl4eDEzUUJiQm1EL3l5Q040OE5PblQ2Tk5FaFdYM3lEakxqR09rczQ4VVozeisyMkN2RVBWTTYvY2wyVkZJVDltY3hWVWZqYkZBUktWaXdOWGZOWWVOUjBKcnhLTzlOUXFTZ0VXTnhCSzNWUlo5aDB0ZE00NHFUU3h3cWdWSnpHMHF5TjNIcmo3cm9NYmR2TWJETmErNVRrS3BQb3ZKSlppc3NsT1krZHlRUDdJbG9DY21ObmRqV2orRHVQR3BBNEFuczZ0WUhFc0IrSnloaVRrT1pLOUo3NSt3U1I5UzF6SDkxemxrOU4zeFJFNllRbE4xSHp4UlBpQXBCMW1DbnJDU2VmSmQ5d3NqSjJ3Q2MyQ2VmZDJFbHFrUTVRWFFCQWJHcitkdXZLVXJuTHdob21sYVJ0ZTFVOHpxN01WMm9icWYrMUtiaFJoNmdkNm1xU1owV25UVkVVTnFiY2tVZ3NHTllnMDY5OU5HczIyRllZT3BVRXJwVFZjd2hjb1YybFlCL21oMVVJSUNRQzd0VVNBc254alpnWE4xdlNteVR0Mjc3TTZSZ3pWcW5VbytHRXMwd3Q1TzgwcUVxRXExWGt6NFQ5MFVzZVJNcjVCRU5mOVRJTCtuQXFHY0hoazVOTGxDNjBXZHN4RVV2L3N2RUJCa2pFMkQvcVRuMnZ2NG11eEZ4ckxyVERzTFFLeWhNUTZKNTVNOUVWWWVTdFdCRXdURDVobFhaMi96WHhxV005TVVCaGo5N0JGTXNDYk9kbjRNRFkyaHIzN3pUZmZQSGZ1SERVcUF4TEVWMVBnam4raWNaV1V1dFRQYUNqR0I4QUF0TmkvL2R1L2hXcjcrT09QZi9LVG53VHNiU3k4M3h4UVRMRXZBL0wzN2R0SHRaNGNQZ1FuUUNOMjU1Ly8vT2Y0Y09USUVmVGh0ZGRldzBhUFRYOVNEMERzek14TWgvaXNXN3FmemErR3dvakF6dzhNZXNCZE1JWVlCR0F0Y01VRTJCdW9SdDl3RFFZWkhZTzZpYi9TbmcvQjY3SEhIcnZ2dnZzb1VaSFhEejh4VFhnNnhzWXpkWUtDVjF2Vyt5MGZ3UkFDR3Zndis3a1pNb21ESkVXQVJzNTRHK29iT0FTSVFsaTVjZU1HSHZia3laT1FZekRMVFBmSElFUHdJdjBSN25MczJERUFLbHJEOCtMQk1TYTN1VzRwTFpsZ1Jxc296WUFXTUlZc2ZnZ0pBS09Fb2FPVWNQLzk5Mk9pMzNubkhXT2JvYldESGdxbk9JRDk2Q0VOTFZoT1I0OGV4U00vK3VpajlLcTg5ZFpiV0drRy9tbFg0TEl4b1FDM2xHQTY4dm1uR3RIbFdpU0pLUkZyRllGTWVjWjhTcnR2WG9oSGZmVXVYYUNxUXVWRmRLelVoQUhZVmtGMnBpRHJXb1VlbE9Ya0FQajY2TWpRMXMxVGUzZnVtSndZcTIwbzcyWFYwaExhUEVjNWZOWE5iMnQ2UWxwRVhXVUZtNUJkeUQxRS8xU0x0SkFqYnlPK0J2VVdDRmlIWWFTcXJYaEpmRWRTK1lVelIybnloVXBleEFEUFlRcWx4YXAxMGorSGxZY2pkYmVybktJQmJabGZyZFBDclZiMFpobzB4YllRU3NsZUlmZVZmcWZxSDRDZ2tFcEJIRjlEQ0NTMlFFSXBITTlUdWNlTFhhY3pHWVBUUHlpdUVxSGljYlY4RCtzR3FpTStqbDB1TThmS2FRQUF0MDZleWlqVXpFR3p2YmtvbERJL1FuSGdNcm96MDFLNWxwMnpBNnZIUnlvK0c3RlZSUUM3MFd6dFBYaDRaSFM4bzRTSEowdEVwYSs0elpiNDBPU2w4QjNQOTN4VktmV3RrRHlITUU0cWNTaEZqNkFzUXJ6cEd4am83dy9EZWUxT0luR1ZQaVF3UzJzdWUzbk5Lb3RjRUJua25GWVlMSXJadjg2YjV0dVR4aGRZRHJQOWJnNDF5ZXRlMGNCazU5a2MzVU1QR3IyNVo1bENxTmlGYVRiSHZvbjlGQm9iTUlaS0liWk9ZdFhseTVjWlNNODlsMXVoU2FFMmhYU05POWJFanBra2FWd0F2WmFjLzlER3Z2akZMMzcrODU4M0dkVWJPQ0NkUUduR2xuM28wQ0dHSWtJOVpRbEI4dVJBcllmVWdsdERqUU13QUpDZzkxUFB3K1BzM0xtek0wRjlaeWhpa0lHcEk4ZkhCRlRRQ29JYlFYS2lkUUhuZ1NVWVNkYTI0U0JiUlV3K1B1L2F0UXRkUFgvK3ZLbitoeGFBUFdqRUdGY3dUWXl1d0F3U3ZjZ1RiSXJrbGszeHQ4TlhhS29ibTVCUDQ3Q2dLTUEwUHh3SER4NDhmdnc0Mm1TUzNtcnN4eGZSY3d3NCtvWVAzL3JXdDU1NDRvbTllL2RDR3NNanMrZThIYVllZ3c5OGhhWU9RTjJ4WThmKy9mdHY2YUppeEFrOUdneHBOTkVrR0V6S0pSQ0pBUHdQUFBBQUxvTUl5TkFIOU9laGh4NTY5ZFZYTWZ1VXRHaXRzVW9WR3ZGUWZGNHM3eGRlZU9IZi8vM2ZEeDgrekloUk5BTEJBaGRBcGpHWkR2eEpudzd6VnVqNTJuZ2R2elJud3lmWnJjYnpjeDV6eG5KVE5pOEhUN09kc2VCZGJ1ZTBGVzd6Nm1zMkU5NVNVL1d2Q0NqVUFaV1FOYnl5L1gxOSsvZnNPckIzOThqdzBQOTZ6Mkp1MnM4anNPd1Z3bmxWdG9sWUpsYUxVWDdxeGRpZ1BxQk03a2tzMldwWUxBN1o4Q1NhejZ1S2ZWcW9lWUJNTnJCSllnQjhyZlNTQUt5WUNwZ0hDb2c1UFZYZSt6eGFBZDkzSzlXa0dhZFJTeFlKbFA1bW9IbnprUVVwdUZxeEtsNlVSa0VzNGV3T0F3b3NSZzhvZDcySUFhNTZZeEs4TjFubm1paTFIcmZla3l6TVd3VkhIUlorSm0reURaRmJHWHBFTjdaVTRORHNndHpTSkNRSmpZWWx5UVZ1S2RBdnpKSlFoRHZHdk1mcXlKQmdCU21oaTBVckdZcEFYOWNtbzVLKzlnNXo0dzdmZTIvZjRFQkg2M0VTUkFGYTYrdnBDYXBKSkJrdW1kOHJCaFZQdzFLVW01Q2wzUFgyY2NnNEJod0RROE0zNWhiRW1wSEdjalBzQzVtRUsxSmt6WnpjeGFWRDROcHhOci9RR0IwYzlGbmQyQ3FjUmJabENDNGR1cnRLSzg5UTB1VENjUGZRZzZIcHh1YlBlbXZRMktEM2tCYVhObFhTelRKZ0huc2lZOVFoSDJBVFpDNFRRUXNucVpLV2M2L0xlRzgyWE82NUxOZEdGdHUvK3F1L2V2bmxsNy8ydGE4Qm1EZU0vWHYyN0FIU28vOEF6dXZYcndOWEFLTFkraUhIa09LWFFnbCtwZDBDYUFTRXdFOEFCaFJRMnRJM3BOazRaYVozUGlhdDBDUXpnTkpQWGovQVB3YVFwbkppSkhtQjBCL1c0R0dhQUFaODM3NTlIRmlTRm5CMkNEQzRudm85bXVJZE9VR0VROEtxa2NNNkovaVYzUlpNUkN5NytTbldjTkQ2Ky92WmY4aUNHREgwQVhla0FNY2t3SExnQmNVYVN3c1E0K3RQUGZVVUpoZkRUb2hsWFNKak5nQzRvcmVRQWlFRWpLMURIMklPVmpFd3NZUmN3L1FsVVVMRm1uejMzWGRKRU1sUWpJbUpDZlNaNlFtLy9kdS8vZHh6eitFQ0Evd21Dc1F3OXhtQkFHUHlveC85NkN0ZitRcnUrSk9mL0FUaUN4dnNGMTBsWlBFSVNuaVlDMHd4UFZ4NFpFT1dzQkhzMTdJMnVWcVQ1RXkrRXVxZmFoWi9XcktsWjRYV3A5a0FtYnBvV1ZySG9ZcHZNNW8rait3cndENlB1ak5tZDViemdjWVduSHpuOU1YTE0rTWpJOXUzYnQ2eGZldC8wUkMzWWhaekRJTlF4Z2R6VEZVQzJ5cHlEUmpHcUozTUNkblRQT1poUSs4azFuQ2N5UHVEN3d1VG5JYkgrNjViY1N1ZTV6Tk1ST0w3TWhwUXlKU1RXRXlaa1BoRUFmQTg5VitvZnIwMFNDUnVNWXFUMW5MU0N2eGxWNXpTeXkzQlR0RnhYRHNLMFdJVVJzdExEZXg4YmsvVjgyc1NOQ2VGZkVScngzcUg4aTFPQmVCYzV0MUNCOFVVOWZZbGM3TkszS2prRmVoT25HaHlJSVpVZVlJbEtTRmhKS0Fwa2lSbWlqRElvSTJWc0Q4RjlrY3hrRlhVWkkwUHlCSys0UktMcDl4TElwSFFkS0ZlSUFtdkQ0S3dyNy8zcnNOSE9yQ0QwVVNQNitNRVQ1WFdlM3lJUm1FV09tbGRSV0N2cnk1Q3E1ajVwY08yM2lKbUxRZjBZbVI0NHRMN1Z4SVdRNUlxUWxKVFFUSWowbGpNSlNLWVZtamZvajExU1RWTzM2dmIrZUpYU1ZIZmhMenVBUGtWMUVXVzVyUlJkczRZa1RsV1YrOHZEaWFtVTUyaVF2UHNzODgrK2VTVEFFNFMxRkQvdzRhTExZOWhlclRoWTc4RDNsQ2JaOWdhdFIrak41TmJ6ZENjTWFLZXZnQmpHaVdTQWZ5ZzlxRW5Uei85TkRydzUzLys1eHRMOGNmK2kwMFpLUDdUbi80VW9IamZmZmM5OHNnamI3LzlOaFJRb0F2K0JMaTZkdTBhQS92eEsvQ0pUSDhBMXp2dnZIUDM3dDJuVDU4bW5HeGdxeW5Ib0JrMFplUWpmZkJHZGFaTkFrOUtsUlNqYXBqZ3lQelArRVNHbnRHWWoxNlJKWW5PQWxObGh6dzVURnNnZUJ2ZmdZRi9hMVdSeHZWOGRoUW0ybExuVFZVZU5MNXQyemJJVll4OXd3cGg2VVZlWXpJRm1OcCs1c3laa3lkUG9qV2FKVEN3alBESExkQVVRMEg1SUZnRGRMZmp3KzBFZjBDMmUrV1ZWeGpJeVhBVG5JRVl5b2xqWmFhR0hwaDZURGRFcVB2dnZ4OGlCWWZpcnJ2dStyM2YrNzEvK3FkL3dsOHBLNWo2QmVXVUFUNDdPbzhWOHQ1NzcrRlhQQkV6Vkdud053c2JEMnZDS3BudnlwSHNYRUtwMDA3cTB0ak40RDJiRkxHTzZ1OEZTNzJUT3dOSW1PdHJkSHBDN2xzN1R3RzBDMEw3d3NRdkdXQ3BjdHlvbXEvQmhGUm5jd2lXa3d0THkzT0xTeGN2emJ4NThwM0pzYkY3amh6Y3ZXUDdmdzM1YzVvZSt2T2RuRWsrRHkvSWd4UUtRcFpjT01oTVRJS0tBQ0plZlhCYm5NS0FENFhlVHB2UXpqWFdMK1A3NlpJMFNDQlNpaG5JMzJLcjRwTTVWNUwxZ0RseDZqQ0dNbmUwcEVrVVprbzdrd0pDSTNHNG9mTjk0a0tnNjhCT2xDVW5rZXdPQ1ZmTHFqVnNTRjYxVXF0WEszZ1BJNGdobm9QelVUT2pEZHgyYm9sQ1VJcnRDK2VrSXJDRUdtcGhuMUQ5cklLa1N1cEFTWW5FaGRDMDdEeDJNNG1qdE5sd1M3UWIyRTZTTU1KaktsSm5lZFNiY25ncnFIb0p0NGswSjFRU203OWxMVGVXOSsrL1oyckwxbHRGalhFOVdhMHd4Z2ozOVZTaHBZUWlTVmppKzA4ajljQjRHcjJaMnJKRk9sa1NDWTFBbXFxcnNtOTJibEdGdlV5TmxXS2RpYU5tRXNWdTV0dGVvbVlEV1F1U094Q0ZpOHVOM3A1NmxsZUh5RXMxNWxrcXVxanl5Z3A1OGF1Q3pxZkw2ck1LTDQzTkUvc3ZsTFB2Zk9jN1VQck4xazlsbExSMGpCN25wbWJpb3JuLzhxRHFUNE1xcVd5TTU1aW1WSnExYWJQbHIwWnVvQWIyekRQUEFQdi84aS8vRWdMQkJ2ejlVT2xlZSswMUFPcG5Qdk9aeHg5L25KYmJvMGVQUWlmREpnN2xEMXIrenAwN2YvbkxYK0w4Z3c4KytLMXZmUXMzT25EZ0FDUUd3TU91WGJzMjVuUXdqMWxPUDZQU3o1L2syTWNJQTV5ZzNiS0FFTm1FS0RCeFRPaS9aMmtEZkFDazRiczB0NUNoajNCaXFnR1J1N0JhSE1iNVhUWkNmS0RGVUk1Z0w1UGQwcHdPZFIrQ0ZIckZtQU1JSWhndS9NUTFobEFJUHdIR2I3enhCcTZrSkFRcGg1SWlUUmVrUWVSYlR3UEQ4ZVBIWDNycEpWeHpPK3dPYUFFdFl6WlpCWURFU2d5cTRDSmtZaXFuSGoyaHFJcHJ5SG1NQStPUEdjY0h5REZvalJJU2ZmOXRZUVQ0aVVXRjFRSmhGQ2V4U0xqQ1RYNmc4YWRRZE9ORTQrbG9ZK2hBRTlreDFvK09Ta2tkRnl1MXBRbHFWUHdKcGNKTDdxaFk0ZVJaZmdYSlNXYkljNVNjSmN0TC9SVE9Fc04zWnJQNUZmZW9Pc1F6Q1h6ejhzcm82Y1hMVjJhdVhqdTRmL2VISHJpM1dxMXNIUDF6Y1VUNzUrUWtmd1VIb2FFVExvclVhaGhiRVl5dHVxa1ZXeHVKdjlYSDBacDZVT0RsZmNpZENJd09zeldiTE02cFkxeVpkVXZ6K0NBSUVKU1oxODg0ZUNIbkFmZ3lna0lNQ1dtY3hBdFNmRjY0ZjFNSmx4UWpnMVpBQU1TN1hrK1BWNnRHV2ZUbThST3ZuWHBucVJWOCtOQ2RoL2J2Y2ZDQ1FhbE5VaXNLYk92V0ZlV2MvaUhMODYxbVM0SUpBbjBlRFNjcVFqZHNWZGV0b29LUXhpR3dER0thWkkxbGF6alB6SVRva29ZdERlM1RvUkNEbThZYU9pd0ZJWkYxV2FqcEsxWVNKUkttNE9GTW5FVkJjTmVSZTBiSHgyODUxbGFTdXNvYURCRzBYcXRnNk1JMHJ2dWVTSndXS2JSOGlkYXp1SnRJTldVSVN2ejYwTkR3L1B5Q01BcHJnSVk0cXZ5S2lBbGgweVoxaGNNd2gxUzlCOTc4Y21OOFpEZ3ZXYTdMWE9TNHdycVZGcFY4bFdNb3l3WE5sY0NTN3JIaTVTWG9ZanM3ZGVyVWYvekhmMEMvb1NaRXF6aXR5aVo0MjhTdllhTUVVbUt6eHBiSFhDa0EyK1hMbHk5ZXZFaW5nR0ZUcHdac3VGREs5bFZDaStFTUlKTDk1My8rNXovKzR6Lyt3Ui84d1FkbDJJV1M5L3p6ejJPWC85U25QdldoRDMwSVdQNzAwMC9Qek13OCt1aWpnTTlmL09JWFVPQ2czelBXREpvcnNBY3dnTHQ4OUtNZkJUNjkrT0tMRzZiMWJTdUZRRWlnSlp5aUVnNkNQWjhSOElCQncwMHBEWEQ4S1RBeFk0TGpoa2N3WGhKQ2tZblk1M0N4RWc4ZW1XSVpMWE1tOXMyTThPMWpQMFVOSXc0YTN6L0dpbUVUa0t1ZzBFOU9UbUswangwNzl0aGpqNUdLeCtqTmVPcjMzMzhmcXdobmFCdW5GWjFabEZTZGFRQWdkVDhlR1FzUHJSMDVjb1NRM1BsQSsyaUVjWHhVdnZmczJZT2ZXRGE0THlNZmFYYWlISUJ1WXhsczJyVEp0SURQdUMvZ25BV1RPTnIwYmRIYkFqbUc5RkIwcGp6NzdMT2tqaUIrMGNsVnR1cnp1N3lqQ1VTZ2JXbEQyTzhvbnhscGNRQjlKRm5SZUg3ZDBXZ2RWMHpTaER4czdGRWE1bGFDUXVkMThpQ3VFbEdlNjlBWWtGb2tyMXZSaGZMeWdFVkVJT1B5SFUvYU9mYm1TY2ludi9IcmozMVF0c3ViQSs5eW5kNHBTZ25seEFTNXg0R2NyQ2FVUWJ0WEpNdEtTTnFHYXZtRVNWYTNXWXJRZzF3b21lYThxeVRkT1pJeGx4cCtaQ1lhU0tRa2xNNHM1NzVKU2UwblNtMml4RDVNVm9oVEVSV3FIbjV2QUpNRDBYaWlWcEEyUThpUWJsOU5rdUlyL3NMQzdJdlBQUHZMNTE5Ni9mS2xpNDNtdjM3dlIvL243L3lQMy9yWXI5VjZCM0YzWWZjbDExSG5nWU9zMER1WU5Ccm9tYWl2c1k2TXdyWUZUVDJKTk9UUWhpUmllYTd0T1Zta1RuSkhxSVhTNWtxNG41alFXMDJaNDR4dXJVeUQ2WlE2U20wcTJGZENPNkxUQlZlSkV1RjdXUEwxbnZyaGU0NzI5Zlhmb3AvWXBIelhzN3drTHhLUStwNVZyZFZyWGlWb05lTklXWTBjVFhtU3VFOWJuQXVhdVVnYkQ3RC80c1gzMVlEbWErVXFocTFXTERlQWdDQ09BTWQyaTBoUU5MSFVhRVZ4ckNKQnptSnRHMU9QWmNyMm1wd1M4NmVzYS9CdnMvVFM3a3FQSmpRd0EvTkpjUmdNNEVGL0xiN3ltNy81bTMvMFIzOUVNejROL3RobnNZLy80QWMvK043M3ZvZXB4TDdKZURIcWpxYk9TamtZbnJjd3BkTVpRZllQLy9BUEFKVVBXdEdIdG1pZys5MTMzNDF0RjUwa2t6L2FKTGNnNUpKMzNua0hvc1pkZDkyRnp1TWFZRDkreFllZE8zY0NqWjU3N2pub2ViZDBPYTk1YThKekdXdWRYREoxNkFKbnBoeXR4UHhKN1ovMWJCaVh6cks4bEQvb1dqYVVSSVlmMENxSVkvRVZiTWlHdks5czdUZGFPKzkreXh3LzQ2VEFqY2djd0htbnBFSUp4dEtxTHVQajQweUpIQm9hd29mcjE2OVBUVTJWZmR0NHJuZmZmWmRoL0t4RWJJd2lwTkRoNC9PdnpGQWdDZlNuUC8zcERsUytKZnRpQ3BrSitBM3hqbElPSnBGc2ZlZk9uWHZ6elRmcHh6RVZodkFuQUR6a0ZRdzFTd1NOam82aUErZ2tKUklqVW5CSXNSaXdWTkFhblFoby8vVHAwNGJ4MTFCZlU4emlJNVFyVkpVNWd6ZVkzNi9SZHpsbmFaeFhJY3M1OEtrV0Y1cjZDcG01eVd2S0ZSMW5oZVM5U0VwWHhjbk9Ld0psUnN2T0tkQllNYTZ3emN0NnNjbUFDOFgyelBtTFQvMzhoWTkvNU5HTmxiaDJKTDArelN2NE9Bci9aTFczODBJRUsxT2I4LzVtZVlhRGtCdERENDAyRU9wZkRJZ1M4U3JMWGlRU2tsaFFZb1UrOUNzV2xJcnN0SkpGY2VwSUlxQlE3b3RmSkdXUjNWUzAyRmljRGhJektMNW82VmNjV2tuc0p2SDFTNWRuVW1mTDJJaS9GTVF0U1NDMFhNdHJKRjZ0am5GNjU4M2psOTg1Yys4ZDIvWk9UNzY3dVBDZng5LysrZFBQM0w5L3grYmR2bGZ0ZzhnZVp2YnRoSjA1b3lQQmxZdXVaQXM0VXRzZVBhdFhzMlpveThhcXMrVzVsaTVDa2V5VW5pOVRJVkhBM293R3hqQU1HVHlSSlRsRlZNcElpbFNYbE9RM3RwVG16K1B1WW9tWElweWUzcng3Mzc3YjBYM0NJRVFUUGZWS3N4VkZ3aUJrUWMwUEV6R2lKSkljR2FzR1QrM2NsUnlQTkhic25JUkhlYno3R28ybHpLa0M2ajBxVWtLYjdGdGhsT1hGL2RRaHB6d0VBUDc1eFdWdXNSb1NhT2Y4a0JrVFNhd2l0bFg5KzJrNTJTK3o3Qzc4M3hTZ2pxWHo5dHR2czd3S3FkME5TYXFwZFZhMmNITDd3eGFKYmJTdHdYdnZ2ZmNUbi9qRUUwODg4Y2QvL01may9LZWxtcUZ0cHFxdkFSVmlsUkVSNkJTL2N1WEtqMzcwbzRNSEQ2NVh4SDA5alJDYk8xQ0U1WG5RRklDS3ZvbnA2ZWtISG5nQVNqYUVHN1NQVHVJeVhNRHJTYTJ6ZS9kdWdFVHRnOWNwTmNOU3RyU2JJRElUNWNCcmlIbm9DZjMwTks0UW16SHNOSkFZTFo4UVlrYkdTRTdBU09yNlBBeS9UVG1zcjV5Z2Y1dXFQNlVOSStGUkx1VHNjL293WExnWEJoTndTTnBndyt0SG03bWxYTCt2dmZZYTlIaEwrUUR3RllpQWpIakF0T0o2a3hSSEJqMUlXbnYzN3NXWlgvLzFYNytkVHJJR0lHWVczYU1QSHUyalY5RGo3N2pqRHBZWlpCNnBTYjdBTGNxTWpSaTZYYnQyL2V1Ly9pdTlBelJDbUlLSG1CRjAzdGdraU9VUUZLeWk0QzlyVzlEZFVJN21NNlVDS1o5QjV1Z1FPOUs1aGk5MW1hd2dXVGRHYzRvRldWN1ZUWTJhTGxWLzNkY2NLYWxTd1QrNXVxOEJtOHhGQU15cEVsdVkvOVgrem1MMk9TdGF6anFyYldhYTI2MGlBOVROaXUrZlBudnVsZGZmdlArZXd4dUt1TThOQzVJeW5wYTlaUG1EWnRxVlBHVXRyeVFncVgwZXlRWERRQmhlTjNCVFZSNmhHUS8wK2t1dEJZbGxUOUlXWURvRU50a01LTFFsd2czUW1FQWFTUUI3a3NRZlN3UzlxN1lQMVNzVEJoeUkxd0Q2YytnNUZlQ1d1ekMvK01ZYlR6My95cTZISDdydjBGMStKdHVaNHpraGFRRGljTkJLdGs2UERVK1BWMjFyWXViS3NCVk1EdlZsRW1VbnRRWGpNRzRrNFZCeTYrZHloMGZ0U2sxQ05RQ29rZElIMHNHdlpXNEYyb0QzMkZYOW1sQU1wbXJ4Sit3RkxYVFhKaEZiSkVDK29wV29NY1JTSlYydVRUVEZYOXp2SWk5S0pvTE11eE8xbWdjUDNqVjFHMlNyK0VLczFZUUhmQzhJWS94YjlaMDRDc2t0VXF0NEtzZEpOVjRoVjRKUTRQakNKSnpGUmNDSE5UUTRkUDM2TlVmTldjVVR5R01tbm5wYmtzanlxbG9uVUpBY3U5ejgwbks5WHBXVjcyaWNZYUkwY3liSFR4N1YxV0QvSkNzSS83TnVoUDlhMkk4OUdxQ0lyWm1oMThaV1g0NWdiN01lZDFCcm9OdDk2VXRmZ2tiNDFhOStsV3FyeVJ3ek5kQ01abW5VWmNJTUtkQ3htei81NUpOZi92S1hKeVkrQUxNSVk4NmgrZ05FNlhPRk5nK0FPWGJzMko0OWUvYnYzNC9YODZHSEhtSTFlbWlyRnk5ZVJCOE9IVG9FWU1BSVhMNThtY3lERy9ScGxuemtadlFZejI5NDR3MzJBTDF3UitPcXg1VkhqeDZkbkp3cyt3NU04Q0Fra3JObnoxSXZ4OFYwT1J2UEN5bjVqSlJRRHV4dks5SjRtOGhxQ0FtTTZrek1vNWpDK29lUW4yWm1abGdvbVNueVpqRkF3OGFBMC9hT1JqRGdSNDRjSVhuRDk3Ly8vUk1uVHJBa2dmR3Y0L3kyYmRzd0k3Zko4c1FJdTdmZWV1dTk5OTdEeUdDWnZmSEdHNXMyYmNLRTNubm5uWmh4YVArQTZ1WGxaV3Jra08zdXYvOSs5TUdFS3VPbUVBUXhDNUFTU09kTUV6MlJIcGlOOWNPUlp6QWdMUk1tN0pIQVg0N3hOSll0VThUQkpFZHNTTzlua3BYV1JhV3FWcENVT1htTk8yVytjWFgzMXhodk8rYzB6ZXdEKy9ZODlNQlJkRHN2MlFveGMySGh5dFhyRjk2L2RPUDZiS3B4Z25tUitTS2ducnFZcFZYUEMyb2R0Umtvc3cxcnMwTG5QSEh5M1QyNzdoZ2FHUGpnL3JEQ3NwOXFrYUJjOXlyS3MrZkpCL1FJaUlOZnlPU1Z6dGpLTStPQzdJUG4zVktJb1ZRVXhBbERDTEdyTlJPeU9TaDVIWkFTMmljQTBoZFNmQ3NTbUpHQVBJNU5KaUg5anJESjIxRm1GYUozblBuS25PUTVtelpQSHR3NWRleVZsOE9vOWVpOTkydkJ5RlNsbHNTdlZEZmZ1V2RzKzdSZDY4bXFsWkZtYStmZTdXNjEwanN4R1R0V3RMUThkL1Y2cGQ0bk5FeTMzS0JyTldlZ1A1NmRsWks0RkpaWUIxQnExVmdGT1RQQVVmSjlNOCt4b0RpcmtUMXBCVmtVRVB1eHJlSmZDb29NN2l1eU8wUmVsTkovTmxQNlZOREI2clNWSE5EMURoMjVlL1EycktEQ0RFR1RreTNoakV5cUUrWStpYUJFWDhXV2tJcWdVM1drWkpKWHFWWURTOElualRjSG1GSHI2V3VGZ1pQbmdqZzVGWVJRRnVYWXdIaFVjZFk0N25JUVpLSWVpZmxEWTJIdE5BOTB6YmU3Z3FXRWVTNTBtOG56ZFhQODJuelYyQzVmZlBGRmJKZXN1ZEpXMEsrTjZ0OEVzblcySkVQMWh5Yjk5dHR2bTh1TUFjQzBhWHlsWnZka1RScnN0dGkrTDF5NDhJR3dIekNQNjRHcGFBRnJDUTNpeklNUFBnZ043MmMvKzltSFB2UWhBQU5PTWpVTDZpbWVldCsrZmRBZ3o1OC9qNU5BQXRaMDJaamVYNloxTS9JTjRka3d6MWdGNnhGdlJMWi9maGNkSGxoblg2WHRoRm9wdlFObDREZkJmZVhTTzZ2cGhtNGYrK21ZTUNwczJXWkRTa2Q2WjVpNy8vcnJyMk1NeVpUSDI1R29CK0lVeG5OMGRQVHh4eDkvK09HSEFhZzRBM1VjWTg1QmdBUUFXWk5SZUxnU1dqc044cmNUNndlaGpkVVhxVnVqVjJnRUdJL1BXN2R1UFhqd0lQN0tMUC9wNmVuNzljQXNseDBLdU4wWHZ2Q0ZiM3pqRzdncEN4L1FsVUR1QWE1L1U4V0EzbjFUdDdkYzVwZ09mc3FMRkIzS2E2QkRZbFJIdlQvM3VKdEtPNDVkY08ybmppRTAwVHdzT3BhWURhZ01iWklXb3YrYTFxWTNUUjdZdXdkUDljcnJiN3o4cStNSlk5WXkya2xKSEVDemIwYWVQMU1iTGZjV0tGcEFRRzhHd2NtMzMzM3d2bnMrcUFKdTU1Wmx6MTV4UVJUUi9GYWVjSkNYN1pYTU9xMldsM2RFUXhtRXhTTDU0SnVha3RLTCtHSXZMaTJIaVFUZkEvdGJjZEtNNHFBVlFEVFMzRGtSMXB5S1lIbVdSWUpUVW0xR1ZKOU13VVovYWwyQU5OWllPa25yYytzOTF1aHduKzhkblJpWnZuZ0ZVdFc4bmZTTWpOaXRaVTlzQm9EU3BEWTY1ZzBPQjdIU0FmblZ3YjQrVjdrQWwrWVhHd3RMMFA5N053M2F0K0dLRTBxQndhRmtmZzVJckFxdWx1RHhkTmExd3EvMFVwSUFOSHM5eGhRbVpHeVNMYmJSY3VyeVVrbGRnRFNEd20wNUhHbUpnOGpTbGRsUTVnTFBrZUxGZUU2SkU0M0RBQUwrblVLQzV0MkdxQ1hiVHlwQ0VsYVhCSmFRVnluT2tsNHRrR0NuVEV1UjZaQncwditQdmZjQWtPU3F6b1h2cmRCcGNwN1puYzA1YVNXdEZta1ZrU1VFc2dTeUFRdVFudkV2R2ZNSUJteUR3UTlzSTJPLzl3dzJTVFpnTUVtMkgxZ2lXa2JZTWxISktFc3JhWE5Pczd1VFUrZXF1djg1OTFUVjlNek9kRmYzcmtDN09oL0xxS2VudTZwdTFiMG4zWE8rWTlpbWt4ZUZuTDRJRklzeEhjM0xEZzNpUkVRanh0VWRudERnd2JwL1hZS3BFMXJnempuU3RNRUFtTXhrOVYwZ0tnYlA3K0NuOHgrcGM3UmYrSS9KZjVSRUlJS0cxUXhmOFlOWUFCY0toSEpwZlZxb3NNbDdDN2wrdzZvLzJyOHZjMlR3NUVEeWdoZElLVmVrUzhnVG9zaDJXRmhGZ3BXQ3ErUld3b2RKZkZmVjFnL21Lc2g5c0dEQ3VDc0Fqa0IwZnZBYVhIL1FvOFNyRDBNQVh4QkU1WjQ5ZXloMkRXcURIT3ZhMDVrREk2YVVjSmZDeVBRblV1R2tPVWpsd00ybkxJY3lOelBzUmtPNmhMTFF5UUlJbjB0NERhSFRYNFBpRjBHbEg1WG1oNXM3VkFOQ3hYdmcwNjljdVJMVzZlRGdJRndWYmQ2WGRxd0hGLytXVzI0Qlh4eXNOekJvUU9tQ1RxV2JBRW9hakxQZTNsNXFCVW1wbzMxOWZYQzZxNjY2S3VJVlVnNEJlZWZFTmtpeElyQTU0SkxBMUlBTFdMWnNHWXdDSHVpVlYxNUptejRVbnlnMWNjQW8vTWxQZmtJMUZGU3JBcGRITTVPZUVkRXdVS2VBOEc3VEJqL05WZEwzZEVtVUVrRTJFNXdScGlLOENWZFNrOTlQL1dCOEtVYjlZZnpzdUpETWgyTGEray9TbStMOFYzTnRqY05VdS9RVkY3bU85OFRXNTNYdEFEVUY4bVRnOStNT2ZKZ1lKV1ZRTHkxSmloSWp6TkhqL1JjNmptMVpWV3AvUHdVTGs5Vjkrc0dBbjVBUys0T2tMMFVpbWhMU0FxcDh0NWl1Z1hQREpkcEQ2UlVjdE54eW1PbUhybUcyVU13VzNCdzRISlpwMkhHTW5pQmZ2aEw1SWl4QldHRk9vYWlaRDNEVzIvUG55N29taWJhSWJnV2pyOHJUNnFzd05qYXhmNjhWVDNRMnQ3V0JWMjNhaGJyNldDcHBGTEpLVStZNFdkRDcwakZSZHdsRkJZQ2dESXZGYkQ1UlY1K29TOFVhNnlQNm9HWlRpeWYyZ1J1T2xQaWFYVkM2RGx5cTV4TWxLUW9PK2UyY3NSVFEwdmwyd2tsbnJMWTJuWXVWSThXSUFqY0lzMUF2UDlwUjBqMFBYU3h1eEtJRzNFYlA1ekxMMTEyd0tHS3h0ZWZxN2tZUzFwSG1IaExZTnNtVXVYd2hCdElLLzIvcXJRb2luOURoUHNkVFRyYjBEc0NhR1JnZW9RWlBaSEpSaSszQVdkZWZOR3hwWXY2SG9Ua3dITThQSXBITUM3aU5nc3dZaW9ocGJ1aVM1bFdNS1pEM0JnSTZGRzJrdWtoUlVjaWFkcGZEQ3Fod3Y3K2lZVUhXUStnd2xlYWlVOWlmYkF0Nk0veVZQajh3TUZCVm1qb2NaUG55NVNDeUtWcEw0V3NZQmJoOW9BYjI3dDI3YytkT3VuN1FRRXVYTGdYTkJGb0hCRFM4Z1BPQzZBY2xVUU92WDJrbFBlMzdoaXo2WWNvazdmcVQyaVpLSEJveWRUMFFaYW4zd3VLSTBNc1BkeEJtbEJUT2lQRDczTmhCdG1aRWxCWVEwbkNJWWdpODdkYlcxaU5Iam9CZUo4b0JjTFVwZ0UrS0grNHEzRUQ0SkJnSGNNT2ZldXFwSFR0Mi9QQ0hQNFJQdnVVdGJ3R24vOUZISHdXTis1clh2T1puUC92WmozNzBJd3EyVStGY2RFWUh1Qmg0eEtEbTZldGtCdEdFT1hueTVMUFBQcnQrL1hxaTJWbTRjQ0c4QUxzV1RuMHFWVERZcHBTZFNyWVhoVlhDblA4d2lrTUJqekE2RlZKWmg3T1gzZ3d6SmVHTU1IYTRGVERxTXMySUsrVDZVYUlka1pVWk9qRmZlM2llbi9BZjJIUFVza2VYUUlWMGdPV3dhZVA2SGJ2M1ovSVppaXZnNW9MeVNYYWtxL2xpZFhJY1ZvRVI1dzdWQS9pbWdadk9aQVlIaDN1Nk82dlUvUmlRTUlMQVBoVXFoRXpDL242R1MyUzB5dWRwVVpvTkY2dnE4OFY4dG9hWVAwYWVUZlNyODhpaUkxeWsxY0ZtUEZtbk9BRUdJN0Vjb283R2tuTGhGTEVtWGhTMVJ2R3JJN0hxdmFNYmZIZDh0S2NjUHhPTER4L1lreXQ2dVlLS0pldmphRFRrUFFORVpFeDczOXJSalZsVWtDZHR6Q1JRam9zY3Q0a0VXQXpZVWRpS21qaHAxeldBYlBPS2pobUw2M3hERjU2UWc2bnlrdkx5SmRINjQwNkpuN2NCcDRTcmNIV3FQM2JRemVWMGdZZW1HL2FwbHZ6RVVaMDVyM2ZLZGIyb2psTjRjT2NjVjYxYXU3YTdOMUpuVmQwdnlzcm1YUXlEdVo1bEczRWJRd3R3ZjVJT1pweklSRXd6S2NKYWpXRm5aQjNEQ0xrY0NEb25LSmJORnhUMXJLS21GUjRWZzNwKzR5a3M2WThKcjRCOURYUkNxcGFPeUlDQXZORlNXMXJDVDZMMGExaWtwRmxlOGg3RFYxVGdlSUdNcHBweWtHS1VtVVY1Y01RelE2S1FzdEREcER4d2hzcFgvVkJKR3dsb1VvR2tTMEkxR1hybklaMHFlV1pFZlVPbDFlR1djOFN4d09rbzRZdUtGOGdiZzZ2dDFnQkJUOXUzTUVZaXc2Y2hIenAwQ0l3QU9HbEltMU90N2k4bHp3bjlmdExacE85SllZUXFPVXlwSTJLNzBJK2N5NmFoZ25nNlZIajhVcFRhQWFHbFZXcElSUjhPTVRpRkJIOWhYU0k5VTFDb1lDa1NBUitOb3IrL24zYkI0WFF3bDBEUmd2NERnM0xQbmoyUFAvNDQyUTNVdFE5c3JFMmJOc0hQODg0N0R5d0QwTXFnSGVIZ1lFTkVKM09rMkFZbE9SSmxNbHdia1FmQTh6MTQ4Q0E4UjVpM01IbkEyZ016QlF5QzN0NWVPT01NQTZpbnAyZnQyclgzM1hjZmZKZWlYelJuUW43cmtIYUN0anpDaWsxUytUUXRRMU1ZYmhxTWl6eCtzQ1poQlJHTGM0MStQMGsrdjErZjB1WE5oaCtZUnorZFVwbTFjS1JldGZqNGxhcW8vRk4xcWFhbStzbmphY3YwRStIRFRDalBWNWkwelMrQzZpamFmVkJVb3crM1lYaDB2RnJkci8xOEZWb3Jzb1RiSitoTlFPSmQrNjlCd1IzWkNBcjd2eGFVVjczRVJqL0R0T0YvZ2piVmNCWWorWXpyak9heXVhS0R2V3FMUldtN211N1BFSEdmekU4aWpZeW5yUlVUMCtiblRqc3hkZGZhbUJTZ1lvdnhKSGdaQWluckRSVVF6Rm53QVJzK1l0RklSRnozWGNhSXZTMklOamppL2JOalpuMXpZZUFFdUdQYVp0TTloVDJ0eG5HeUdrUkNESW9QdTlYb2FlQy9YY3hwYTluQmVqOGRGekI4SWx5ZE5Hb2dlei9XQjVqWVlnOHVydWc2T2FlZ0o0U1hTQ1pYcjErZlRLYWlaWTM1dVRCV0RJY0dwZ1BZNUtqRmxRallOaEx4V055eVkvRzZsSm1JQ3hQY2Q4M1dWN29rREtPeG9TR2RIVEQwRmdFVnFhSWQ2dW9BR0lnL3JIVDBreFZLRzF3cXZ4T0VUL3lMQVJxZlNGTGZFTm9DVUVFZkNkYitKWmxUSUNYQjFRTTVTRjNoUWNlRDEwSzZuNUxScUs4UDBjV0hvVTRRN3VYVDRzQXpnMFVIbXBnSWZPRHpSTDFDSEhDbDJxaVVTeFVtSklWd2lUNjlxbmcxSElUY1FlcWFRMFh6Y00ya3dFTGVXYUo5aFUrR25FWGdSMUoyVzIySmZxV2t5R0VqK1ZMMVhGcDJYMXFHRjhZTXdzL01wZTFDMXAwd3hoQVdTZExQR1djLzlmS3FTdmNqblJycU9Ub3NxTGVob1NGNG9GdTNiaVVGRDdjUlhvT3FBK1VORGpjb3Y0Y2VldWcvLy9NL1Y2MWF0WHYzN3YzNzk0dUFNd0M4ZkhoOXd3MDN3TlFpZmtENE1LaHFDaXhkZmZYVjFkNTVlTDcwbFZCbms0RkNTUW1VcUU5OGduQi9qaHc1MHRiV2R0RkZGNVZ1K2NQMVgzbmxsZC8vL3ZlSnN6SWtuNkRtRkxTYlVKckVGOFpDS0NSRzk1OHVnMllPNkh0aWNLSjRENlVPMUtMN0ZWVW0wYTRZaVRQVEQrNEd2VWxRSS91OThXUklsaHNwZ295TjBJWHl3d1dZVmFlN3pCbDBZUDJQR3J2NzdDaktKd0xRKzdVdytrdytVN1hpMTNFSm91bzNUTHBrdi9rYUJUSDhZamZwTXhYNUhWa05ZdU5GWW55dkpudTh6cllNTjZmTCtpVFlwY1JxVUNnNnc5azg3bE1WSEdydnEvZUN3WlgyZk9KQkUvbDJSUkRrTDNNQ0N5WlRmZEtPV2NWQ1VlbFdBYlNqcnh6aDVBdVlxdUNhb0YzcFprb3FVWWY3b0Z2cEtEKy9MdXBZN0tiVzlOSERGbGdZY0VEdDNXTU9CQmI4MFVUQzFIZVhFdHgwQ0VBSGI0UXFaREZqMFMxNitheCtsaDVWSEZQZlhqMjNCRkVkNnptQWxMdTVYQUZ6U0F2NWpwNmVaWlZhYTVSNFhRTDcvbnJFb0VEN3hOTEMyK0VhZmpkcHozL0hUbGgyU3BweFJYczcwNC9UMXRKNmNuRFlrNTRaNUtRU0U1SGVkY0djUk4yUlNlaW1ScTdPQjVRK3BZL081WE9sMzdDQ1V2NzBuZ2hhU1RySlVSS2pnRlFjK0ovS25BSzlQbDhEdER1NHY1UitSYnFmWEhEYUNLQjZkUGdUdk4vYTJncHVOUHdzczQvd2xhOThCYVF3ZUQvZ1Y4RVRCRDFCUkhYRTR4dnVYcGYybTZHNnFaQUdBTlJEeE1MME1OSnc0c1FKS3AwbkJsOXFkVU9KZFVRSUE0WU9ESWQ2NDFLd0d0NkJhNkRjUUlwZzF5Qm53clM0VXU2ZHNKeUJuRlFLYk16b1ZCdnUxcGV4Y2tJYkl2VHNTY21WL3FrMFBWT1VaUGlYVnZsWHBWbmg3b1VuQlNWTlJ5QlBIZTR0MllqRW9nL0hCK1g2eFM5K0VUNEFqdjRERHp6dzlOTlB3MDJHNlVTcG8vQmQwb0pnS0d6ZXZCbThjSERIRHgwNlJQeTQ4UE9LSzY2b2lvQUlIaE54TTVOcFF0T1lBZ0NrZCtscTRUb3BnUU0rREVNSUd5dUhXTDkrL1pJbFN3NGVQRWhUamd4RW1wemh6aGROUlFvRGhHMkxROVkvNGlraWF3d3NTSW9mZ0dFRTk0ZjZROWFrK3dPS2UxK1FHVDQvRDVYbWUzNFZ2cDhpUFVXS0syVkY3WThiM3RsY29IZTlJQ21GMnJ2NExQdCtWajZGUjNXaE9IMVJoLzJ4TzA2MXk4UFBkRVVQWEJPNzBHYURRZjBGUWN3SE8vMkdINElHNXhsTUhZeUs0eTl1THA5MWEraXZCUjZHSlV4UEZIVXZuN3l1ZlFQdG5IZTk0WFFhdy82dWd4WC9jRmN0M2ZzQXpEcGRLRXNsYzhKUWJsbURnMm90SkdwaUZUTjFPQWpMNHl6RDFFRm56L0owd1lMVUJmZFlMV2hTeGFKbVU5WnBEa2IwUVVrWmIyNlZodVZpcXJ4VzRraFBhT3JiNXBCZFFRek9jSGhESjI1bzEwQnJ2bndXdVg1aDZrdS9iNktpbm9BeU1CWXhpbVFvbjAxSzVWR0hLOHR4Rmk5YnRtakpzaW95T2pITkFPK0RROFdaV3RuR2JYRHk3Ymh1emVkZ1RvQzBTV1RwQnNIR0tkWlBBd3JyUkNhWDh5a3NpQXNLaS9oZG41NWZGeDlwZG10S2RpVkgzdCtYb2s3Vm1wYUN1bUI1ZXViNE5JMnoyQm92YjREQW9xWXM4T0w0OGVQRXowcVNtdVJkNlB6UnJpZFZRd0hnbmVYTGw4OTZ6T2VlZSs2em4vM3NmZmZkQitxQkVxa2FOSWhTRnd5Q2t5ZFB3b2tvQmxCS1BoTXl3QkROUUxVY08rVC9VZTQzYUNPUzlmQU9xQXB3K3lpMEhqcHdGTzJIdnhJakVBVitvM0RMekhyZVVrYS8wbTU0SXVnMkd4YktoMm8rckQ2ZnNXVXdsL3dNejFKcUNvVHgvekFZSUtaWDlwZDI1WWtPZXI1MDJSUkxCeVZIeGhQOGhPY0NPaDd1R054bk1PbkEzb0xiQzdiZ2swOCtTZTF4NGFIRExZVTdUSDBjYU44SDN0eXpaODlQZi9wVGVMMXQyemI0SXBnUjhIUEJnZ1VoMjI3MG5FcDR5cFNlUXBvZUhpNU1NR3FDRUJJUlVuOGp5dEl2M1hNSnNXelpzb3N1dW1qbnpwM1VaUUNPVFB0Qk1EbXBielZ0NUhzQndzeEgrakExRHFEdG1ERExqd3dSNmxWOTZhV1gxaFR6OTZPWG1yMk5rdmlWM3VYRjlqU0dUc2ttNTltdkpkRVRSQm5VajdXc2xUY3lNalk1TVNtUjEwNkNJNGFIeERONUt2Q2NwTlpkQWVtZkNucTVUZlhmRTFXNlRRYmE4cFltZXJOMXpaWmZ2cVVrcFJCanN5THBLMUpOMmFvcGRFZ3hZTXNYSjF2SVpHdUkrZXY4TDBNSHhjRUFFSmw4UVdqS0lqRHRSdExwb2ZHSmZDRUhxejhKdWptR0gvTm9VeGdwOFhFbjNzUGI2YXF5MDFEWG9Ca21qZzYrcVBVT1JoRjBQZzVvT3hQM1NKUy9qWUlaaFFKWEZOSW1LTk1JbWk1RUhZNlZxcmZiMnJ6c3BGWnh1bGJTMUVuN1lML2dzZXpnWUtaUEN1R25LOXBlTnFkMEhCWFplMEliejVURTYyY0l5MVVGZkNqSUZlZ1YzR0lCcmxtNE1kdFlzWHBOZXlVcTMxS2JFaU1OU2hiUW8xSTJHRU1DN0dYWmFNWlNpWmlsUFNMc25HekZNWG5GS3dvVk0rdzQzS1pUOXc1YUd4dkJ4eFNZbjJjWnRFZUJsb0twb3lmWW1wRUVIazRKckNuUWxZREtvL3BRdjRLUldMRjFXRXRQWWtzbkFmaGJZcXo5UXp6Ly9QTzdkKzhtZlFtQ3VLbXBpWGhqNkZmYVdLVUtMbUpRb1RaMEZOZDU1cGxud0xPaERWMUtkUVlOY2ZqdzRRY2ZmQkMrc21YTEZwRDFvNk9qb096Qk95UVhFQTZ5WXNXS25wNGUrTmpBd0FDMXFDRzVHYkxnMGRGQW5ZQ2hVTlZZYUFPWVBGRXlIWWlPalRaaVNRTlJCVCtKZGZMSVljZ2hvMDdvTXRhMjVSK1dnYzJvc3cvVmRtbHFYcW5XTDMvUzBMTVA5dzVteFBOTHRYdHBrbi9wWDZ0Uy94UXNJY01JVHRmUjBRSE9NVHc3aXFEQVpjQXRoY2NLVmlQY05QQ3FRWG0vNlUxdit0clh2a2FKSTlSWEY1NDQrZEMwaVVDMjE4TVBQd3dtSmlVSHdGbmdJTlJ0SWZxMXdSZnBzY0tEcGpoL1NJVkVjU1BhcTZJTUFPcXFGM2JmT1hYQ3ZPSVZyL2ozZi8vM3NJcVZuaEhaQ3VGam9yeVdjUHMvekhVTmEvMEpsS0ZDbGlWOGh0b04xS0w3U2V0TDNjeU91c3o1VWlza0pkT3pTTzhkKzAzTUpXWTVPUldWeWRZWHRoY0tSU3RHVWhYOEoxZVUwQU9ZRkM4eWlYZEh0OStqS25uVVhObzJOd1E4eCtvV0JraVFlRXpRWGZOakV4U1R0V2hRcGdpcUM5Q3YwKzF3UkJGMHY0MDBkbzZEVlJpNUduSndzR2xFTEpiTFkrRURUSlpNb2FoYnU2SXZQcG5MRGFZbjAva2k2SDYzNkdBa0dhdlRMU1ZOemVlbjFXYXd2T2EwOTNYMmdLUjlDWUhPUGUyTVNGdWJaYVp1Q1NqOWQ5RXFvM1JDbkdLVzB2MFpSTmkxSU1wdHRNeDRlMmY2OElUbUFpWjZQbGZxTEJEc2MrK0xGYVIwRURRckZKVzJ1VzQyclhTUkpHYlgrK3lRd2Y0OEVlMmhJV0ZRMmgyc1NqQ21wWU1SMXhWcjFrY1hoYm9MRDlyR3hONWtHcHB3UnhoMXlWamMxdnZFdW9PeWh4UkFLcTZLMnY2STZ6YURNMjlCYTNQenlmNSt6WXRHWVgzTlpVUkJERitXd1RNMGRiQXFyQkNScnQvLzBkOHl3Z2N0UEZNM3RIUVZkVFlVVTlrbERJM3QyN2ZEYzlpNGNTTXhsb01yQnJjTGZvS0FCaDhPcEI3NGZPUUNnaWtBSHlETlN2dm85OTU3NzkxMzMwMStMZndFbWJ0a3lSTDQ2NkpGaTI2ODhVWXFzQWJGQURxZTJOR3BWcXExdFJYa01yaGM1NTEzSGhnSCsvZnZENnZ5d3R4MU9ENzh0U095M1JtS2N0QWk0SWFTKzU3VldhNjZUWlRmUm8rVUFkVnV3ZnVVY2s5bDRrTG5hVlA4dHJZN1dWcllMUUt5WkxJQXlDWUlmZmRxcVhaRlVDdFJXbDllMmowbzNKTU8zd3dyTEdyWTc2ZGpFaFUvdGFpaEd3aDNDYng1ZUdUcjE2K0hSME9jZlhDM24zNzY2ZVhMbDRNVk9HL2V2SzFidDRhaGpyQjdFK1ZZVUtnY2JqNlltM1NwY0RRNDh1Yk5tNnRpYjZSNlBGSzlsTlpIZVJzMHUwS3VwSkRZbjlMM3dsMlNHUURMbzd1N2U5dTJiYlF6QllPQzQ4Q1VnR3VEVzBwYW43WnNLR21KaUprcEJoYVdRdERHbVJOQUJOVExOWEw2RXNPOXBDQ3RJaVo4NFNKUkdVYi8vZm83N2RnS2Z4ZmQwRHYyS050TXc1eHJBajM1M0FzNzl1ekJMR3Z0c0dKR24yNU5LMm5YVjJjVTByNjhYK2huaFBUK1BzOFFtRmwxZGRXeCttT3VpcVV0YTR0WW9nS3FRdHJjVjVSZlFGUFdweTdVMlhsNEtTNW81bUlPRzhQWE1JUEJaSXVaNEpVVVBHOHlXMFFYM2xTNk5sN0NiMGRISjBjenVmWml2dUFWYlN5WkF4dkl4QzVHbG1hU1FTb2d0L3dwUFUzZDVIY25vbzNuQXFvME0yaVhqUDFxUEIxK1JtSUJCN3Y5b0RrajRja3IvNGxWVVhJR1g0ZzNObzFyd2tNOGk2Wmd3VWVuTjhaMWN5ZEpsUkxDb0oxN25hd0EvNWtZOTRvTzlTd1FmbkRWRXdISEFnYjRzZDJCSll0b2lPUUx4WHpSTlQybnU2ZG5jVFNtTGY5dW95VnF1RWFRS1NLeDNiQm5ZTkdnSFkraDNZK091b3ZkQlZVTVhrZzNyUWtGN0ZPcjdaT0pSREtWbk1oa0xSM1cxMHlGNlBxcmdPTVo5Lzc5alM4ZGJhQWxRSzYrdi9XbE5Na0JHTFlXRVZtWTJtN1FyWThNcnZPYnV0WEpKR1gxZ3djR1FwQ3k5OGw1dXZycXEwR293VHNnNk9IRnlaTW5RWXlDWXdmcW5PSUVSSkpEaXBOQ0FxRG15VnlBbzRIdCtPcFh2eG8rOE5CRER6M3p6RE5rTkdCN3NHUEg0UE9nS3BZdVhRcWVQYndBcStMUW9VUHdrNGhVS1V2cit1dXZMMU1pTmJzODFSb2R2a1UyQ2x3RzBmeFJUbGtZR0NBeVdvcFNVRXlZYXZxcGxMSG1QUC9TeElYU0JNYlM5UDZ3QVU5b0tOREdTc1g5L25EL0pmeHVhYUpBZUpid1hPRnVRbFZGa3FVQVhRajNqV3I2NFhiQjNCZ2RIYVZFdHNPSEQzZDJkbEt5SlB3S05pS28vSFhyMW9IbEJ4K0RlVUpaZU1TU1MxRVd5dCtrMkRqTUUvZ0pFNHpZZHNIenJpcldVbnE3NFBoa1pORHhTZmRUcEFFbUFFd0RvcE9pSnRTelB0a1ZLMWFBbGZuRUUwL0FWMkNldzZTbGVrV0tESlhTV3BBM0h4SXJoVkdjc0hjbDJUcGdCRVJwQTIxRlNaQVRwRnAwanoyREl1WmhSenhUZHpEVkdXVGF2VFFvZ3FxNTZsUkJSemx3YzZMb1RFeE85QThOSHo1eXJHOEFpVk5pY1o5R08waUt3Z05nTnpqbE42cjNKNDBJUWcvK1RNWG9handXYTI1c3FuWnRnTVdBRzdXV2R2S295VnBRdWVYbkUzcTY0NDR1NmRLT2RGeG5JS0QyQlBtalhLK0dHWXdHam9GaGpSeVdHT0g2Y0hSR2dhSERNa2RIUmsrTWpTL3M3aXdXTUFDRmxmMm9CeDJrK0hXOXdJUjN5ckRBNnNRTC95NVI2cm5BdHZPYUNSL3VXYkVvMHBnVWlXVDdlQ2dGVm9XbGFZR3hHUzhvYmEyanErS1pzVkoxY0pOZ0lzc2tDaW1wdSszaDQ2Y05FbUtDTURGMzA5ZUEyS1JZT0JOaldQSUFxMEtLa1BIT2IrbmtEOC9WUVF4OENGbWROUk0zNVlMbHF4Y3RXMWJWWTlhOVdUemRZQWZ0VHlYaHBhN0dRU29EbzFqTTYxaUZvMk1WdG5JTDBvZ0xiNWJ4RzVqdDN6U1d6aWpOVCt5UndhYXZXNWRrVURLTWpxUWdYUVJhUTdwbWtlU2ZnV1lCRGx6cG9rMWQraVY5SGdUZndtU2RId0MwTXF3RjhONUE1SUhmUm1WdnRQTjkvdm5uZzR5ZVAzOCt5VlB3OXVEem9FcXBkdTdCQngvczcrOEhTVGMyTmthdUR6bWcxQS93d0lFRGE5YXNvZWIwR3pac1dMeDQ4Vk5QUFFYdlV4UVVmaDQ5ZWhTK0RpcGswNlpONERXQy9iRnIxeTdRQ3RUZERoVEpOZGRjVThPU3AwNnlsTk9YMTZBV3JyUXZTMW5aWWQwL3VlWWhzeDRGalZWTnN5TThTS2hydy9oL2FBMkVmeTJ0dTR0eXVsT3pBV2IwRFFxakM2SHJyNmFpbHFvMjlVKzZtY29Sd1pLRE8wTzBnL0M0Ky9yNjREWDI2YTZ2cDQyVjdkdTN3NXVkR21SeTBTVlJXSVV1bUtKSFpINlJEUVNmM0xoeFkwOVBUN1VXSGlWT1VzODl1amt3ZjZnSEV1MEkwTTJCczhQcnNCcGkxcHNBYjRLTnUzUG5UcGo4MUVlUkdsR0dCaGJkUXpoT2FLdFJrb0VJS0JyRDNsUzBVUUx6amN5ZDhyRnFxK3hrSWc5Rzc0Y2JRUVduMzNSRk8rYmFRemRKN2V2bWFIN2V2eEM3RHh3NmZLeVA0dW9la3N6cThzU0M0Mkh1R3ppZU1aMUJwUld1SnRpVnVwU2FxTzJEV0w5bVdndFMvc2hPd0YxelR6WFcxN2MwTjFVNWtaREhEVE8zY1ZDbXRHVFFMTTZsS244dHh1R3ZobzcvWTA5YVY5Ty9vYTNodW9WOEFUelIydXh4MTNFTG9QZVZWWEM5UEhqZXVCZXV6UWpsRFUrTW54Z2JCY09va011QmpXY2w0cjZ6N0RnWWs1ZGFJd3F2YkZ4QkwzaWR2bWZxSUJUUjBSQXRybGR3bEtPajNyckZQRTUyK0RVV00xRDBZR2NoSGNPcHpnYzFZL0ZFYzB2NjVGSFRpeW1kTStCUlQxdGlQeGJhN05EeGJSM08wVVdTTU41Q0FYMWt3eExLb2MxK1JicGYrbDBka0lZUXN4eXdUMUJPMXozQ1UxNitibDBpbnFqcWJ1c3RLQ3did2FKR25XdGgyQkpNWXZEaWtZVklhTy9FY3kzTHNKRlNTVnBHUW5lbG1PWEp0alExSFI4YzBkT1JwaVptTUVwUHR5ZldYWlZNbUR5WVVxQmJHR09odnc1YWVaajhyM1FpZ0M1TWRmWE13djBZdldYbCtzUUhIaXQ5SDZDUFNiU0JVQU9GRGRPQUpCY0FmZ1Y1MnRiV1JpSis3ZHExOUZkNEFRb0FwRFk4bTRNSER6NzY2S05FVWh0Mi82TkE2M1BQUFFjSEI3L3FxcXV1V3Jac0dRV1FRYnRUL1JVeHdWSFQxUVVMRnNESGVudDd3UkFCQ3dDdTVPMXZmL3V5cXV4T0RXckNSbklmbEJORmhxbEFEZ0JYU0I0L2tSU0Z3WG1xTENDbFVuSHJmYTVvZjZraW54SGVuNUhZUCtPVE03NDcxL0ZMR3grSEVZV3dwMTlwbW1UcG9Xclk2Uys5bVhDandJU2lrQVB0L2NPaFFFY2VPblFJbkh0cTZnUHVOZHhubUFQd2xVc3Z2WlJtU0ZnSFR3a0JGQzBnU3d0K0VxVVM1Y1BEWElMWlZkV0ZFUXNUMkEwdExTMWtSc0Rwd09halNVWFpKM0RaUkZCTnFha2h0LytzQjRUNU9hQ3hXNE9pUkJUdEQvc2EwS3lHRTFGQlFkaFltWFlCd2pBTW1jVXdDZUZYNmxaY2krNUhwVUpHb3FtYm50TEdzTEtJZngvVHBnUTVmSmJ1dWhKa0tSaTZIN3RTMlZ4ZWh3WDhySGtRdzdGRWpMU3czanIxYy9jdHZ6SlFFVG1RSm94VEpwR25CdEZUdzZjU3hQOWFsdWpxYUkvSDdPcDBzTzYxcG12UVRGMjBSY2NGY1cxcUJuYWR2Q2pOb0hRUjgrYTBNYUszbzNXbW5GTkxHejg5SWd0TCs1Um5ndVVEZWdBOGNGMHNpSW9oazg4ZlBEazRsczYyTkt0OHNRRG1uQUJ2MTlBZERkeUNFWFpRS2h2bU5ySDNYY0NPaTcraXBhWjB5Uno0MmVqblV6NGQzSFd3UW5MNTRrVE95em5ZaGdlRDhPRFFXbFhsTUJxbWxXanJtRGgrMk1YVUFiaURwa2NTUVlaNTdMVE5yY3NJTVI4RW05bGc4b0xuVXFtQnA5TVVkQWhIWDdPcFdZaW9vdEtUeFh4eExBT2VmM2IrL0o0bEs5ZFVmY054OHBrVU9GSmE1dHBvOXlmc2VGeXF2S0wreUpxQUJ5N1JzaHVVR1pkMmJOYklSeW9SYjZoTGprK2s4VjVoalNEMW9EYUMvRWdZVlZGU2tyL2ZFUm9ua21ZRDlMMS9haDBWekc1VjBpSEk0MXovVWhGUHZEMFVqeVVwVHk0c2lEa2lVS1BNS2ZDTjRBTWc3dUVESUdvdnVlU1NjR01WcERrb2czMzc5b1hkLzBoV2duQUhDd0IrTGxxMHFLT2o0NVpiYmdGZi96dmYrVTdJSHd4cUE5d3NhbUxiMnRvS0ZnWWM1OXBycjczMTFsdHJHRXVvWm1ndm1RUTN5V1hhYkthY1BoSDB3QTN6N0VoWGxYTHZWK3RqbEViMVM3dm5rY0tiWVNLVU1zUFRpOUxpd0ZsMVArbWJjSGMvUEFqNSttRnpoTktlQXVHT1E5aGJxTnBCVVM0ZVVlZkNvd2RkUzVWMThJSjIwK0Zod1J5ZzJucjR3Rk5QUFZYS2MwZEpmL0JYK0REWlpGUk9TVWNtVHhvc3lHcHJLK0JjWUkvMjlQU0FoMDJuQzdWdjJEcVBVdTdEL0UzcVN6bVg3cWV1eE1RL0dCWUZ3S0hDN0JNS00xQUFxWlF1S1dSa29ndWc5RUFLa3NHZllDcVc2VkJRVHZmYmNWc245T3RpZkJuU1FlZ21yV0txekVOSGZQWGVneVJaVDlxZm5Ibmg3eFVFRjZnVDBYd1dIYVN4cHg1QXdpZEMxVllCelZRTXc2UGg0UGRBTWJUUXhia0ZodFRDM25uVlR5UHFNNmpDeElHd3Q3RHllOGxRQWdQNmRzcjFEQkxkeWljbmRsMG5qNTVyTFg0L2t0STdJbHRFNHlIczVVYTdKdURqSGhnY1BENDZ1cUM3QzF3U0N3ekdlSXcwSTI0Vmd5ZFBwbUtaMHlyZGFxaFF4RFJHbmFWZ1dnWW9kYlF4WFozdXJ6ZGZzRi9RUkNZL01vSHg2bndSRXd2MDNnWk1zZVRDUXV2RnJsbk5rR0lOalhDcUlqaHFkaHhUKzAyVE9HeW9aaEQzU1dobjM5VVdGZlZKZ0VkdG1sT05JWVVmVWRLVHdDWEJwWmtHVkM2Ym5aaEl4NlRYczZCMzRZcVYxV1pYWVBtOEFLZmN0UFZzc1MyckxwR3dVZmZIREdFVmlobDlMOUVTTVEzazlsRzJLVUQzenhHTGEybW9IeG1mOEkxQ1AvVkNSMkkwTllIUXhRSm9LUXJUb3VFcmVnNStPRlViQ3g3dHlGREZqQy8ycWRDRW9VR2FQcVNZSlMxSVhQMGtPZ253QWZDSDRLLzc5KzhISFQ5Ly92ekxMcnVNS3ZkdXZ2bG0rT3NERHp3QU9uNU1nL0tmd3c1K08zYnNBTHRodzRZTm9EUGdPU3hac3FTcnErdmd3WU9nVitqZ0lGVi84WXRmd0Y5WHJWcjExcmUrOVozdmZPZXByWUVqNnY2UURpaFVDZUd1Y05pV0ppVEFJY1VjSm9xWEo5V1BxUDdWZElqWlV1N0pSQkRUV3lXVjhjN0pkaW5WMzZIS0NidnRoUjUvNmFaRHFQVnJjLzNCZmlKR1F0Qm44RmpCM2FkVTl0N2VYbmltRlBNSERiZDM3MTQ2QzVtSnhNcEE2b25DNEdCQmttcWtUZmVRTUgveDRzVXJWNjZzOXFyZ1hNdVdMYnZnZ2d2Z3ZOdTNiNmRqVXBTZUpuQVllNkJPdmhUNEtYK0hZVDRUQVFEZHlUREpuMjRnN1FRUk53TVpHZFRnaDFaTktRTVN2VThCcDlBZ3ExNzNJME1jS1g2dHlxblkzcUR0YXAyWXAyTUJCcXAvRzZVL1JRS0VUeHZuSzFrLzRWc1QvcFBqVEpORFMzOHpwRk9seUxCMmgzVmhlamd2QmRWOSs3Tk5xZDZlcnJhVzVxcGpZdVRaNmI1OGxCZW5WYXpuRjJRVGhZdEIxZGU2TFl2cllEeEFiMEREdnlMNHkwNnhodTZyT2hKdWdpcktPZURRT3Vnb0UxMWZjSGRPam80ZE9EbTRZY2xpTzVWd1BHclRxeE1SWEIwOWR3dENSMS9Lak15REN3TkxFS3NZaEpmSk8yTVQrZEh4WXNGQm5UK1pCN05BaDB4a2NTeU5BZnFZTGJKNTFMNUpTOEppQnV0NGJGeTUxWm5rWml3aGJiczRPVUp0RVpSdEVXTXljaEhvYlI4L2tLK0lIbG16RStJZUEvWDE5ZndDUHhWUVIyaWZXaTlkcEYzSVpQTmpreE9wUktKMzJhcXU3dTdxbnJMZUczSW9neE9aKzdINVU4eEt4T3ZxNHZVTjBuV3ltZkdpVXpCeWVXM0t1dEswelZpOUlZMjVoR2xUWTBOaWNFVHpjWGgrTCt1QWYxZ0xPQk43TFhwRkxGUFZDOXRVaGliMm9ieEhJci9VVWJLZ1l4UnBmVzNQc2QvdlkvWHExUU1EQXlDdHVydTdqeDQ5Q2pJMDNLMGtBVTFPT1FoMGloQlFTalBGWGVGakYxNTQ0ZnIxNitFSWE5YXNBWEVNT3Y3blAvODUvRXBzZWlUKzZJRGJ0bTBEZlErMndycDE2elp0MmdRaWUzaDRPR3p2Q3lZSVdCVlhYWFhWZTkvNzNqS01LQlUzM1NrVVFjNVp5QlVZRmhDV2RtQXJiZTRTMHVQWHBpTkR2Ujc2MmFYVi9LWFIvdkFhUXNVd2d6bXV6UEhwSUdHNEl1d3NWNXBzV0pyb2Q2cGRVaTFTR2xRV0FRLzB3SUVEOEpoZ25sQnBQakhmVVk0YnRiR2g3bnhFL0V5eEl0b1hoKytDWnFWNnpwQXJGNzUrOGNVWFY3dlpMelJqVDN0N084eTB2cjQrOHNYQndxQVlBTzFUMEg0OFROUXcrRUdFVG1XT0NZWXNtS1M3ZHUwcW5RWmhxSURtRlMySHNDTXpXUmcwaTZnbWdrWktSRVowNmhyOS9rUXNnV0lNRzZrYnBoL1ExWEpQeCtEOUhyZzZ0R3BpbkZWSE9YWEduZ2pqLzVKMjdCV1YrNXM2Q3FvOVA0L3lCVDFxbWFNTHdjQ1VjSFZlbU9XbkFtZzVhL2kxMDFKdllMYzBOYTVhdnZRMDVJejJrc2tZSUU0Q0ZYUlVsMkd6SDBGOVduWGdBUlNKQUsyZFE1b0ZyNmJlYTZCaFZLWlF6QlZVM3ZYQzZnSmRqb2FONy9QRndyNytFNk9UNmViMlZnK1paL0NSb0tUQXgrL0lnRVdoakxHdmRPVGV3YzZBaFZ6ZmlmekpvY0xRbUZmVVprVFJsWTRIaThaS3hyMWlYcWVvNFJPS0pXUENBd1BUUUhKLzVObFZWZXIrdUoxcW5EaDR3R3lMbTFZTVE5eU9pN1VKV3JQakhvU3RlWHZBYXRIYkcvcXBCdzNGcWFVaWJrUDRUYUIwNDBUeWtQQVJZTzEyT2czRyt1TFZhNnYydXZBNHlCMXNHOUtXdXBMRU1oT3BWTEtoS2Q3UWxocytBYlBZVVFaSUNCZDdLeFZUY1RCaTRwVERQK3NCWTdiZFdGODNQRHFPclFYOVhwQlV2WS9CRGJET3BiVDhZajZjMjVxOHowOWpDSk1CVGZMK2xUL1QvVThycnZFTGNQWFZWNE5LQmorYlFxa2d6a0NwVStvZlNFeEttNkxxSmtycEIwa0hNcDFLcWdCUFAvMjAwTlYwUzVjdUJkMFBLZ0ZlZ3cxeDdOZ3hjdXNwdVk5b1hzQjNwTlJ4NnZZR1J6NXk1QWc0WjZPam8vQ1oyMisvL1NNZitVak5pbCtVbE5HTFUxanp5QzByYlhNWFV1eUZUbjlwZGw1dDZsOU1UKzhQQ1l0bTFObUhJRWR6eGhGbTlYU0pBbUhHMFVMRlgyclRoUHNPWVdDZzVsUi8ya01oUFUwRklEQXh3QXFrYmV6VzFsWjRIOVFlVlZLQTNPanQ3WDNWcTE3VjM5OFBWZ0tsKzlHVkVDTWtaZU9IV1padzVDMWJ0c0RYcTcwcU1CYzZPenZ2di85K09HbjRFSW1vRWQ2aDdYKzRWR3JMUkJRT1hScGxXSk5oQ0pzM2IzNzIyV2ZoaTJFaUlUVXlJTVVmOWplaWpFSktISUVYUkhvQkI2ZmRMbEQydE1zQW40Y1hxMWF0cWtYM3gzVzJMZWErbVdaWWswMHZSRWpISndQLzNpQXZWNVRVQU9qdFhaL256Lzh3VlFDaTRDZVdZTDBqVGdGUVQ2ZFM2WDBCNGdmMmlQV2R6dUVvTHhsUGJGaTdLcFZNMXFqMWZibXJCYmdSTEZTaUV3b0VzYzdROGluL2xPbnY5UmR6MllueGlWelJxVUZlZys3TEZkeUpmR0VzNXhWUjJXT1htb0Q3MlBkVTk1MDRzZi9raWQ3NVBSYTI5OFdrU0RNQjZqT0c5ZWN3YjAycnpMTHhORFVldU8rVEowWW4rZ2V6QTBNaXArdmtYTXI2aDhOaEttSGNLWGhPM3JPbFlkdEczRlR3b2o1bHREWjdZK09GbUt0TDBhcFprSFlzMmRIanlhMjZnWStubjd5cEtMRlAweDlUN3dVMENCUWxlM2gweHhWdEJublVNRmxTTmp3TlE5TUFneVZiR0JzZksrYnpuZk42bHE5YlgzVXN6c1Y1UW50VHBxa3MwMGltNmhvN2V1cWJPMk4yTXUwV3NHMkEzbHZWdGFTV1pjZUxybGVtQkJhRzFOU1FHaHdab1ZvQXFTMDJqd2FsUXpoVUk2cUxSQjBsd3Buayt0b2YxYnhEa1FLcGd5REVZSUd4TVdHdzFpZUFGRnU1Y2lXMUhTUDVDUHI0L1BQUEI5LzlvWWNlSWdWQTZmY2tza21DVXhrVlNFeFE1eUNGUVNBZVBuejQrUEhqeTVjdnYvSEdHK0c3Ly9WZi8vWDQ0NDlUZEpkcXhFbm93L3FDajhHdmwxOSsrY0tGQzBFcm5EeDU4c0lMTDN6WHU5NTEwMDAzMWFBSlp0cmlXczhScTB4cGU3MVNTcFl3NlN4TThpL2x3YTFOVFphYUhhVlplS1hNdnFWcCtlRlp3aEJGR2QwZkpnK1N1M2xxTlgrbzhrdmZETzJHbXRQOXFHSUNMRE40eXZRRTRXbkNhL2g1Nk5BaG1DMlVzRWtrZ0RBWmJydnRObERuTUIvQStPdm82SUQzaDRlSGFRT2VLaXBKb1pJUkExOWZ0MjVkRFhjYkxnQXNUckFzaVh5YVNIN0NSQk9pYlFnYjhNQnJ1SXoxNjlkZmM4MDE4S2N5aDczMjJtdS8vZTF2RXlFZzJTZ1V1NklsUUhVRVZQNUhGWDN3S3lXVXdFOHdkMmhRWk9tR2ZZYW9NcUo2M1IrTEs1Kzd4RTlvMG8xOURCbnUyWXF3ODdvZjlWRStLVDVsOG9WYkJPR1d1MS9YN0Rma0UzNjlvTThUTEtoQmpNN0V3MVExSTJpQmloWFp5VlR5L0hXcnV6cmFhbHVUWWJhSm9VaEJVV2ZXZ0VkUVNjOFB4S3Fweml4a0tuaHVOak9XVG1lb04wMzFKeGJwZ3B0M3ZMempsMkdvSUxZV3NHQWJKMGZIZHg0N2NkSGFYS0srRHF4cnh5NllMdWg3VzVKK05NdWwrNkVITTVsSkh6czVmcmh2dkg4WTFBdjQ1TENhY2VjL2FhbUNUcWNUcmtqWWRsMURMdUZaYlozSnhwWjRlM09zdlExV1ZWTEVDcmx4ejZwNlhIWHRuYkdXVmxSbU1NdjlMUjZpZ3BDNk90SEVoZ0thblZCZnUwV1U5dlFVYUlMbzIrN3FERTlOY0k5eGM1bk5GUHFIaGh5M09HL2hvbVhWVlBiN1VvYWFRZUVXQmx3VVdPTHhwdWIyVkdNcjJNemdPTGlGREhqNXRoTHhCTm9Gd29waFoyWW5LMlhEWE9zZlMzZHdqY1h6eFlKSjNTYlFkdkZjRWZUb1ZUcHBFVVlLSTFaaFNZWmZ4YWlEL3pxZlVabFRmYU0weVJLbitZZDQ0b2tuRmk5ZURJOE9mS2I1OCtlRHpJS2ZJSmQzNzk0TlBoejQ4ZURxUGZYVVUvQlhJdllIc1VnNTg4UUZSR2tCOEpycStzRDdKNjhMRGdKZkI0TmcxNjVkNUdSVERqYnBSZEFOUC9uSlQrQXptelp0QXExLzlkVlhuNDY3UDBNQjAvNzlERmU0ZFBzL2ZEL2NSQS9UNWsrSDJLZDB2ei9VdTJFQUlGVE1JVGRjR0tndlkvN09PSDdwSjJtTTlFNUl2a3RPWjJucVgyblpZVzFoZjJMZEI0MUxRWHRRdFBCOHdTQ2djOEVjQU9zTlRnR1A4b0lMTHFER052Q0JLNis4RWl6SUgvN3doL3YyN1FNTGoycjY0Y1BVUEFsZWI5eTRFWXkvR2k0SkxvQTZOc0hqZzh1Z2tkSU9QWlVNVUpGaGUzczdmYUM1dWZtVnIzd2x1T0Rsc3pndnZ2aGlzRVZlZU9FRkNoRlJOZ1BkMkpBMm1QTDhZVGkwRmlpcGhhWTNsVVFTMHpEY01UaXAwRm1FdGVoK1M3ZDdtVExpWk9qeSs5ckkwMjFLZ2cvNEc3MmF2TXgzNllPOUpwOFlVQWJ1dDY3akV3WnhvNFNhbi9iK0tVeGdFRnVxS01BTlZhSzFxWG45MmhVOVhSMDFyMGtaOFBuNEJRViswMkRsKzJ3NlFUdU14bXQ2T0dGNnlGL3NnaE9hVGNQdnlWZ01HK0pVcTQyRVNHY0wrU0l4dW1OcCtKVDU2M2NVRlBBQXR4ODUxdGMvMk5yU2dnMXZpbm5kblJHN3hhQnFLY3Z1QTdwcjVIRGY2TzZEMlpGUk9JK3dqSGl5THRIZW5PcHNNN0UvYnl5UlRDVWE2NVB0blNLV21CanBNK3NhbW5vVzR4Y0xPYmdheTRvcDVPT3JXdHpFVXZWTjh4ZWtUeHdYTVV0UjNidWhtZTExRGp1Ui9mbWlVQnNXbXFQSTU4U2pKRTdxQjRWUFFyZmUwVlgzem1RNk16NCtBVGQ2K2ZvTmxtVlhiMmhoZ2lPNmVybzNZS3FodnFHMVBaRktLQ3orSGlubUN6RzdqaWliaTY1WkFEY2lPNjZNbUpUbEZxUnRXWEQvVGd6bGtEZEJDbUtFOEN0RmRQeEdOK21aV2lSVUQ2V0g1bHMyT3A3a1VuMkw4aFA5WEtGWSsvc0E1MzdyMXExRTFFOTlWTHU3dTBudzlmYjJnckFEVVF0K09id0RZaEVNZ2t3bUErcWZxdmtwcjRvME9ta2ErTUFYdnZDRnBxWW1PTlIxMTEwSFZnVW9ETEFBS1B1UGVIODdPenZuelp1M2VmTm0rQUFvZ1BMZVdBMnVxZ2d5ek1rUkxLMHVDOW5XS0xlY3Nyckk3NmNQMTZ3alNVUE0yTlFQdC9iRFRINktuNVBDb05PVnowR2JFZmt2M1Vjb1BmV015djdTekFNYUVkVmUxbURaVU1VYVlPL2V2ZURyMDVGQnp4MDdkZ3ptQUtoWTJzZUJJOE1EcGVLOTdkdTM5L1QwYk5teUJSNzBUVGZkQkovODEzLzlWK0w1cHdkQmJQbGdKdGF3MlUrK05lbG02c2RJYVgzVWRJcjIrMEgxcmwyN0ZvNFBkdWVDQlF0dXVPRUdtTWtEQXdQd3VrelJIUnpuc3NzdUk1SWZLZzZrVzAyOW5zRnFvU2NWM2thNHBkU3NpSDZDbW9jamdGRUNrNStZQVduTG9DYmRiL244TERycm5TamJ3a0FBQmZFTnlwN3oxYnFKaGRDYXR4UUx2N1dQVHlSNTB0OVBWMEg3TXI4L2p3d3kzaW5ubm5LL01FdktCUjFZZE9HY3lXUzh0NmQ3MWJJbERmV251VDc5RG9FQjhacDJpQTNxRGtRc3E3cXZ6VlFyZDZvL1YrQ0hGN0k1bVBWdERmV3hLb21FOVdweE0vbUNpM1gxeEhlblp2Z0lsRVIycUg5Z3g1SER5NWNzckV2RWtkL1h5bnRnZHhrMlVTbVVXWmRPUGovYTEzL3laUC9ZNUpoWEgrOVp0anplMFRKLzNmbk5QZk96RTRNdzA1czc1Nk4xakpOVkpBeTRyWGtGaHdkWFNScDRDbmpFV0hOZnRkOXZ4ZU4xSGIyNW9TRnFiNitaQTNVdXB1TlJOd0c4djJURFNlM1g2eTRHa3RyWVVub0hpUStxTDlSUEE2Ynl5T2p3Nk1SRVEzM2pxZzBYMXZLTWRla0U4UnZZY2F1cFkzNWQ2end6bGJTc1JENmJjM1hiUUZnNjZXekdGTEMwUUFxNFpqeGwyYkd5T1FSR2MzMzlpYUZSYjJxcUVpOFUwZmRURndnWnhJbnc3THAweGRObExSUlp3bm1HcVlYQzM4VHlXMVF5Tk1CWG8xd3RjdVBnSGZpVkNQdEFOTGUxdFlFL1I5dTZ5NWN2QjJFNk5EUUVvbzJFR21WMVVSU1hBZ0NrUWVFbmxkZTN0cmFDZ2dlNVNYb0NSREJJWkRBTDRNZzFaOVNYVjFSRXhVb09mWmowRnliVmgxMTJLQ0VxZkIyNjQzTXh2MVkwT0lqbmRjYXVmK2lzMCswbEI1MXVWR2s2UWltTnpPeWJYMEVuZ3RJYXdoazBQalFjTW5yQzNZVHdyMkV5WTdXQVI5elYxUVh6QVo0Z3ZLQ3NQUXFNRS9FdGFGOTRvQzB0TGZCd2lTVml5WklsYTlhc2dWL2hTc0MyZ3lrRUZpRjhnSkxqcU1jdXpJMVh2ZXBWdFZsYTROQmZkTkZGMUd5QzdLZVFrUWwrQlIyOGV2VnFzRTdBQ29FUFhIdnR0ZURONzl5NU05eHJLQU80cEczYnRwRXhJUUpHSnNwMENXTXROS09JTHhLbU43d0FFNGRXRVB3S2xoRGwvTU90Z0dVQ3RtOHR1aCtKZE1pRjhYUHZLYkdQL0hXdHRLUWZPOWVsOHhoTzk1UUsycGw3eWdoNysybjFKVXZwVENpb1RqdmZaRWZvTHFkZ3d1T1dOLzZlU2lhNzJ0c1d6dTg1SFhkLzJ2TFFlcjhrNTJvcUNLQnRWRTFLRzlDdzZ6WGswWlpEb1pDQisxOWZuNmhoN2pxdWx5bHEra0M5eGV1eitnUjd5WnByRCszSHlXeDYyNkVqVjR4UDFEVTE2SVI1VU5LWVIyYmF1dHgvN3ZrNU1UYXgvZUQrSFFmMlRianV4c3N2NjczMGNsTTRka09EblVnV0NuV29VNHRJWWt2MTlMRmt2V1BhVmp4aHgyejRMMm1xWERybkZndENWR3RheVVSVGk1MklnOGFXQ1Z0SDdQVWV1cW43TFFmeFBpcjM4QnYzS1dHQ2w2YTdzaG02dDVBZVBnVUQ4SmJuY3BuQmthRnNQcmRvNmNyVkd6Ylcrb2hCaEZueEdOakN6YzJ0WGZHR3BuaGR2WXQ4QVpya0Vwc3plTGw4TVJXRE94RXpMTERRRTJBSmxkZkU5Y2xrWFR5V3pSY00zY3RIRWNFRlRYTGlycUFvQmlXN2F0dFY2WXdIUHg5V0JIUStRZUFyS0laZ0lNQk5QOVcvSkcrNGRNWEJtK0FWVmVVSFV3VlViYTF4YWdNMUdDd05ra2ZVTHJQdXhGZWwrMHNKYWs0bnhqNTduQzhXbzNiSnBVYys0MmVaM2ZnMlRWRGtvRTBybm91MnV1RnhYMy85OWFYdmcrNEhDK0FNVG9QenpqdnZVNS82VkdYaHJ6ZjdRM01ocE9BdGcvWHIxMy81eTE4K3plY1krdnJsdjE1Tzk0UEg2L09VYTVVNTVjUlRFcFB3UEw4YnFlSFRzdnZFNW9vSzVZWGo1d0g2aVcwR2VkSlM3M1VxVGFIcjcwMlJVTWE5WThOc3FLdHZySzlyYTJsdWEyMXViMjA1VTNNTHJpdFgxTHRRcGh2c1BBU09PSlh4S3lwU2tKUUJnTTZhY2xYUnlXWW14NFpPWk1jSFZVT2pyRDVkQlR5UThaR1I0LzBEQlVma3lySmIvT0tGN1pldld0WGNnQXgweUw0TFYxc294cEp4QWViMjNEVjQrNDRlL2VaUGYzcGtjTkN6RXZiOGhac3pUbjFUYW1SbzJFcWtuS0kzM0greTJSWHRYUjFLeDhMdGVHcHlZc0liSFVtbVVxWVV4V3ltLytqaDhlR1JudDVhTnIzc1ZKMmRyTStQRHB1eEdJVW0wQ0hRWVFETTNhTWtPSWVTT0pEWkVXMDdwR1hVMi93NkF1RHE1cmJ3bzVqTEZMSzUvcjZqejIvYk1URTJ0SFRsaXZxbXBob3VxVkRJVDQ0T0s2K29tdU9KdWtZNzFXREZrbDVSbkR5eWU3anZjRjJxWGpiSGl0bml5TVNFbVdwV011WWc3WFRCUVhhRXNpTzFMWmlUWTVNWlRQYW5za1NsV3lONURtM3FLK2tFKy91NmtZSXVIZzNpLzVSSFFnUlZnaXBic0pqVGN3VmpiaS96VkxxVmFtVTN1Y0svd2xGVUpidG1GT1A5TWs5ZDg1SGxMOUYralhLdXVRSTV2MHpqYjBZUWFOYlhML1p6akRqZWNoZlUzTmlvUk5DaHJLUTNtWTdMKzdzOFBqTlBJT2wwa2o1UjQ5R2xCODF5aEc0RHJFblBVYkZSbkZSenZscW1ZZHZnZnNWU2lRVDQrcWxrb2g2RE9XYzRIR2NhUm4xZENpNFlTK2I4T0szbjkxNmhXbXZkclUyWEsvZ2xmdWdWZ3dMTzF6VjNkSzFhczdHM2U1NWR2U2lKeCtOcjFxMVB0YmFCdXNzVmkycTZwVStaRVBUYU1NMXNMR2sxTnRjMU5vSi9iRnEycGdFREo5WTI1ZzVLSitycjU2MWNXYmRnb1FzRE1GVTZrK3RldU9EbzRYMnEvMlJqTExucnVXZDcxemp6Rnk3VWhQUk9VWGlaOGVIQkU0ZkFJd2JMTGpzMmZ2TFkwVmk4M3A1N0M2cmNMWTBsa2gzek1idXdIcXRLS0JCdUNEOUgwOCtkOFBucmRPOW5YZXRwaG1XZG9BWWRWK29tQ2lvV1YzYldqU1hyTzd2UDYrbysvL0tyYXZTNkdocFhyTnRnQ05VMXIydkIwdFdkaTVZbDZ4c0s2WXd0VlZ2bi9KYk83c2IyK2FuUllaR3lXenNYdEhYMzJzbVVNQ3dLbHBhZlBHMk5qZU1UR2JJWi9ZMGJOQmZqbERnaXdqaVNNRDNzSWVpcit5azJQMHFWMFc5NHVqb2pIb3NMQm9QQitGWFpwbVd5UENZbTB6TURVMEVaL0ZSdldSbjhJVGlnLzZtUXNsUUZid2R4VmVtbjcvdnNBS2FKaVRCV1dVYkowd2Y0V2RsY2pxN0VWN2RDVGIveUdjT2s4WUZQV3NobEo5MWlNV2JiTGUzZFZwWHF2MWdzSGo1NHNLQzFmcGxDRjZxV2JVZ20yNXFiYkcwaFVtY0VDclNZeWFSaHptNmxaU1ltVGh3OUduVC9VQzFOTFkzTlRSUGpZekNBbUdrUERmYlhOVGExZDNUU0JqVjQ0NW1KMFVJaEY3Tmo2SEc3MkdZZ0ZrODI2MExuV3U1cUllOFdDdEx3OC95bjlyMUxKdGdVZVlEMHl5ZW5aa1p3Ty9EYUhIY3lQWm5PWk1ISmJ1M3FTaVRyYXJpZVREbzkySDhTVG9FdGUrTkp5NDdCdGNHeksraUF2eFdMZ3lFRkpsRFJLVmdXM0FPZmY4M1NyYjRyaGRGVXJsRHdrMFhVTFBObDFwWUFxaVRDRk01L21na3gyNHEvQ1B2TkRBYURjYnE2bjhGZ01CZ01CdXQrQm9QQllEQVlyUHNaREFhRHdXQ3c3bWN3R0F3R2c4RzZuOEZnTUJnTUJ1dCtCb1BCWURBWXJQc1pEQWFEY1piQm1SQ0ZRZVdNU3k4cnZEeit3NnBmU3hoeFpTYUVURXE3V2NRNmhIRkdDWmNLQTNoU2QxdzZXYUh5K0E2ZUxpWE1CZ25uaXJXZjZRRU9LR2ZpbEFIR2xKRVFacDIwR2tXOFMwajd6QTVRd1JqZFNlbWtoU3JvQWNZVW5NdHNFS2MzUU5iOURBYUR3YWdSS3IxSGpqL3RqVDBwSnJhTDlFNVIyQzhjdjJtWER3Tzdkd2xUcU9SNU1yVmFORzZRVGVlTGhndGtZbjd0SjgwZUZtT1BxZUVIeGRpekl2MllLaFNGTjhXamdhZUwyU3ExUlRaZUlGdTNpSll0TXJId2RBWW9KcmFLMGNjVURuQzd5Qi9FbnVjbHB5UENkbUVMRmQ4bzYxYkx4dlV3UUhXYUE4d2NsS1AvclVZZjljYWVrZWxIUkZINUp5WFNOQk1NREZ2VVhTS2JMcFF0bDRubVMwUnlBZXQrQm9QQllMejRBTTEwOUovRnllK0p5ZVBra1liSzNsZUt2aDRML3RGcitHdENpTVkxUnRkTm91Zk5zckhLemgzWlkrcm9sOVd4ZjFGamUwVjRVaW1tK3F1WG5nNFFFN0pwdVpoL2k3SGc5MFNpdHpvRlBQYTRPUHgxTmZCZE5YRlNGS2RaTTNNTzBOT0tPU0VVRExEN2phTG5UYkpoWFpVRFBLU09mRjMxZlYyTUh2U0tJU1BlbkFPVU1NRG1GV0wrYldMQjc4ajRQTmI5ak5JcDdBbzNyVndkcDFMRm9IdXNObytObURSaXdxd1RadW9NbnhUTzVVNG9CMDVhRU5TdEhwc1p4YVdSRUZiakdZNzdLVWU0azhMTktRekVPZjdwcGdZWXg5RzlHQU4weHBXWEUyNDRRQk1IYU9vQlN1YnNZNXk3Y05QZTdvK0tnNTlVdWtNV2FEdGhpS2l0S1VIaHVBSDdhNE1RUy83Y1dQckh3cXlQOU5YajMxQTcva1NOSENFVkcrbWtydjVuQ05uYUkxZC9SdmJjSE9raW5RbTE1MlBxNE4rcWRLRHNheDdnMG84WlN6NGd6R1Nrci9aOVErMzZmVFV5Z2tlSVBrQlBEN0J0c1Z6NUNkbnpXNno3WC9Zb0RxdnNZWms5b01hZkUrbDlYdTZvS0p5UTdqSGxqV3ZGbUJCbXE3SjdwTjB0VWd0ay9TcFp2MVlsRnNua3dvalRkSTQxTTZreWU4WGtkakgybEpyY3JYS0haSEcvMGd0SUdvM0tXaW9UaTBUOVNxUDVJbFczU3RZdFI3T2paaFNHVk82SVRPOVRFOCtwOUY2UjYxUEZZOUxwODA5SEE3UjZaTHdiQjlXd1d0YXZVZkZGTXJWUUdJblRHT0NveXV5VGt6dThrYWRGaGdaNElCaGd1N0lYeWNSQzJiQktORzBTZFd0azNiTFRPaGVEOFJKMEpYSkgxYk52VVVjZnB1Qno3ZDJvU1VlQ2dweDNoVHp2THBsYVV2YkRCYkg3WSs3Ty80Mit2bFhpQkVlMTFQVzV3RVZlODJmR2lvOVZ1QzZRbWMrK0ZRZG9uTjRBUGQvc0VQT3VNTTc3dWt3dExYOWF0Zk5EM3U2L3dRR2F0US9RV1BzWGN2bWZSYmxvMXYzbjR1TE1IcEhEUC9kT2ZGOE1mdGViRk5LZHRqVTFjOFlvMzdwVXRqQWFXMFg3RzQzT1Y0dVd5ekJwcFRwWFlGSU4va3oxZlZ2MS81T1luTEo4cDUweERGVloyaUx1K3YrTWVXOFFyYjlXdFZPZVBTU0dmdVlkL3pjeC9IMVV1ODdjQXd6UGFPcVZYejlmZEx6VzZINHQ3cERaclZYYVVpTmk4TWZlOGUrby9ydkIzWkhlSEFQVU5yZy93TzUzR0QyL0tkcXU1akFBNDV6eEtOd25YeU9PUFZHTGZwcExhY0cvcnJYbVJmZlBHWlAzOHQ2dWo2aHRuOFMxWnAzZXVXQzlydjZBc2VadjVyWnNqbmxQdjBrY2ZVVFlaMjZBSUtCNkxqSXV2S2VNZmVOdGU1L2FkYWN2cVdyM1RMUXR0ZmJEeHFxL0VwVjZBTEx1UDhmVXZsTEg3L0VPZkZxY2ZBdzNxTFFTOHZYVHpLNUxnYklNRmFRWEtORzRrRjNYeWlYdmxOMnZqM3JhOGNmVjNzK29vOThVV1gxU093aVV6VGlqTE5rVmM3UjlrQkp5NFcvTEpYOG9teTZJZGlZSEJxajJmMXIxUDRrRE5BUERQUG9BaFI3Z3ZKdU1KZThVN2ErT2VtTkhIL1QyZkZJZHUxZms5Qm10a25DY091VjBaQllVOVl0NkdPQTc1TkwzeVBxMVBEMFpaN3Q4OGJhOVUrMzg0bWw1dzdNR0FHQmhMcjdKM1BSdFRKcy9GUWMrNHo3OWgzNlk0VFNoWStuR3hrL0x4WDh3YTNSQmJmOWpiOXVkNENlYzRRRVdoRnp4WnVPOGY1eHRkME9wL1gvamJmMFFmdXowQitqbytQK0ZuemNXdmFQOEdGajNuME53YzJnZDcva1U2aWM3VUlwVlBWNFpyTU9pMXNvci81ZGM4UkZaS1N5UG0zQXYzS3FHdFVhMElwOVVUaWxJMmRaa3JQOW4wZlhhaXA2MzJ2TVgzcDdQNGdCak5Wbmw0UUFkSVVFcnIveW94TDNHU2dNOCtsWDF3dStxTVQwNmV6WUxvL3dBNFZ5ZEM0d05YeFFkMS9Na1paekZHSDdZZmVRSzBpNW5XblpwbGJ6cEs3TDM5bFBNN2tmZGg3ZUkvT2w1L05PMW93VGhkdW5Ec3VteVU4NzFpUHZRNWI1VGNjWUhLSVc1NVZ1aSt3MHpWZkxRVDkzSHJoR1pRTGFjZ2RnTURmQlIyWHh4bVUrWmQ5eHhCMC9wY3dLZXQrMDlhdWZmbzc2Sm5kN2lOUFFSQ2tLY2ZGaTV4NHlPVnd0anpsbXBqdnlqOS9SdFlnS2Q2Vm9XRFBuUWsza3grRTFadjBZMHJKOTc4V1M4YlgrZ2R2OERPdE9uYVpWVE9DUW5WUDhEY0c3WmRrVzUzTU9EZDNyUHZCTlhacUttdTBxUmlZbHhNZmovWk9QNW9uNDF6MVRHMlNwaWR2NmhHTndSYVptN3dhNmZpclpxcExhUzViRHN1VVVZMXJSVi8venZpc0dEb21KeXNBcXkzbVFsNFNCeDdRdjNtQVExWENyWlZOSGIvWmZpeERPUmRMQWJuRTVFRzZDQkVsV3BZYVA3TjRVUm56YkFGOTR0K3ZkWGxtblJCd2dQQ09TVk9DRzdmcU9NNkRaNFFwOGp5L0xRMzZzOVgvUzEydW1EREFpWVE3dnVVdnMvRWN6eFV6N1ZmNjk2OXUwWTU0K2ZuaktPQ1pVVjdqTnZWc01QekRuQWc1OVcrNzUydWh0K3BkQUxVTzI4MHp2MGhUbmQrQlBmY2JlK0Q4MmcwOG5ZMDBWTmFsSjRULyttR24yTTV5cmpyRVMrWHd4K3QvSXlwN2dhTEs2dTFhSnpGYjV3bytsK1dDWWpENHV4eDZmN3hBK0lZeityclBncGFTQ3UvM21Wd25KMHJyNzd4Y0I5MDk0dkRJa1RYNDFrMmZnRFhDWTZsK0lMSjlvTkJNRTErQk9WUFRSZGhQNjc2UHV4SHk2dHFQaHBnR291ZVR4ZG9oNzVnUmo5UlhteHhEajdrVG1vZHJ6UHQvak9GSlR2czNvNzd4QmpUODN5Z2ZRdTcvbWJWTVpYb3FjTEMyMVY3N21iVWNTY2VpM2pUNmk5ZitvWDlwekJBVnE0b3RUdUQ0cXgyUlpKZW8rMzlZM29qc1NxM0RxWnc5UlE0OEo3L2xaUkhPQUp5empyb0VaL29YSVJUSHhQeUphRXVmbmZ6RXNlTVMvNWIzZ2hHeVBvS3EyTDRQaHFja2ZwT2IyRGY2UGNTaWVsREw2bGJ6VXYvb0Y1OFgxeTZTMlZWNnVGSElCZTN6M0N5MDY5T2JrRHBWbEZDVk1Vc3JYZDNIeXZlZkdqNWlXUG1oZDlSelpIVS8rZ2JQTkNUanhmWWtPazFiRnZxSXJiR1RwOElsZmNibDc4US9QaWUrV1N0MVJXL3hSbU9QUUY0UlZaOTUvYlR2L25SRHFhWGxSQnRDcTZTczRLdGY5T0pBWW9oWnRXQno0ckJzK1E0Zy9QTmR5djlzOVNnYU1PZndXM0ZTSXEvcW9HQ0hwOVRJaWozOUFNbmRQdjZ1NFBnYllXWnpCREgrN1Y4WDNxMEplUWtJREJPTXNjakgzQ2plQ2VXa0t1dVV0MHZnN3JhT0JmNSt2a3lpOUd5Z0dTMmhEUEhTMVJ4cnRWLzg4cUwwRE1wN25BMlBCNTBYR0Q2UGgxWThPWFpHdDNaUWtBcGtiL3Q3QWFPYnoyeVcxKzVVNVoyU0p0R09EblJlZHJrVTgzMWlHNlhpOVgzUlVwNmlsUllYdnBmVWk0NG5zWDI4WEpleXNITWtGYWRLd3oxdDJKQ1VNZHI1VnI0Y1hxeXRhR0xkU0o3NGpTKzhtNi8xeXp4OTJNT3ZHM2taNmtxOWRKSEttZ2hCUE5HTmNxMlR2NUx5SjNmTnBKeDU3MERud2hVcnF2ZzlZdWhzM2RDR3NEWS91ZlUrTmJwNTByczE4TS9rZWsyZXBwcXp3Y1lNU01QSkFDSjc2c1FMU1ZZdmdCZGZoN2xlVU9aZk1WOUQ4bndybE00ZTM5VTVVNXhQT1djWmJKbWR3UlgyaTRjLzl6a05KT3pzaHBiYjB5cWdHTm5zbkUxRzhEUDBUUlVkSGFNSVhzZnROVXhxNVpKK2U5cDdKd0E5azFLZFRvRTFNSFNoLzJhM1BLREJDV2VVT1hiTHBvMnFHYU42TUxFZEhmY0NkRHlhdEdIc1ZJZzFYNXRoaTk3d2dIS0dQdFJzLy9VQlhOS1JNM1V0WFFUMW4zbjdzWWZ3YWQvaWowVHpFaHovOC84b3BuNUJWUHk0MS9qUXN5V2l3T1hYODR5NVE2bjFUSDdvNlVtSXFWdTZ2a0pWOHlObjlHdGkydXJJOE5uWUozK0V2VE5PYkVWbHlXRVl3TWxEdWJQaVd2Mmk1ZnVVMXUrR2pVQWNJaW1jeEpzREJLNzlhQnY5WEpSNVhrRHB4MDNtWmo4K2VOVForVXJZMlYxeitzODNFaCtyNmgrUWNaakxNR1V0b3lxWmRZc3R3LzFiUkZXTlBMMkVBRlJYUXpNSXR0U3FhbzRaOVcvb3FuSXcxMXk2Y2RwbVVUcXZhS29zWUQzZitvOEhLQkhMQXhQYjc4QUZOQ05GMHE3SmJwb2pVWHVpNFJ4aGdrOWJscE5mTGZsU01OU292WnhtbkV3TEpoTGRaQ1ZyeXJDblQvQTJWRUVlTXN4K1QyeWg2blhnYkdocy9MQlcranpFL1pzRjZwblBmY0haWE5QMHJCVGU4SnVHdzBzVmZmRnlwSDRHRnFObG5HNXAvTFdDZiswbnlKZUdxTEdsYmxNbmZJbU8zL3ZDaDhWT0MzU0hRY1FyWndvNUpsZzdHNHo4aEY3NllTWWJuOHcxNXhVTzM1WE9YVlphQUtSNGErOEc1TjdoRW5mMUI1Y1JTRjdGeHNiUHltU0MyR0w4bU8xM2lQckZQWlNwY0twc2JSUDVlTDN5ZU1ScDY4akxORzl5LzVZNVFlRlRVVnVxZlRQelA0TStLY3FTeWpEQ0dEVlMvY3JCcjlRYVJ2Z1R5WlRrU21ZbDErcFZLbHI2dXhwMVJoVUNLbmtKUkwzaWZuLzdadUJGUlcwSmlOU05wZGlyR24vTExxaXBjcWhjUkdmMXF5Rk1mRTJNOHJpMStRYkVrWVlNKzBOKzFXSEdBMmd0czI5a1BXL2VjdXdHRXRyOTZrWnBab0VxTHRxcW1TRDNqUjlRWmgzVkZaTmZwSEtNbFFHM3NDZDk4anpCM1o4ejRaNzZienlhYk5xdnM5WXVqT3ltZE1DekgwSTlGenEvOXI5akF1QUt1Q25TRWIya1huVFZQY0lFYk02TG9CZHhBSzBZSWloZEdwWHdmdTh6bDhLaTFtdWZDOUlyWFVwOUNxV3lHNmYxdnMvZWZLdW44TTd1R1RvdjNYZVBJeXpockVPL0JmdFhDejR2RG5JbFg2VWU1dFFIeXJNZ2NyQi94SnlOaFNXVTF5Mmp2TjB2STcrcFpYalRMemdpZ08rM3lDWUhhRWxrZDBGRWZFd2IrTyttRVFLVUZySCtXTXEvU0pTTGNGS1JTbkZSb3BxdzRIcUNvUFVHV0d5aGdHakxNY3ptamwyYU9FcXJ0TW1BM1Qxb3dScStMNXkrQ2pibG9OUHhLSjN3T00zUGFyUzQ5Z05GK0F5N3RTQlk1eWhBZW5DQy9mbll5U0tLU1NLMmEyc1RLU1ZSQU5sZDZ3d2Yrcy9CV1BXb1JkTU1XZEtVMEoxbFdVY3ptaVREVWpnM0hPUU8zN3VEZXlQNUtjZ1FWVlZ5OGF6Z3NzL3IyVlV3djlhTUc4R1pKTk55ZUxzUEIxWllFRTNYODZBenowRDk3Z3ZrZ0pEVVZrK1JUQjlvVE1IeGVGYUJvWURqNkQ3bENtSW5ZL0tuTVQyTzgvKzlGN3U5RzhaUllOTm0xZDVTUjRwVFBNOXNubkk4WGlhQUxad1hlZENURjhmNlNsQlZNMk1aMi9PdDZEdWU2NXNqTmVaOE9LOFVleDM2QTJPT1NDdDhtbXpab1FRODU1ZldBdnBKWUpjOXAyZ2hyZnFvclJCb2gwUmdHOXY1c1JFL2RIcVdVU2RVTFpYYkxFdUpIMUsvRlFxaks3aUJyK21SUi93Wk9YY1M2ai8xNjEreThpbGVhU01HbC9QWW9wUXU1NHhPdzVaVFlhMXZTR0lLQXBJeElLWWNCdnNIYkZQL0JEdGVQRFVUMG9rR2Z6M2h0dWFxaDhYNlNZSzRaREZzc1p1dDlNQ3FzVGt4Vlo5NytjZ1hvUi9sVUxyK2dkK252S2xLa01pOHhWdmRudmpHTTRMa3JLUGVoK3UybmFQTFNicEkycFA1WG5hL1laYk5palcxL0lwbGNJK0ZmMUFIUHErTGY4UGxvVkw5VVNNckhRLzIxeVYrVm9vZS8zUzJIT2lNVTE0NmlqVkRSTVBzUlRsM0V1WS9oQjk1bWJJbTJFQzEwamt4VG1vbmVXdkRNU1NUV2k0VzdOMGl2TGFCRnFwUEl5OUFUdTk5ZW0rRWNlOFo2K3dlOHJXQkVGVFNLKzROYUExRS9oTG1wRTFoRE1NSngyaldBS2VFWWlVdG1rS3Vmdk1GNk9VUDNmVjhkL0hwV2VNeUZrNDBaL091V080VDVjaElrRHBxcWMwYUJQSmpCVUZXWEt3aW15QjA5cmdFZStLZ1llcWN4L1NRT3NseXE1T0JqZzRjcFpRbnBSU1hQUnpNd2dJeVdpNU44YVhPSFBPS2N4OUNQdmlhdVFPU09LNHRjQ1FTNzVBMHdIbmxxVms1RUp0V1p0S1JpdHJCQ3JDdE0xV1RZUHFDY3VqNWoyUkZTRGN2bEhaTU9Gd1hrOTVhU2psaitnY1ROZEhzR3Ywb282UU5iOWpLbjVrTjZGREhwdU5MTWFxVE4rUXdSYjZRck0xWWc3QldhYnNLYTN5UUZiMVd5UHNxUkJOYXJDOFpvSDZJMC82ZTE2dHlxS2lCdU5Sc2ZicHRwcmd1NVhrVmFVc3RwbnJFQnB4cVVaTGNQQTVXbklPRWZGUzk4M3ZNZXV3NFRXaU1SZlJTRzdOaGpMUHp4OVZSWWpWODFacHlUbkcraG1SRlNOWHI3cUFaNzRsdmZZSzZNU2Yra21mcUozRXhvM1UrSkMrUU9NTk1aVFdvbkFlT1hwVXB5eTduLzVJWHZRZStZTldHVWV4WERVQ2ZiR292Y0VCUUt1S0k3Ni9TUXF6WGdsNjJZdURqUmdVMUYzdVFwak5ZcWV6RDcxN0p2UTV6QWp5UjFSSjJUUDYwVVlvc2hINXR3MTYyYXVRR2xIWFZMY1BwTnhMdXA5dGZjdnZTZHZWZW5JaWgvMFlvc3dMcmdIT2ZMTzRBS0pHazR2eVdLT0JOZmI4MUh2OFp2VlpHVEdUeGhndTIyYzk4L0lBemp0eEVHdm8xK1J2T0Q5L3BmWjBnUzl1UFYzeFBGdFVTY3UyS2JMWHkvYXJnaSs3eWxuckpyWk5VUEpteXFLdVVyN2NHNm1objA0TmJuTGUvWm1jV0svVG82dDdQRWpTZWZDdDZuV0s2Yys2NHhHM1dpY1pmbklxQkxINDhuSU9MZGtTL2FRMnY0SDZ2RDMvWnI3aU9LbFdjak5qOC9TMzlLTVJWMkd5cDFpeVoxYTJKRWorVElXZFlDWlEycmJ1OVdSKzZJT1VCSDV2NUFYUFlSTlNtZUlBQ01lTmJDQkdWTFRkYi9ubmo0NUdPditsOVBpbkhqRzIvcDJjZnpKU0hwUkluY0VUdHlWLzZja2xVWk42MzVSNFFqMktXZVIvcHRSckZnc3pLOXlnR09QcVdkdkVTZTE0bzlTT0ZzUXNyTlJMdi9RdEx3RUwvSjVEWHVtMHdDL2NpaU44VEtVTGNlLzQyMS9veGpWNnk1aU5Mb2dqTFpPdWVrL1JkTUZzL3pWckkvY0duVFdCaDdGcUZhNEZZVml5MVBIdjZ0ZStDMDFGblRsamdKSHlQWjI0OEw3UmRPRnA1eFhTcnNoc3Mvdm5sTEw3MFhkTlpTcyt4a0RQMURQLzQ0WUdxN2NMMUlFMlhZcElUZit1MnhZTlUxZm5rN3dDVFZsWkdkZVZla2FuN2hIUGY4bXpPMk5SVHNKS1A1R1laejNiWkZhWHR0NXBUVGtMR2V5SWpmMVpERE9mdVNPZVh2K1V1MzdZdFNpSVZMV0lFWjZyNVRuM3lXQ0hOdVpzTnNqdThXRlU3clZnWXN5SHNrdlI3ZS9yZElBajNxNy9sd2QrSnBmdXhSOWdBdGVLYy83Mmh3RGxGZzFIVEZLaUdPWkpwU1VjcVNYVTFGMlRsbjN2N3h0Y2tmdC80VGEvUkYvanlxaTRvOEo0NEt2eWM0Ylp5cnZ5Q0d5V1hMWjBZQXQrRE95Y28vdHlCMzB2THphODFmNEwxdUY0Z2ZMeGpqL0c2THRWYWQ0ODFFWGhmSUtTbmx5K3FLTW1zRXZlVjR5em5LNEdURnd2N2Z0OVdod1c1SDdpRHBhdGl6N2ZibnEvODVrL2k5Rm9nY1BHTUc1bGU2b2N0TnlodVR4b2kweFd4c1pjdzR3cS9wL29MYmZISFdBTW5ESUxXR3NlQjhPMEV6T1BjQjVFVWtJVlBHb1V1NjAwWGdaNGZTeDM4OG91OVltZDNvNy8wUWMrVGZxNVJNSldVeC9NeTY0Uzg1LzZ5eHp5YXlMN1BtclV3eFBUeXFsb2sxWmFVYkwxQjE3MnR2NUlYWHN4MVhzTW9KbDB5RE1DKzRXM1RmUDh0Zm93VWJsbm1MQ3FDcVNqQmlNczFpdzdGQjdQeTcyMzZXcThvWmRJVnVTeHJxdmlKNjNWUGh3YW9VZlFhdmN4T3NFRW81TmV5Y2Q3WXRFejlVbVp4L2dMclh2NDJyZjEveHVPbEhnNkFHMlNybm1HM0xlbXl0OE9ONkY2WkJaRWFtSDc0eUVCamNubkZ5a1N6Slk5Nzg4MStmaEw2aGQ3OEtNZHlOeU9VcGVwOTJlZjYvc2ZPMXNHc3NVZG5QVVVKWEs2ZVZ1bG5yS2VJS0tUai85TmNJK25EcndhYlhuajdEWWhnWVlwVGF2SUdTYk5NNy9rV2k3WnZiUHhEb2lKeG5sVHpsbE5LZGZzZTVubk0zdS92RzcxWTdiMWJDMnRxTUlGdDFjV3lTRXNmUld1ZkpqSVdsL09lbVJYQ1RpVXVRcUxXbmRhVXhPNXpWWHhWRVZzWHRRYWhNS3RGUGNmWEhzWDlTdXQvc0ROS01Oc0lDbERYTHA3OGlWZDBoczdsWHB3cTFHV2JkVXBmZFhWdDZldG1hbWhUb21QU2RhTG5QZFF0YjlMemVyZkxmYStjZnEyTDJvakt4b21rYTMzeFlMTHpQVy9wMmNOZnVHbGxxczFlZmtyOGgrNC9WaGJLcVVhdHZOQzNja1VuOE9wT3BxTHpmQThlZHdnTWYvYTJxQUtzSktjSVJjOUNxNS9uTWlwQTZkeFI3dmp1cTFGMGRtUnZoaGdCSEpEMWozTTg1R3dUTCtsTnJ6djlYaDcrRThqeGFZODhQdjh5OHhWL3d2MGZtNnFHY3liTkg4UmpIeXJRcUJjUXlKZzk3dG4vWmVvUTk5bUNqTnhwb3VsTk9aenRYNDQycjN4OVdoNytKbFJ4OGdvUGR5WS9uN1pkZHZSQjJnMVNTYUxzZUtwUEt5eTlEK1dMNVBOS3lkdXNpSUpDdWVrTTJ2WnQzLzhsbWRTaDM0akxmbmozek9xWWhQV0d0UXVlNGp4cEkvbUY2SGVnb1M4OUhTTDFRMmg1R2Z4OG5JVXQydnNzSWRqTGdQcHhJTDVSekgxUVA4WTZ6aWtaRUhXTlJXK2ZxUEdZdmZqUjB3eXlDMUJBZm9WSGJjcFRNd285Skd1VGtWdFFFSnoxVEdXUVZuVWgzNWt0cjdmaldxMTM3RS9UVWxKS3k3eGU4WGk5NGg2cFpwcHQ2NTkvQ1ZoNjVDc0VkdXRGL2pIZnhXQlRmRHdLV3RKbmVVZnNRYmZyUnlEYTN1TWlCYnRrd1ZNVGtUNnZDWDFKNFBZREsvVmNVQXRidi9RYm5vUFRMWks1emhjc25DT01CNm4wckVUTXEySzVUeFR4VlNFM1FYVmpXK1ZiWmZFMzVPamIrQUVyaGl4RVVLbyszWFdQZS9QUFQreEZhMTdRL1Y4Wi81enphS2x2VzBlZGplYTZ6L3FtaTVTaGlWcGp4WUJnbFJ1Y1d0anNXQnZDaHRyUzNkZEtTcVZOeTVYeWhUeTJiNXk5alQzbzczaXVPUCtNcys4Z0JGNXpKejNaZEV5K1dWQjVoWWlzdStHS0VmanpNb1ovajkzcVFvUnRQOWM4ZmlHSXlYSW9aLzdqMzNmbFE1c1NxRmtoSnE4RzR4ZEw4RXU3K01Uc1kwUUNXWHZWOHUvWkMvd2pwZUEzWkRoUjdjbEY1MzdKL0ZncmY3RWJ2aXVEajJWNVUxbTR0dHpXWFRwcWwzUmgvM252c0FPUW5Wd1JPcS94NDE4Qi9TSGFoQTNGRlVjdm1INWVMZjl3bittamZKZW9FOFNPVzFPQWk2STU4U0MzL1Azd1l0bkJUSFBsT1pFeEFHV0NkRTYrV3MrODkxZUhsMTRFNXY5d2N4ZVNSNkpaMU9BRFJXZkZndS9ZQ3dXNko4UTVwMXN2bDFhdmplaWlZbjdzTVZUcUN4SDZJd1ZMa1hBSm41alJmUDVBTjJNK3JBcDczZGYrcTNBWXc0UUIyWk5GWjhWQzU5djdBYUlnMHcyU1BxTm9qMDg1VUhDRkxKS1cwQXFtVDJDSzc5Q04yRFpNdHJlTTR5emlhL3doM1RQZVdxL0pydVdDMEdqd3AxVkZVMGlFSHY5dXlmV3RtSkJiTG5OOVgrNzFWWVVEWTQrbnZsc3pjYjgyOVRRcXFqWDFWakVZUU0rZ052RmZWclN5VE1SQlZWZktVREJDazZlREJTbWk5SWpQa0haZkJCV2JkV2RiOUY3UGxtaFcvWlFnMzFlYys4MGVoK00xeTMxL2RQYW1ROFVvYmd2TnRMWFMvVy9lZmdvbFJqVDNyYjN5ZE9QSVlUTVRyTk15eVBudXVOVlg4bGNTZkpxTUJyalF6U2VyWllEYkwxU3JYdjNzckhCM040N0VuWmNsbUpWN3dUWjZSWmFWa2FRcFoyOVFEZmV1d0o3NFYzcVpQUFZqRkFpcXN2dXNGWS9RbUp1VVhsQjZnMDZSQWRXc3EyNjlUSlNycmYxTUdQOVA2cEhvUEtVNk5QenNodW5FdGV3RDNrbWNzNG0wQjgxYlgxb1loWS9xZDB5NCtwTXhweThmdkVrZTlWQ1BzVFBXN2ZRKzZKaDBqc1JHcmZsUkxHL0RkUDY4Y0J5Ny9tbmJpSVFna2RnNUt3aVJFM2VtOTFqM3dUalI2cmdxeFdSMzdrOXYwb09FaGxweDk5bmdXL08wdUhROWI5NXc1R24vRCtld3Zxb2FvZXBpNWNrZkVPZGVRckNnemU4aWFycTR6NXJ4UGRiOVJheXhJdFcyRGxSR2xlNloyNDIxejRUbis2NTQ2SmdmK0lZbG5McEJDbDIxUkRQL1lldng0alk3SHFCb2p0UEdKdDZzRGZLVGRUSVJYUW5jUjEwbm1EdjlBNmIzUjNmN0l5QXdFWU55ZStKenV1OTFzVk8yUGk1RjJWeFllck93aTBYTUV6bDhHb2dLWlh5QVUzcTczM1ZJakR5NUpzM3lpRW5zZ3M5Q2JSL2hLSXZiVmVJM3QvUyszOVZnVlpTajVQeEFFS0hYTmRkcHRvdktETVIxajNuLzF1UC9XY3JiYXJrMFMzVmUzK0ozOCtsYmNpQzBMRlVyTHJEZFJLVXRZdGx4MVhxVU1QVkM2cjYvK0Z0LzhUY3Q2dEdKdzQvQVYxNHBISytsc0oxWEsxMFhoK3lRQ1A0SjVmdFNZNVdNcWc4WGY5VStXU0JGMmZvK3JXeU01Zjl6L2FjcmxzN2xZREp5cXNEeGpMa1h0VXk4V2k4N1hDY3pBVGFxZ3ZTaXhPZHIwSnFVc1lERVlGZnpvcFYveTU2cjhITTVjcmlvN0lHNTJ5VWNpbGYvS1NLTFl4RTNMWis5WEF0M0NBOWhrYW9LN1R4bDNPTXN4Q3JQdlBCWUJYYmRSRXRTc2plOUtZVHQ4d05mTmluWExCN2Vyb0ErakNHdVcwTDNyR3ovMloydnRucUY5em9uSitpa0lqeGx6NHJ1bG5qL2xGcmkvU0FNazRNRXNZQWFWbExQcHpkK0JkRlkrdllJRFB2RitrM28rWGw0bXduanlkWUxIb0hXVmljUXdHWTJxUk5hd3pOdnlMOS9qL3dNRDQ2UzhhUjhjNzEvOC9XZUpkL0lvSDJIU3h1ZjZyN3BPM241a0JhcG9CWThNOWNOOHFPVWNNUnJUNHdyVGZPcTZUUGVlTFFvUXFmMU1yeGF4K0VTVUpybk96NkhyRHIzNjQ4MitWYlJHb2VnejlMeTM4UFplS2hubFJ5TjVmRjgyWDhueGlNS0pxeC9tM0dCcy9qZ0trY0hvSEtxSVVNamI4alp4M3kwdHJoUE52TTliL05hWWJGVS92T0xyd1QyNzhqT3o1cmNvK0kwOHNSaTJyTWRadHJQZ0wzRkRQUi9pMEdTM0E1R3FMZGMwbmFXZmhWd3lyMFZqem5VanhCaGx3ZlZjMGc0cFlkU09YZjZ4eW5TR0Q4WElWTGJPK0taZCswTGp3VHN3RXlvbW9YUDJsaDlSeFI1a1N4b1gvSUpkODRLVTQ3R1Vma2hkOEZ2T29UbWVBOWNMWTlJL0c0dmRGK1JMcmZrYXRhSCsxWFBWQkRBZTRaK0pvbnM3T1czV0hhSDdKSk1GMXZWNnVlQWRhNHQ3cHIydy9oQ0RYM1NtYkwrQzV3emo3b0J5L1dlNkwray9OU1ZNdkY3M0h1UFRuY3VGVktITnl2c1NJNUZGa2RVQngwVFhHbGdma3d2ODU5d0RkWDhZQXZUbkZwVno4WHZPU244cUZWL2c3cEZIRURvbmZuQmFlaTY0MXRqd3NGN3d0cW5mRFU1cFJJNHk0WFBaQm1UbUlXYmdxR3AxK21mVUppM1BsYmNheWo3eTBocmo2LzNxWi9lckFmK0hvckZvSFNEUkhNTUIxNzlXaWh3MXV4bG5vajhzRVpzOTRMOXI4MWJrK3Nqd0pSK3RWeHFadnFmNGZlRWUrTGdZZnhLQ2pGK3k3eWVtSDhnTHZPUzVFejlYbW92OHAycStwd0ZocXhQMzBvQmR2Z1dLTHNsVFpBVjV0YkZvbkZ0enZIdm1TR0hoWTVJTmE1YmtHYU9nQnpydmFXSGk3Ykg5TmhRR3k3bWVjTWRodHh2bzdsWm4wOXR4RmJYK3JWb3JLcHdlV3E5OXByUDc0dEhMYmx3S3Nacm54TG1XK1crejdydDhJVVZaakFkQ0hzNVJlOUg1akpVZjdHV2N0MnE0MXJ0eUdMSDB2MXBZYzlyK1dGYnRweERwazcyMW0xK3RVWnI4WWZraU5QQ2JTVDRuc1BoWEc1elFSaVVxdWtIVVhpcFpMWk1zVnNtNUpCUnB2WCs5ZWFienloV0RkdnBnRExDL2xZcDJpOTdmTnp1dFZkcjhZZ2dFK3J0SlB5VnpKQUhVZmRaVllKZXZPbHkwWGk3WXJaVExhQUZuM24zTlFmc1hxaTNtR09TTlFzUzY1N2s2amZxM2EvU0dmQjl1T2ZNd0NNZHdKWStYZmlZVnZtMGJyTWUyVG5qOUE5YUtOYnU0QndsbzF6dnV5YXJoQTdma3pyTU14OVFDTnFEMERhWUJ5OVQvSUJiZmhrbVV3emxaRHYxSGFhMTg2WG9kc2FoTk5GOG1GT1d6bTQyYUZsL09KOUpHaUo0N2xiYkRjekhnVml0eXNxNWdiLzh0RHJGMkNFOSswV2JwNmdFNFdkME9tQnBnUVpxTHFBYkx1UDlmZ3VYNDYrb3VYSWVjSVRZbzN4d21zUnJuc2c2TDlLbm40THUvb0Y4UmtVRFZuQkt3RE1qUWcvUEEraGVPd3lyYjM5OFdDdDhJVUw2dEVIYi9INEl0bjJlQlZ6WmxETE8wV3VmSlBSZnVWM3BHNzFMR3Zxa2todzBEY3FRUDBnakVhZW9BTFBpQjZiMzNwRkJReEdPY1FwQzVoVDBicDk4MERuSGxvcFJUUG9MUGI2ODhlRVVNL3dVU1ZGeTg5M25PdzdVVGpwZ29mYzdOcWNwY1llY2diK0xFWXZ4ZGozY1hwT3R2Vy81SlNOcjNlYUw5V05WK01kTUpHaGRZWjJPSjY5RUhVelMvU2pnRDYvVVhSdkVVMm5sZHBnR2sxK1lJYy9nVU1VSTNmaHlrMnhVRFR5NmtCeW1TVGFMNWVkbHlEeDZ4YmlkMUlHUXdHNHlWbFZyRHVaNXg1WlZvWVFvTGI0cURBUHRPVHVzTzJwdWl4NnJHM2hOVWk3ZVlhTnFoZVFpZ01xdUtZY0lad2dNVUpqRXhJUFVDN1VjUTZoTldxQjlqQ000SEJZTER1WnpBWURBYUR3YnFmd1dBd0dBd0c2MzRHZzhGZ01CaXMreGtNQm9QQllMRHVaekFZREFhRHdicWZ3V0F3R0F3RzYzNEdnOEZnTUJpcyt4a01Cb1BCWU4zUFlEQVlEQWFEZFQrRHdXQXdHQXpXL1F3R2c4RmdNRmozTXhnTUJvUEJZTjNQWURBWURBYURkVCtEd1dBd0dBelcvUXdHZzhGZ01GajNNeGdNQm9QQllOM1BZREFZREFhRGRUK0R3V0F3R0F6Vy9Rd0dnOEZnTUZqM014Z01Cb1BCWU4zUFlEQVlEQWJyZmdhRHdXQXdHS3o3R1F3R2c4RmdzTzVuTUJnTUJvUEJ1cC9CWURBWURBYnJmZ2FEd1dBd0dLejdHUXdHZzhGZ3NPNW5NQmdNQm9QQnVwL0JZREFZREFicmZnYUR3V0F3R0t6N0dRd0dnOEZnc081bk1CZ01Cb1BCdXAvQllEQVlEQWJyZmdhRHdXQXdXUGN6R0F3R2c4RmczYzlnTUJnTUJvTjFQNFBCWURBWUROYjlEQWFEd1dBd1dQY3pHQXdHZzhGZzNjOWdNQmdNQm9OMVA0UEJZREFZRE5iOURBYUR3V0F3V1BjekdBd0dnOEZnM2M5Z01CZ01Cb04xUDRQQllEQVlETmI5REFhRHdXQXdXUGN6R0F3R2c4RzZuOEZnTUJnTUJ1dCtCb1BCWURBWXJQc1pEQWFEd1dDdzdtY3dHQXdHZzhHNm44RmdNQmdNQnV0K0JvUEJZREFZclBzWkRBYUR3V0N3N21jd0dBd0dnOEc2bjhGZ01CZ01CdXQrQm9QQllEQVlyUHNaREFhRHdXQ3c3bWN3R0F3R2c4RzZuOEZnTUJnTTF2ME1Cb1BCWURCWTl6TVlEQWFEd1dEZHoyQXdHQXdHZzNVL2c4RmdNQmdNMXYwTUJvUEJZREJZOXpNWURBYUR3V0RkejJBd0dBd0dnM1UvZzhGZ01CZ00xdjBNQm9QQllEQlk5ek1ZREFhRHdXRGR6MkF3emdhNG5qZFRLZ21oWnZ0Vm5xNjAwNmoxMjA2eG1DOFU4QUJLLzA5RDZhdXlMZE0wVEJFY1c1OEVKU3Y4eDlQd2h5bWxBZitUd3JJc3cvQS9YQ2dXWGRlRkR5ZGlNZmhNTGw5d1hOZEd4T0FzeXZQZ2c2N2o0RUgwZDB2dlJ6d2VnMFBSY1lyRkluemN0Q3c0dXo2M25IRURUeDI0T3VYMmxyazlTcXVLOEZDcTVJaXk1RmFJNmM5dXhnV0V4MWZCNGFZT09OdHpyL2c4b3orK002THBTcSsvd3VubW1MM3FsQmt1STQ5Rm5Yclc2UTk2VmhoemZNQXE4NTB2ZmZGTEF3UDlqdkwwZEZlZVV2cEpHVXA0aG4rNU9JRmhVc0lMVHdsOFRWZWpyNUlXQUV4WVdpbndIejExOFUwYUozekdFd3BXVFNxWmFHMXQ2K3JxV3JSdzBmemVlVTFOelJHZnhNNmRPKysrKzI1REg1RnVBdjIwVFZNYUltR2JNY013RFFXLzR1clM1M1ZjWlVxUmlobTJaZFVsRXhsWXpVVVhwNkJTcmlQeXJpT1ZoQThZaHVGNnVDSmQxNE5qV0FZc2Izd0gxbHFoS0IybDRuRFpscUVNSFBhSjBiUnQybzExeVFiTGJHcHV2UGlHTjlqeEpLN0diUHJrOC84TjkwQ2FObHdIM0MyNGlmaVE0U1g4dFpBM0xDT2J6cHpvR3hyTHFhenI1SXFPYVZvb0krRHNyZ2V5cHJXajR6V3ZmVjA4a1poMStLT0hkaFRHUnN5WWlYZVpwaVBjZThNUUJveEFldnBrY0Y1NFF2cmhTdzhmSGd3SmpvL1BEaDVjMDZKVnNmcEdGRXlGL1BEZTU0VCtTdkRvOEgrR2Zud3UzQm85eFR5OEtRNCtWZjFSZkt4NFdLOElNdEV3ZXRaZVdOZmFFZVhCNWRPVEJ4OS9JSitkTVBDZXdKV2l5RE1RT0VkdzdLNEhUeWJ2dUVXbldIRGRISWhIRHg2Y2REeFY4RUNNQ3JlWXYvNk5iMTYwZERrY2JXeHM3T3RmKzlySmdRRVFsd0t2WHNoQStpb1MxWHJONmZja3pWdWxMeDhuam40SHJnQ3ZCTzZQTU9DME45NTQ0OFdYWEZ4T0RUak9ONy94elowN2Q4WGpOc20wcVhXdEpTODhiWGdhbm44cjhRZUk1c2JHeHQvN3ZiYzFOVFd4dmkvRkMzdjJvZ3loZXlpMW9OQ1BVRDh6UFFIUlI0RTFDYk5SNlhsbzZNZEczMUNCMEpSRzhEZ04vOHRUNnA1a0pqeGlrRGFBR0NoV3kwckVRWFhHSXVxUFk0Y1BmdUpqZjcxMTE1NzZaQ29ITm9DRHN4Yk81eXEzSzVYNm5ldXZXTFJ5dVYzWEtHMGJaN0JoS2ljdkNubVlBWWQzN3QyMzk5QlF0ckIzYURTVmlDOW9iMTJ4ZUg1TFcrdElPdDNYUHdESE9ENHkybGhmRjh2bFZ5L29uY2hranB3YzZCK2ZITXNWSERPdVlrazdVZC9jVUorYkdEdDZkTi9vMkFpc0FyaHlrR1p3MlVYSCtkQUgvK2czZnVPMWRJWDMvTXMzWGE5dytYWFhKUk1wV0thaEpqYkNHeHNvVTQ5dWM0a0ZJL1I2VGlUaUhTMU5jMm1kd2RHeFhMNW8wUDNVN3hnazRYMjk0T3VnRW1VMFpSTEFPN2xDb2I0dTJkSHN5L2FSOGNsTUxxK1BGaG9UaW80Y0doRnltbmxCODBIUlgrR3psbW0wTlRmQk00M3krT0JlRFkrTzAxZW5qRFpmeXVuamlhbjc0MC9DNE5QK1A2VWE2bEwxcVJSOVpHeGlNcHN2U1Bxc25HWmVrR0hrYVVsQTAxUDVna0ZNcWNmd2RMNDZseDB0amJHWVhXWUlNT0VHaGtmenhTTHBjdjMwcGwxMUlJRzgwSm9RMnR6c2FtMk54V0xWNmY2Ly85emZQLy84ODcrYzlRODZENjR2bFVyTzYrbGR1MjdOVmErODZ0WFhYYmQwNmRMeTM5cStmZnNkZDl4eDZ2c3hFMmNSS1BpMlpLd3VZY0h0ZFJ4UTBpQi9DNTV5T2hwanpjbGtTMTJkNjhuaHlSekluYVJsNW5MRjBYU202TWtFeUFaOVA0dktLemdPM01sRXpFakZEWGlXY2RzdWVON1FwSkdNeVFWTnlaUnR1Tkk0UERveGxDNjJOdFl0YUdsWTBwRHFXYkp3MDdXL1RycmZ5YVdQUGZsak41dTJrZzBHT2diU2MxRWJLOE9MV1RGVWJWN0JrdDdnb2FNSGp3ejFEVS8wajJUQU1zbTczcVRyZ3RyTFpMTEwxcXg5NWF1dW0wdjNEKzk1ZHZMNEFTdVJNSlJXekZvYksya3J0SG5BR2dQVEJjNEdkd0wrRldFZXV0cWdnQkdCemFFbmpreTI5NUR1UjB0aS83YjBVSiswNGdybE1JZ0cwT2llYlpzd2ZYTzVqR1hCZ2NEMUFhM253SndDamF4ZmdMMG5DeTY4RGJlMllLWHFJK3IrMGVOSG4vamVYYTVid1BsWnpCdGE5K1BpTjZUbk9LRG9zN2xpTHA4Ym5zeGtDb1gvbjcwM2paSWt1OG9FN1QzYnpYZVBmY2w5cWN6S3JFMjFhQitrRW9VMGRBdEpTTjBEYU5UUVRVTnptamxuZXFhSFh0UzBtRDl6K3ZUcEFlWlBBNGVCZ3VFUERNT3dDSkFvU2FVcVNTV2hLcFZLcXIyeWNvL01qTlhEZDdmZDNwdDczek16TjQrTWlLeEs4V3ZJa0U1V1pvU0h1OW16OSs3eTNlOStGMEtpZ1JjUDNSQUNBNGpDL0poMUJtNjFWdm53eHo4cDM2M2Y3ZjRmdi9aclY2NWQrN3ZhamVmT3ZmbkgvOC8vdmM4THdqQjgvUEhIbi83YTAyL3JiU0dvL2RTblBubkg5Ky80OGp3ZjlwTDAweklFd05pYlNFZU9oalZQMW5FcjQ3OXA5Z011MDJBWjdRbi9UL0VFaU85UjZWV28vR1BzL2xNRFRjQjVZQkJRS3BVcVlIZjJPR0w1MTlOZmV2THpuLzlDMi9OcWp0MTN2VWljTmZnVU53anVYWndOMzNYYUhjeUFUNFpqamhjQ3B5OEttTzlEUGpIY1hHM2RXUG5HeGJVYWVMN3BacW1zcjU5Ny9TL09YVG5mN2lxVkVoZ0ZNUGxIRjJjMnoxM1ltR3JVcXlWcUdET3FaaWQrYjN2enl1WjJPNGg5elZLZHFtWmEzZTFSdTdVUkJpNTh0QmZHb2QvcHRYOG12OEsxRzZ1RFFlLzlINllRTkl1c212SGM4V2Nya3pzSUxwYzV5NzNobXNFMmdEZmR6MzFHQ1RnZVZZWmxlZjRKajRUeFBIektrL3NKbUVFRVgxNFFHTWJZM2NEaWgxRk1pVEpHS2JMM0pPTkVMbldsU2dwMzhDeUVwOEtrRTVHWXZUWGZIeVUrSkczQzI1TkM4aW5mbS9OeEJNakhnSWE4THVtODhlOWE0Yk5pTUY0SUFxazdrSTQwZ2hIL0dmdjhRcjQrenZqektBbkJIVDd5Zy8xOXY0UjJJRldWNkE4dlBNM3gyZ3VzQ1FJUElzOE81N3ZDTUxmMi9ZNVRoaStXcHBNU1BhQVFVRExDVlE3ZVdsZXl0WU5vRlBjWndSV1JwNHRRbVZqQkNxZ2lpc0p6d3NSUDh3Y3NBMmZ4NjB5Q0FLT0IrMnJuMVpkZmVSR3krZm41K1k5ODVDTS8vL00vLys1M3YydXZLOVExQ0lKMXpHMkY3eE9ZaEZLeURkdlFlQkl0TmF5cVlZRzNEdUpZVGNCZnNWcUZOa29RNzlPeWJtbUsyaHFPeXVXS3JsTElMcW1xaEFTU0FQaDFQZlJqY0hXUTNQdFJaS3FrWW1xNm9VT3FxVkZqYXhBWUpYNWkxbW1XaWFab0sxMHZWcDNscFZLamJCNnMxNWJyOXRLQkpVclY3QjZwYnRoZ29BelRnaXdmb2c5RE5mQldGUWhIVk1zdWc4dUVsSHY1MkxIcCtabGUzMnQxaHB1YllGaGlOMlpidzlGZ1pKZmhXaW5aRzRSRXhFTFRETWpIUmZ4RWNMV3BuaWp3ZkJKTndaV1JqMDFobXBJRXFzSW8wYVhKWkN3aHloZ3VVZzJ6TkxzMDNMaXFhaGJETUJsRGNzaU9pS3JoQVlOOEduSW1YV2ZVeDh3SmRwK3FLbEdvYWpvOFpRMENxOWlBNzNqOTdsczE5NzAyWlBCRXN6V2RVc1BpTEZGTEpJRThDWFpGRXVweFRJMVlqeXhxbWRzRFg0MVlxVWEzZW1BOVFsaVFFaU9NYmI3alhlOWRQbm9zM1phVU5pc2w4UHg0blRLV3gvMUo1ZW1BcTAwd1I4SHNYdXc2ZEE0VVUvK0VDZ2NRaXl4S0dDdzBaQkJ6UFB2dFp5OWV1SGpzK0xGOW9EOFprSlZzQjdOOFZXTXlEayt0RllFZHlWSmtRUUlSU2hBRTFlcGJUVlArWG4xaHJDMjhNeEd1U3BwK2luL0tRSUFVRVZIOEN4NzA5SHpKZnhLYXVoOThpdWprRkpXUXZaQmhJaDZCd0tzd0dZVmQxZW4xU283VHJOV2N2U09BeTVkVzRIS1c1bWJoZ1lLeFlHbWdEWHRZTzN4Z3NURS9aMVpxbXFwN3c1NzhFWVRYRW0rYlc1aCs1cldyUzNQVGp4dzdDUGw5bEVSZmZ2YjdWNzFnNXVCQmM3cnBqN3hGeDZoYTZnMXczbXViTTlXRDgzTlRUcTBpTTdzUEVUcHd2WlViYTk5NjllSWIxNjRhcHRPY211S3NFZnJ1Z3FiOGQ0Lyt3dysvNytIQ2phbUQxamI4b2tvUjB1UGdsbktmSnJlbHVISGgwREl2eThlN2tWSkM5dDJjRkkwTGtSdVlweDVhdkw5S0NrQnZ1dVZwQnJlTVhUdVpTRkZ0MDlBMW1vTXo0ejlUUHliZWpkSkNUUm9QY1BZUlhJSUNFUlpIdExkVVY0SXpya2k4bGVWTFVuQkc0d1JjK0svY1pZLzNqdzZSb21FV05oVzhVazN2TVZ2UUhHR1N0OHZ5OTUzY2dxVHdxZG11NVJBQjF5dWwvVkVvSXBCUk1ua2lKdUlWa2lNOE9lYXc1N3RwKzlZMklEclRtSkx1Y29rTFFXRExHR3grTlRlN0NWYWswamdkRmtQVXBmQVVpOS9UVXBCZmhDU3E4RTV5UmZHM0JNSTdOZ0ZvanJsRTVlREgyMXV0My8vOTMvdjg1ei8vTDM3dTV6Lzd5NStGS0dRWEdFVFVJMVFCRmt1RUd3dHBoSGhCdUZTelo4dkdNSWlDR0JIcUtJcmhaRGNyQm1TekpjM1JCQWFGVlRyQ1I2Rkx1ZWFIckd6cVZDUERJSzZYelNDS2t6Q0JuNXNXdm4yUzhKSnRicmx4MzJlSG1xV3BFbVFNOUhvNzJockd6VkxKc1l5cGFubTZiamRxVnNuVWk0OUU1TmtoVHpUQ0U1SndlRk1JV0dBQkVoWmhxUVFCZUR5bmhsbWVXNnJQeklXejA1dWQ5a0JsK3ZVdDUveGFhOHF4eUI2RkpiaGRiK2pGbnE4Ymh0eUZST1pGR0VSaG5VSzRzZ1RCcHhnUGtmZzBocytIWTk0a25oVFdOTWFuY1dZQlFvVWtIUGFITGp4UDB6QVVpSmhpaVBZZ3dpQUpKdWdSL0FhazVUSEVMeFJ4YlQ5R0tBSGZGbDBkY3p0YkhNNVl0amYyK2Vwc3JrSVlYaW9MZ0ViVmd3U3ZoV0hBQ2dHV3FxaFl1SUN0QjliQjFBMjRweUJtcHFsNWtlL0dnVW9nSGxJZmVQZjdkTTNJejA3SjFFb1FycWtxSmdTd2k2akU0VG5DKzRxc0FsQ0Vpbkg3aWVnTG9oZXVpdUlGbmlndXNrV05xQWxQRE4yNHNYcmpxYWVlMnNmMzgvUWp3RytwTW5KTjdXYVNBdGJpWFZQa1dWUzhTTHI1NzN6dFVoa1ZwU05oUTBUQ21PR2swalZ3d2hVeXRteGM3bklGSHdBWEw2Y0t6Mm8zeWhpTG52UkdoYW9xSVlWaXE3Q2xrSGIxQjRPUjYwNDM2bE8xK3MwRlZIaXJxYVg1ei96VUo1Lzg2amMzTzUzVXBURVpSaW8xeHpGTEpiQS9GOCtmRzNVN0pZaVJkVnFiYnBiclpaVVlyM1hkdGI3N3lmZmNGOGV4N3djWEwxMVpXZHY0MkNkK2RLQVp6Nzc0MmozTGMwZnJWZDFVWng4NEd3LzY5WXBkZG15cjRoaVdwVnUyWlR1TG1uYnFnZnZ1T25IcC8vcjhsMTVkM1lnVnNDRWNiTkxISGpuN3FmZmRweGVjTlZpK1NIckhncjh2RWgzR2JqUmRZSlloeHRJbXN6d20yS2VHUFU0MytlVENGaGFjN0VDM1pjbDVzc1FBaHRyUXREQ0tKRFl0bjdxQy9sZ0MxZUo5dUhBbE1uY1ZHTTg0bUJBWEl1QWk4NjFoL29tU0FoWWt2N1E4OTVhUWtKS1dyTk9NZmJ4YW1KY3plQ0lUYVJndmV0eTBjRkZNNzlQd1NNUi9ZMEpEOFNrVTRSTkZDV0Y3aEtGdDduczdwUGhYa1R3ck9USXh6djJGMitmcHlWSnV5L2VMb2dXOGxTZ1o0eUpSeUgwVExtOVNJakJnc2ZFSzBHMkR3NUVaUEdXaUhJUzVlSUorQjdIbU5Gb1IwQW1zY1pKZEZwUG5SNjZJRFBvaEIwd2llTDF1NnJwaWRIdTkvL1NmLzlNTDMzL2g4Y2NmWDF4YzNIczlFdlFXWU14eFA1QkdXWnR0MkczUDc3dWhwWmt4ajJ4YnJWWEF3WHNseHd4WjFCdDQ0SzRNWFEzeGh1alFEWFdxV3FZMjlBTzQyWmd4TDRTOXdteGRzM1hkajhLcWJjQ0ZiblZIalZKcHFneXZKZDBSdjlwMUxVMXIycVpsNnhhNEtZMktmRmliaUo3d3JwTTRDaENUd0RnWFhLbmc3RkFTQmJpVzRDZVJrb0RwTHFTaHh0enMwdlNVN3cwRHAyVEdjZHVwN2VrdzROdWQvb0NPUmxiWmhsQXMzVmdpQ2FJc1RnTEYwREQ3RjVzT1BLc0lNZERUUXp3UU0zRlY4TS9pV3p2VGk1cFoyYmgySldUZ2FPM0lEK0dSUkl3WUptVC9OSWEzaU9FT0lOSEg5NG9UaURvQ3czQmtLZzNySHdSSlozTXJDZ0lqSzRudGgvbXZyNFVRZTBXbXJscU14NTRYOW5xamV0WEd3NldKMmtRQ0VRYkVLeWJFWitETmc5QTFNZTQyaG41b1VnZ2FLdmM4TkVhRFlLczVocVpqdE1NampFbFVlVnpUNG1aYUhrdVVGT3JFbFJJUktwYy9aL0l4UWZDQmhSMFJ6a2J4Rjc3d2haLzVweitURTZsdVhueDUySmhnSzBDV3h4QjZFZlNJTEo3QWpjWFRsMktrY1lkVnV5K0ppV1RGWHVrRVNPNkI4YUZRUnNZZ3JDSXBGTkpHaXlvWHpWek8yUGZ3OFQ5VEMwMm81SUxRdE1hYnNVQ0VuY2N6cUNpYjIrMHdqT1ptWm5iUW8rQjlmdndmZitLNXJ6NzE1SmUvQmgrdjRjTmxxZ2I3Qkkrd1V5NG5VZlRWTDMvdHI3N3hIWGp6dStabmpzM1VtMU8xMVlUVUc5Vy8vc3EzM25IM2llVkRpMWN1clF6YTI5dWJyZVY2dGM3WmpNYVh6eHl0T21EbTFKV043VXJWUG56MkdOeXFDZ2tIeEx1YXJsa1doejBOTzFDamM0Y1dIemg1YkhYZ0JVa3k5SDB3UjhQdTRQSGYvdU5QbEErOS8vamQ4aUx2UDNWc2MvVTZGU2lLQ0tVS2FmZE5GcE1vNHdWT2ZUWWhkRDkyWFpaSEZxQVU5S081dnhkd0w4OGk3Z3kwNFJrNU1lVUdGVStRYVdoQkZOS01wRVhTaDVGR1pubUtUeWF5V0s2TUlRZUVtZC9pN3NKWGNwNHRTSFpIYVVLZTN4Y2RreERIOEh6NmlUc0ErVFRDTHl4Rk1ZMVBWNVdueTBJbWZ6R2pJUlVpQmZTVnpQVnU1ZnN6VHkvampQeGVlRXA4a1RGd01jamI3NGxxKzBkNVlJVXAxamFZUU5JWUZaQmF3cWw4dEp4RE9pc01uS3lpTUNXTjJ2RzFHTXBwUkFNcnJramtSaGJnQkRPRWl4cUJ0TTRTaGhXSUxOcHJGV3RPVE9SU2lBUnF1cW5vNmhOUFBQSHBULy8zZi9SSGZ6ZzNON2RiaUNLS01ScG1ZR0QvNnhYejBFeWxQL1RhUTg4MjdaQWxocXJVeXBZWFJHWFRoZy9yakZ3SG5pU2tyU0VFVzl6MUlzdlFLNVkyakh3YllsRlY2N29lWElXaEdiYWhSbEU4WFM1QjduOSt2Vjh4dEdNenBxRW1RYXhkYVE4dFZaMnZWUTFESzVzbS9LZUN6Q0ViRHU1NGkyTjZxVEZGVDdBc0JMZHZ3RGR3TVNFTDVCamVpdkJIUkZlR0RvOHNRU2NLZnRZcDEweW5aRGtPbzZXWnZZcHc4Qm1ENFVnYnV0UHpjTjVWOU96UzRQR0loRDRQbzlndVV6QWNYS3l6K0NtbS9JTDlCNytiSUx0WXN2YlNMN1BjQ0xYSzluWS9JZVp3TkVLNkVCWXRUSVRMd1hQR0xJamlNSWxnZlV6VERFTS9pWGtZdCtGQ0tpWFRTMEllcytsbzdjSGg0SmErUC9TOXdmWW1lR2lzRmNDbHdSN1RWZFZTdWVUSElZd2tEaVJXR1RRU2dlZjM0YW5BYzdSVXcrUHhhT0NlT252UHdXTW5pdThKVVZyVk5rZUpHbnFCQU50U2NKS3hRa1dRTUJuT3B6UkFCSFFrVG9MSFNDUGp3cUpLdFdlZWVlYU5OODZkUFh0bVQvaE5JVGxwUjVCV1UvdkZCRldUcHgrRjVFSDVwaERQM1BIeGU0SEpJbFZQOHpuSmpremRFWkVKWDZLbU5BQUU2a1d1TDBxcUNtWWRtZVdWdjRidlJuTC9JUjQyVGMweVEraG43SVZJWG9xVjdnVU9IK3lJN3FBUGY4NU9UKys0eU0wYk43eCtaMjUydWpVY3dpOFpxdXBIRVJQd1Q3cy8rTUxUejMvcjlRc2RMeGo1ZnBndzF3K3V2bmpPc00zMzNuK2kyK3R2dHp1dGRsY3o5TnBVZldseFpvbVIwZHA2cVZaMlNqWmtPcVpkWG1zUEYrNDdXV28ya1dDRUlDcVlEUTBoSzdCb3VCSU04b3BEYzgwRHpmcjVqUzBiVVc3Uzg1UHVSbDh2WUd6THRlcWgrWG1aeGNNdHM5UUY4d0lRdlZjV1FaUmI4OHg1R2tkbEZmcjg2V1IrajJlaGxyUkRxVXNTV0dOYUFkK1JoaHE2bnViT0JWaEN2ajR2WkVzZktTczhNa2dSdEc1T1JWMGpBUXRTOUxwN3NlUVFYazBvb1VvQnR5aDhvcktEZEQrNWJrUVdSTXlkZERuSkcyREZMb284ME1tRGgyTGdSVEtZZ2VRMWpoVFNJUElVK0pBL3NiSzZWNUUzNWJWd0NWQ2tnS1pjNXpTK0lEbW1JU29PYWEzOWRueS94QytKcEN4bUJBZmt5QWl3SG4yRGZOeG9RWkhNVHJBU0VGR01yQ21rVUVnWmt3Vlg5RXl3RlpIb2huc0hIeTdDcERudmhwSzB6aWU1MXZBYllFczFyTmN5WVpaVjA3Q2ZmdnFwei8zSy8vcGJ2L1dia3pFVUdsYVJTT092d3dmWkJtMVVyWUhuZDRhK3JVUFdpSlEzOFBNeHVFSXNCaE5JSENFZ2dIZ2QrVVdSRWdkQnRRU1pzdzMvY2t5alVTbHRiQThKRnNWWjFYYUNJSzVZWnJsVWV1UDY5aWdJN2wxdTJqcUY5M3hqZlJnbFNzTnh3Qy9ibHVaWWhtT3Fwa3BGb1lNVjJSVndiU0hqRUxyRDRtQkpHTlpBTXhRT0lVVkFWWTFJaTRlYmpFcCtKdHh5RWd2ZmtaQ1MwNmpPem9IYjI1UHVvSkk0REFWMG41NGc0WVNFMThSZ1F0VHp4amlld0ZUVCtKNGhFVDFCVTFsY1RXTnFhZVZHcXhNcXd5RGtSQTNpSkFEWHkxZ1V4cUpXZ0ovanN4aTJnV2xBdktURDk3MHdwaHJDdGFadTFLNXR2bTk5clRFN3QvOVJkUHZkOW5hTFF4NXY2akZEQW81aFdrMWRKeXdFbDVtRURGTWZUWVBQRHBNWUhxQnNuNEl3MDlDSVRnbFkyT05uN21uT0ZEOEZiREUxSUEvVHlDaWlNc1NYZ1JCV0VMTDBQazB1eGYxTFU4UlNwSkdMY2tpRzFDUGgyZDVxYlQzMTlGTjcrdjRNd0pTbEZnN2hDMEUyQlZaYmtJYk5lR2EyT0pIRUY5ejBQTG5qNkhlcjk2ZDRQcy90WUxhK1BNdFI4WGhJaWhaTkg2YkNNbjhsQ3Y2S3lPZDVIcitwVk1tWmdqU2ptbzh0YUFFVGx5K0N2NnZDenNHNTZQVzdqbVh0S0RKMjFqZVk3MDQxYS9HNVdGd0ZrWTBua2NMUHJXNzFRbDR5clladHp6YXE4TWJmUEhjQmpOZVBuam82WjVhWEc3V05kdi95dFkyRFM5TWxXanVzS043SVZ5R3ZxRlVxMDlPbFppMktFOHMyRnhmbk5FZ2pMRk5tWEVUVlpEQUVVYmVNWHVhV1orODdlZWg2cHdQSlEwM1hwaXFsUnc3ZXN6VFhITHRTc0RBUW5DY0paa0dpRlVzMkJSWnZmdHdLdFJNTVNBT3YvZkxOSEVYamhVU2VGd2x1VENJMnFkTXZRaTljRU5BbXMxRHdwcG80TElYK3dYRWdramxtUG1HaHBHT1RkUVJzUUdKdnhmY25BdmRVSmlGM3poVmxsMVk5bGhVQ2VCNkp3bit4TFdSbktYTzhrZVNWRldLQzNQM3pIU3ROeG9GQkNpcGt4RWJFeVNFWmk2SlEzVHYxSjRYWXBJajVqNXRLaXhFTVQ2L3l0dXI5R1NNQ25BUllmdHhWNE1XNVdFZlJ6Q3BDWnBGV29nK1I4WXFLOUhJQitoTlJLcUNTQ1pCV2dQRDZJSEVVdFc3aDZYa2lXdDVTUkJSek1HazNSZkFMSDZyU3RCeWc2K2J2L3U3dmZQS1RQLzRqanowMmliM2lBd05mUWZIemVMUGtKREhwRER3bWNEeklmaTFiUS9lc0dsVFJJRnZWZFFvZVBZd1RjVEdzWHJIcXRvVW5XV0d6dFVwbjZQa1l6V05PT1BTQ2lxVXRUdGZPYmZTdnRic1BIMnBNVjZ4UVNhNjArb05SQXU3Qk1GUmRWWFNTcUNRMHFRWEpJZ2FZNHAyTFZmbFlzQ1VwejhKSmlFQlZqYXRHalAyRUFnVkpJVWlLL0RzVzY1aXNZK2tqampFTjJBY3AxalUxRnQxNmFXeEdCY01aTXdWTmJDaHNlc0tPdmdRY0VycEFsbGIxUkJxS0pvL3VPTzJOZzhjNlFiemxlakVqa05pN0FlVDJxU2RWVlFLM0J0bC9EQmRKeWNDUElIaUNkNDN3NkJJVGJrblRyZzZIYjU1Nzg5Uzk5OThDOEc5dnI2MnRXNFJIU1FJSFNzTnVRL3dRaXJYeldPQWZLa0g0QkdFSkxBSm9xaC82MkNVUk0xaHpvcW5IN24xZ1IxR1dDOFNvckZ1amtBMjhFSE1tVVU1Uzh4UExoVnNYZmhnMlJzTHplaDArYTlHektCSU94bkxDekYvOCtWLzg0ci84bDd1eTg4UkMwK3lqRlF6ajBCdWxOV3FTRlYzaHJ0U2MvcWY4NFAzcC8vLzhJaG5VcStRZ3ZmaFR1bTllNEVTbjBSczZlaVlPbEdRSXlpSUFTNXNERlRZdTZvdXpRUXNWQU02THZkWnArNkFpUWN6Y1lTbTgyMjA3anAyVGRoWFJrWHZ1d3VVVHA0NUhRWGo1MnVyMkNBd0ZaUGo4ekpIRGh4Y1dTSnljUEg3azVKRmxrOFNqb1F1YjREdm5MN3Y5d2ZMRDkzN213TnlmUGZudHJVRndCSElZeUJZWXFjM3FkclVLQWExUktqdlYwcXV2bkgvM1EyZHJ0U3FjTGtnc1JHbFZ3WkpYbktCSkV6NEdYbGxmV2xocURXcU8weG1NVGkzTUxGVHQzbkFVRkt5RFdyWTN0MXI5VG1kaGZwNUJHQzNTUWFJVUZBRklxamtnMnZ2a3d1WG9jYUg3YlM4UVdEWlBGaHJhaWh0NnZMQzh3THZNRnp5TmxIZHdQRlZkTStMWXp3b0ZFN3g0SWdwenlPUlNKbXJrSktzdllETkYyb045Qy80czVIVmdUc1hMaWtVSlB1WStwTmZQaTVCREhvbkN0UnVhZmxPRUlSd3czWWtsNUpHVXBMS2xvQkpYQ2plbUZGR045QVhwYTducitkYSt2ajhuV3NycTVHN2hTdzdNb01HbmUwZEcrL2wralVvRU00M0s1Q2VKUGh5TXVJaG85RmNseG8vNW1IZ1pTd244Y3FIUnEyUFlKY0I4Z2NLS3htcGgwMVZOOEs2VmROdUoxOGpvVExRSlVOa3lJRUZVVE9BMDNmT0MzL2l2di9IREgvclErR0dMTGFLclNCQ0UzMEljbjlDQmFOdXpUTjBOZkVjM0toQlVZeHBQZ2dqY3FqRnlSeXhKZElOQ1pqdFYxV2NjUzFkVjhMRXp0dDN6QTNnTjdDdnc2V0pMOGJtYXRqVU0zN3pST1Q3WFBOU29SUXBwOTROMm4xaXFWakt3NmMweDlLcHRsUXdWQWdFcXFYWEZkay9KYkVBc1c2d2FGNzZNa3lpSllGdkZBYndmMVEwTmxoRVNYS1FBWUVzZTBzMUNQd0pQSnhadnYyMnRFVWlkVlQ3dTVjQ0FETzBWRTkzUUxEM3FjTUprY0NFZmpZU280ZHY4Sm1yUDdJSERqZm1GdGRkZTAzUVRqS3VoUXloSElCYVNmQ2p3dmpvYUNEV2hHaXhRQ2ZFZlVmaUV4dy94WEFLSE9MbDAvczFiMnZxdDFiV3Q3VzdOUnBUZEFHZHVJVmtod1ZvSWJoSkdFbGtxZzZRQXlaR1lGd3IzRE1rZjB1bVRxWm5wdXg5NGFNS0lVR3BoeHphRUJUbzg3RUVZd0lQSU1YK0JUQ2xaRjNHTzhmTzBxVmZ5aVZqUlNPR1BkTk42N3JudnZQVFN5L2ZmZjkvdUFUaVJ3Z0M0QjVtMHFManlzbDZJcWhWcEF5NFhER3A0bEFTRkNlNTQrdDN4NUxGR1FtcU9NU1ZndWJkSGU1MG9zbmMvTFJQSUpuTkNzclJIME1SU0xEQ3JUeGZjbGpJUjVvcndRVGhCOGVob3JoVWdYMFBqT0hEZFVUbHJmNFd2ZXg1NWVIWjVJUnowV3lzM1RwODQ4dnI1eTMvMXpIUExpM09uRGkvZnVMYjV3WGUrNDlFZmV2ajg2Mi8rOFZQUHJYWmhiOXRnZHF4S2RlbjBLVnMzM3J2UitjdG5YbWlXN1hmZWQ2SlNyc0NSTWJCV2FNQjFQUGY4UzJBMTN2SGc2U0RBaEE5M0RCZ3pDRHJBQkdHdnEraGhTSklvQ1FJLzhGMXZ1bHlPWS9iUS9XZW5hOWEzdi9DVjdiWFc4VHdUTUUxdjVQYTczUU5MUzFGRThtUTB4ZG9MQ2VBNEs4eEt4dUxFOFgzcS9jVVd1Qnl5SmhQQkd5OW8xUEJKaG1WZVhObHBjTUJLZTc1ZnFNSHpBZ2d4VnVtWUtKTlB0TkZqUm5wTHFqL21ZK01BSlZNdkdiZmFGWUtWblBvNHFRSmczdVNQU1I1TWtRSzlQK05EanR2OFJPaEplY1pVekVKTnZnTlBTU01ONmdmUlJKbnk1Z2hNTkxjVTBBdStnMlN3YXl6eXRuMi9MRWpML2h2czdrc1JlRHhiMkRjbHVWVHBsa3JTdGc1VjVqNlFZV0U5Umh4ZlNZckdTRTNIM2hpZTNwdmdXc05MV01LeWhjcm9QbWtkaEVzbW9QeGQrQmVjaHllZi9PcXJyNzU2enozM0ZKOGwrQ0FOdTN3d09uRzl5QTlqeTFReFNXVjhldHFacnBUNm5nOXhBM2pGNFRBMFZGcXk5U2lPRjJ2V2JGVTFOUzJJSW5EZWZUL3hmUlpIWEpScndaM3d4WHJOWmVwTDF6WVc2OXI5U3pXNFBZajJ0d2ZZb1k5QWdvSGtEMHZYTE0wb201WjRHZ0toUzVoU0NGTGhuNk5oRUhRalZZUTljSWdKMVlTdFFacHl1ZXlvYWtwamlRVlpETHNuSVRpQ2wybGNSYlIvdndmVWJGU0dVWTBnTXhhQ0RneUFCSkVBbkNRVEFWcVNxbTlnL1U5QlBBYVhHb3VJeUtkTVlsSmdSNmU3d1RTUDNuWDMxVGRlMHpSaUtieXFxMElYUVVVQ2tUaTVFQnpCbTNhRHNHeG9wb2kzZEFNcGt5cldnNHhwTlVtMjFtOXA2UzlmT0g5OWZUT2FhVkxOcUZJRDBpY2s1MkZjSXU2RVVSbFF5NEtsNU5iQ2s0M0R4SVFyaVlJVFp4ODhkdGZwSFFWank0QW95TkExYmFoQkhHWkM4TVFGa0NBOWNjTFNYQkJUZjlHWmtGYVBKY2xZRksvU1dFRkp1ZU5nZndlRDNsOTgvdk83K243eG9HTjVTbFJSaEJaRW01UkNsdkxNR1RNRjhUTm1zZ1JBMVRzOC96MmRQODlFVWtRZFNxSmg0M2d0NVZla01EaEdvdEw5a3h4QUZhYURLMlBoRkNXUENncTlaOFg4YWFJR25rTE5PV21kY0cvUzl4T0U2YTFubm5qeTJKbTdsaGRudi83TWM4ZVc1dzh2TDQzNm8yRzdOenRWdVh6Ky9PTi84dGNiRVhmSzVacFRXakMwcVFNSEtzMnBZYXY3d01NUEdhYjUzUGRlaFIxdzZ1aXlZUmxoRUxWYTNSdXJtNmF0dmVQQkIzQi9xaktqUmV4UUZLQ1VWQVFNWFljVzhXU3cyZTUxKzY3bnpWVkw0TmtQM25OYUQvMUd0VnhJMVVnVXhiMytrSTVaOWVPV3IxUjNxdUNSU1NHQkpjcUVPOXlWTGlkL0twTTZ5YStrS1ZzVy84UElYcjhsVWc2MFBydndYYkRQanlvRkhhWUM4WE9TcFZqRTl2Ty9DTkx4cmVOcHFSNnh3MEZPT0YyZTZ2a29HZHVBWk9WMTRZQlVZemZPTDgwNlJZdVhYaUJSRW9WUE52ZG5RUWZObGkzVC9rcGxHQVFsSy9iRHdMSHN2U0d5WFZ6N0JLdGdCNFh6OW55L0NLVUZaa0FRNm1kWURLT0pKTzBMK0JUK0VrUENxbEhKMndNWGpEZ1ZTZThoWmVPeThZVkdpZVJDWTdKSUJMa21PNnhqS2NDTWtFWmt5NTlNK3BWTWkyTTQ3RC85OU5PNTcwOFBpRGptaUU1ekJSSnF4ellKOW5rbEM5TU5jSzR1bkxNSW5DbG5VV0NpMGg5U3VwZW5TZ3VWQ3VleEZ3VGdOb0tFREwyK3dsVXZFRmtzVldjYkZVN1VsNjYyS1VzZVBEcGpHK3FsamVGNkw0QW5wdW02YVZqZ2wwc1dDZ21JT0F6U1l4ckZXR2tUek4vMGx1TW92bnhsYmJ2VjZYamNnYkFjc21NVTlrR3NaT1JpRkZJMkJ4QzVHQ1p0MWtxaTRSWHUzRWlpU0pCOWlBajcxWDJlbmwyeDQxRlpVUTJHelkxR2lwdmlLbXBJbDVEK1hrb3Q4TFRQTDBIYUpnbWpRUEF1d2ViRU85N3p6Q09QblAvR0Y0S1lXeVViVXYreVhlSGlYZkNaUnVBMWJZd0lxVktySXZBQlN3ZUJsS2hrYzlXa3ZXNnYxRkFpMzlQMzJydmlNWGMzYm9EVjZQdUJ1OTQ2T0R1bFZTMERCUWtRR0lrVENSRXBFVVluaU90S1dVa2thU1dSaGgwbi9CM3ZlcTg2V1h1RHEzTXNyVjdTQTRVNHBsbUprMkdzQkhEaUJacWl5TVorb1d0STAzWWlCQklTbG9xZlRHaDVLQ25GbkFscTNwZWVlT0tYL3BkLzdkek1Yc3dPT0JYWExlVVVzVnREbWkwcW1jOEVRUkZSbCtTeXplSU8wMzlQT0ZsbThUSllKYkx5ejVTTXJTNlJTOW1aTHN5QjRMSXhrblVIVUNsSEtTTTVucFVPeUxnTGk0enBRVW9xZXBObGJDVHJ2Y3JrSHlVMWhrWkN2V3JjNk1GNUdFYWFSZzhkV3J4Mitlb1BQZm9lT05lWHIyM2RmOC9KelkydGwxNS9NeHdPRTFWNytOVHhqZTN1d3djWDNqeDNMcWFLb2FwVVpKMzMzSGRQbVpMWFhuM3R1MXViZXEwS1gvVkc3ZTR6UjZjYUNQVmptRW8xVVQvRjlsKzRuRGlLOFBJMFZSSjFJOWNINithNjN0RERUaVUvQ0gzWGhSc3hxNVV4amNaM0wxNWJQWGx0aFN2dlN1bnh2Smd2S2ltdFhTTFpHRzB4cWJhcWpQdnY5NjhBWjlpTXdMTkpmbHgyTksvZlJEQk1QNDN2UWp3VCtvb2FMS3p3TXp6dnA4L2RQMHVmS3FlYzhBTC9QejlLY1p6Y2t1U1Bsa1NSeExVeFY3RVlCSXdyOEVXdXZzdzRFVUkyMUpzSTF4bFhsRWg4TDVHMGluRTVudVZJa3R4dGlPbW1tR0pPWTVFdVgzYmtwWVZCTUhlZXY1L3ZsOG53elM1L0RJb1V3dHJjZTc3OWVqL0paTENJcEdxSWdGUk5sVEhTSGhJbGw2N0dDblVhSG9wY0t3eENLV0NiSkdFdVo2U1pscVZoNXN1eWJsRVpsOHRvTnp2c0RKTXprcjdSV0p4STNQTWJiN3l4SThZQnp4UUZBZGlERVl2QnRUdDZXZFZOY1BDV1JvWWpGL1lHdUJGa0RFREdieEk0MEpWU3FWNnlJTE1mQlFrRXk0Nm1yM2VHVk5YNjhPS1lWY3ZPVEJXc3ZmUEtqYzdRang2OWU3RmlhbHU5NE9xMm15aXFTVmpacExxcXFCb0J4dy9lV3RQRkVuR2s1c0w5bzBKd2RvakFWVWJZdWc5ZUNmdmk3SnBUY1ZCTUVKeFJERmZtUnFaaDlrWitiNzNkc0xvbG5kb1FCRXlYNGFNckVMNEljaVFzSFJOOWdMdVRwT0FDRElPcWVvTHhxdWhVbGs5RzFWbEs2a1A1VDBFeG8rS3lLRktVUk1PZjNLRHNKaW4xeGFNbkR4K1pEWWM5MjZub0JoeE5FdmdSUWw3Z2tuVk50eXp3dnFxcXcvOVVDSFNDR0c2U29QS1BDc2Q0Ym42QjZHcnNEZmJ4L1dqVWVxM1phaVhVTk1qNFcrMmVvU21PcVZtNkxvVTBFZjhuNHBIaFgxVlJQOGRHQUJwUXovUHNjdm5zdysrOGVhZHFLaW1aV0RSeEVqTHl0ZGpBNXBRWVZaa1QyV2hQSjBMSjFCZW41S0V4SXlubEQwdWlBTnpteXkrLzlOeHp6MzNnQXgvWUMvTlBhOVZpTVFVMmxralNHY3NLbkV3bVNTcTVSY1BOblM5ZTVIa3A0L3F6ZE5nWmpFeVV2Qmx3ckZuSFJBK0hJbHRjWmR1UVFLcHkwaEtSbGdWdG1HUnFaUER1V1AybVFNWVcxaGhMa0VuQjl4T2ltOWFIUHY0eCtPN3lxZFBYcjE3LzlWLzlEZDBxLzlqUC9OU0Y5ZlVMVjFacWhtRmIxdDN6VTZlYkZUME1acXIxcG1WSFFZaFNHa29ZREwycHFhbXpKNDhQK2dPbllzMHMxbXRUVTl3dy9FNEhQb0lZSmpIVnRJQ0VHWlJrdWtnSkFVeXNJbFJ6VXdLQnRmWUdRNnFwNnhldnRkZGF6dlNZNi9ldEY5OTQ2ZHo1aHplMmVGb2VHZSszM015bTM1enc5YkpNaWRBZzNhL0ZEMHR2R3NtVjlUSXVtNUtxS3hRQithTGp6eGdVc2t0OGx4WVBVOWVDTUpROUdUc3hnNnpWb3doVDdNaDZzWmEvTDVGR1lnTmtjcHJBRGthaHhPRloyaWRWNU9XakI5eFZFSGVDOVN1Yys3alVrZEVwMHBYTlZDcVlqRC95M3NCTUN6bXR5YVJpaU5RSEZ3TEdkbGVhRWQ5dm9FQld0Wng0RUxlTCtZOGpJOGJUcHFaRTl0dUdJaXVTeGs2UlJXNHA3U2p1Rkd6MFF3OC85RzkvNmQ4b0FtTDFQTCsxM1lKQStObnZQUC9pOTE0SUdETjBFd3Q0ak9sQ2VUN21rYUIrMEt3V1N5VVFnNVIzR2FDTHNGeUk5Q2dyVjFhaU1OVFQ1NEZHUEZRaVRBUlI1Ukd1ajNXSEhpYlJlSUppeUJUQmUycTZBajdNRUh6eGltRk9sVXhIUTNWWUkxWnMwOTVvOTNHWUJqYWJLV1ZIcjlhTW1hbnF4WTMrMVkzdSswNHRIWnF4cjNmY1Y2NTNSaUdybFhSVEZRNlJVdEhNaDhVRzhMUHdKNnlBRnltMlJ0bFlPaE5iZFJ0ejAyNnZHdzY4U3h2YlB1Rk91VW9OTFdMS2tMbER6dWRxSlI1RXFLblhxTURWci9aNjE5c2pjRklIWnVvTDB5VkQ1M1lVN3JPdnNWdFB4VkFDMVhBZ0tOTk5yS1BRMUdSUTFSRGR6REUra2tRa1JFTHFsSXVxUkJLSFJObGxjemoxNmRNUHZidC82UlZpV0ZTVUp6Q0JSVGllYUlhdUNKZ3ZRYmhLWGtHSTJnU1FReXRhREE1YWd5eUh4VzVmYWN6dTZmc0R0MDc5dXhhbjFvZmVTSTBISTcvVkdUVEtWbXlHbFRMcUtjT0RnWlJMQU9RWSt5Q3hCeVVYRWtOVGUzRTh2Yng4L082enV4NUJmQ2hFRGJUWU1ZanJNMGpSUWtiVGtod2RKeXFwNlJNaVpiTHZTTWo3cDB2Qk1xNGYvQVdlODJBdytQS1h2bnl6NytkS2ltY2xzbWxRbGIwcUhCV1ZSTzdBSUY1Qi9TTkpOS2ZGZHZNN1gvdldHWmx3MHNKbXB2SVlZd2JBQkpJc29qU0luaGRuNTdLeUlKcURLQTU5MzNNOUwyMFdsVVV2a2U0VHljK1VhU1hOS0lWNTRwc25LQmtEUEk0aDZyVXlUb2xxV2JZbTVQcDVuMzd4cjc1eWNXWDF4RjJuN0hyekU1LzQwZk52dk5HK2ZFTzljc01oY2Q4ZGxHdVY1dExjNHZJU25sSGJValJWaURzeDIxQkgvV0YzdTVYMEJ4SHNtRXJGS0pYUytSbE1zSjR4U1kwazd6Vk9KSGtFMTBRRFo3KzYzaHNNd1A3Mi9DaGtyTkdvTEI1OFJMWEhpTlJMNTYrQ1dWNjdkczMzc2I0SnhuTkh4L2trVGEyd3BIS1JLS1g3N0UrT1RRMHE0WG11SnpPTmRHQ1JRdkttTFg2VCt5SGpjc3N1dUJkNFZ1cDZ1M2NWNUZYdEZBQkl1ekp5bEU1RTh3Z1Y3cU5JeUFUZExJWFdKN3NNeHdFUnphVUVkOEhwY1VySVhxMFBYQmxUVkNjdU9PMjU1N3dBTXloalRrUXVSMFZ5Y29Da1lZcTB4dytDa20zdmlyM3NpaDBXc1paaWZDT3crZHZEL0FYdm5tVDlsRW82SllCajQ3ZGdhWXJJbENlVHZSeGk0WkxscGFWUGZ1ckhkN3hkZnpENGd6LzRnMS81M0svMGVqMVRDT2FKTUpJaGJUZWREU01OSjQ3YlFWMEF3US9JTExKSVdoVmxzN1hsK1o3MC9mbDBGamtTUmxSZnVIREZWSkZWWHM1TmxOM0IrajBSRWZoTXlaNjJ6YkpsREh5LzdsamJ3OUFMMFE3MHhZRnBWSjNsNmFudGdmL2F5dWJKK2VxWmhmTEE5UytzdVcwM3J0b0dyQVprdnBxcU81WmhHdUQxOWJMdHFDUkNzcnF1WGR6c3pkY3JkVjNOdHpoY2dEZnNRY3p2aHRHMXRhMXpWOWUvLythTlpxM21oOEgyb0EvZnZMaFNsY09PaGtveVd5NmIxYXFCVlk5b3ZlMjJ1Nk9wc21vMzV2YlIyZ0p6SWJsS0VJZHdncmsrK0g5RnFOUklid2pQRFRGelhCNGRhK3JTV1dGUXhaUElGNFgvblhrLzFmVHBJMmRIMTgrckVFbGcvd1hXSUVVaEhtSXZEZVg5a0xHWnp2VlJZUlV3NW9wRSt6WFdPTUFlZTYyTnl0THh2YTdaYTI4MVNycTExSEQ2NWxaN29NYlJ5QXZBTmhxR2s4UXh3YWxMU0VjZ0tOZ0FRUURXeXNIY3hrUUxWUjZFd2VIVDk1WjNHL1VFNFFHay9oQnNtYUZTTWJXUm1RUXhFNE9SWXJGUUtQMGtvWGc1Tm1Zc2Rpa3d3VlRuTlZQWHpocUw4TjlQUFBIRUwvMmJYNnJYNnpzSzFHU0NVa3V5YjZaRUhGa3JTNUdydEpWVDJjdjgzZm5ha2ZxbityNHArQy9wNWJ6WXEwWXpKUm53a1NWbkZ5VlUxM08zV3B0QjRGT3NUS2FtWFNBRWFKWWhva1NDVEpwR3NUejQyMEZkbjBERkpLMkp4V0R2eXRYSzhxRUQ1YklkdWFOLzlRdi82ajN2ZnZDeGovNFk5YnkvL3EzZkhnejc1VWIxME1rajhZMnRoYVg1MEJzbEFaTHhCeHNibyszdDdXNTNwbHF0MTJvUUFaUWFkUjAydXVmcXBSTGs4VXplRVdKeXlIdm1PQ1VvYlQrSS9HalE2UVcrQitjcndXbDk1UEtWNjJmbjRITk1GZ1RGVEFDT2pqZkN1S2RjcXFUc1hxVklYNS9nZ3ZHVTlhSzgzWkEwS3h1a1FubWk1c1dwYU1QTUNMUzdsbldVWGZOekU1RkxLbGhmSkkrL0p3UnJKN2JHVHAwY3VHVkk2NDI5WFp6b1JXZXAvSFBoeHRNNkQ4bDBua1JoaVkrRmp6TFNMcGg3WGQwTGZsZkl4T3BsTVdqcTkxazJVQ3czRkhrZW14WWY4cFdVWm9STG1JRDd2bit6N3k4cUFlOG9mQkN5WTNnQ0g3LzJkalY5QlpZbSt2UXdsWlR3aHRES1JoMmVKT0Zrek01VjFiU2JTUklySUdTV2hJRGlHMVlybGYvaEYzOFJuc1cvL3AvL0ovaDFWZFBrY3RDc3kwc2w0L0ZROG1rUk10NEg4QVJRL2o2SjRqZzlreEdPbHNIQkZVSGhESWdwYjZxdEtSclRiUXVTZTBqL0tNVHNZUEtiSmJ2cEdDcG1oRW5UdEVlK1B4aDUrSTRzQXVkUnNhM2xxVHJqMnF0WHQyYnI5bnRQenJwQjlMMXJ2WlhXQUJMc09BeVZpTnNJRFNXSkJzN0lVSmxCb2tUSXhpTTVzNnl5eTFkdlZDcVYvSUxqT0hudTFmUFh0cllITHQvdURueE1aelgvMGxYWWE1RGpCcUhmNjdkTHB1V0d5Y3I2WnMwMm05WEtpYVhtVXJPaGE5aWt0OVhiSnBlMkhrcVl0aWQvbGNQZFE3WXJRRXhZUEkxTEpSbXFack02bUhob1ZDQmFzckFpcVJpY1psTlNibjViWis0ZzdQblFpM1dwVHd6dkxGVFBFaTRuM1dseUVoNUtPNHNhVm9Ma1F1eHNqK0hSaHRGb2UzT2ZUUlgxTncwRG9xd3kxYWloRTFOVnQzdWpTTWdJaWFZVVBLaUNSNEtYandNRjhIbUQ1K1pnOUdDUDNYWC9PNHVkVjdsOWtIcXdTWXkvYTZQTWcrSEdpYzhTaVBya2hwUzdWekNuQkVySnBJRGNPRjRYOUZPZWVmVlVNdDR3ckJkZmV2bTdMN3p3b1VjZjNWRU95eWpCZ3BBdWUxTFNhclBVMWhMbldqU2lpWUdLVlBnU2ZxZlBidzhDVTFIT1hUNFhnVFZ5eWNpWFEwQmxMeXNyQXN1aWVNUFVtMlNrSGR1Wm4xMVl1WEVEcXpBeUdpT1M5Sm9GWWFLZlJKRllkNkYwelROaE9lR0UyVVFhaEtxY21OQUZVZlNaZi83VGozM2tRLy92SC83SmxkV3RwNTU4NW0vKzVxdjMzSGRtVmpmS0ZXZGhhVW0xeTViV3NVbnNRUWpmNlNZUStsOWVlZnlMVDMvM3h0cVpadjJmdnZmQmVyMlNIRjBtdHBPTTNDZ0lEY2lqc0gxYU1zTTVqaHlMRTJIa2lEY2FlWkIvRElaWFZqWjZJOWRVeWNqMTI1dWJsMTVUWitGNGV1T01HY1V3NDZUVDY0TlZWUEs4TXkxTEZUVnp4bjVvTXM5aisvQlJ4TlptNHhsMGFXWmMxQVNRcW0wcG1TQjdyaVFUYUdhc0tKTmI5RUNVR3BybTQxZ3ZrbU1HTytVSU13MUg2VGJUMm5vV29DR2hRdDl6Q2s0VXg1bjJTUXBDN015UHBROFNibHVPTFMxK3RMSEhwTWV4Zk1GdXJQc2RkTkxjNjQvL1NaVENZTUt4aXBIOGl4OUdFMXlUUEFZaXlvNEMvNDZTLzAyMWdOdm0rcVdsQ3lwRitiaW9Oc25oUERTRFhGSkdCajVaSnZwRXNORS9aM2pzK3RrLy9VOCs4N3UvOC9qTHI3N3NDRjBuOFJtc01Ja0RxUmtDems3NU56dGFPNHJ2K2NBRDkvL0diL3htem1GRjFvK0tiWDZRUitvNE5vOFltdmpUTlA3NlQvL3cybXZmeDJZOEV6OUZFNFNzemI2Zk1BcUhMMHBZM1M1TjFTczF4M3JtalJ2Z1VuL294QUdpS3E5Y0g1NWZHOEhsV1VUNTZFOSs1djZISDlaRlJ4bTh2NlZENktLTHFuZEduaVdrMVI5VktqVWpxM2E3UWZpMzU5WldWdGNYWmhydk9EMTM0c2pTZWkvODJ2Y3YrYUcvdE5UVUxUMk9lS2ZiZzdkcVdCQ1JKT3U5cmQ2d3R6RXpPbnQ0dmw0MkxhMnA2ZGF1L05qODhRaHRQcUhPaDNDaHdPS3BocGVvQ0ZvZmhnUVUyOHdaeTVLQUJKMDFoZ2NLMjBQdXVUUnp3RzRzRERmWFJjb3RTQ3JwWWFPaXlpT3RDWHA5SEhPSTdRTVVmRGVFZ3JBaVRBbmNia2VNYnQ0OUVoKzFOeUZXdDB3TGg1SW5jYU9KanI3dGhuNFFPRHFPWEJRcTdkamlnSWNhR3docExLcnBLdUhWNXRUeHU4L3NhcGtnamRNUm5jTnVSbDFKS3BBTkVIT0lPbGxFVjNVdVJFQ1FrZ2pQVzlXazdtVE1KUjR2RUNPaGNVeUVTaFV5QTBVaWdpTmZOYzExaDMvK3AzKzZ3L2ZuQnl5Qk1CTTVDYW9jSEFBUFMwdERFOEVZd0RGQ2pHY2VaZitPemIrL3ZwK25YS2UwY01KVE5FdnFVK1J6eERKc1hnaG9qYlhZOXFTb21hWlpMcGU3dlo3cyt1T1pneHJuU2NMWkpKbXVQWkhxRndXMmYvRjBsTXBWZ2YrUFlmU3pEenc0UGJjWXhrbXpVZi9HMTcrNXVkazZmZVRnVkwyNmV2Nk5xNWN1THl6TnJKMDd6LzJnMTlyMmhrTTQyTE9XK1NOM24xZ3EyY3ozVld0YUw1Y1Z3OVIxeU4wOUljTUxXUTROSSt6bGF5d3V6eDQ2em5DNlJRSy9Hd1NoYlZySDN2K2h6c2lERjBMR1VpMDVjNlkyVXk4N0JZVXIySzZxYnJUYjNVRi9zTEN3a09Ba0VaeEVLbW9IYVdPWVJQZFpCaThYOFlCVUdIUWYzcmVZOVpQUDZNdllsZWxaa0RvejZSd05ra254S21NTm16M3hCVUlzM1lSN2xNbDNOcE9rWVBOSlZwd1RFUnpuUmRwaEtqNjd6KzdLOVRSM2c4U1prZ3Z5amRzZkpvcmw1aDdGL29KRTFLN05DRHliWnpoZVZUNHAvSnRwSTQxakhaNTVRYmhtY1AvbG01c0xlTEU3WTR6ejM4enp6NHNJL1BieWZsbTZTYWRkaUd3c25ZNHRDbW1janNzYll0b05FNjJNT1l4RTk0SWJhdlhha2FOSFhucjVlNm1nYkM3RUllSU1WaHk1TG9pdmFVU1dvcWlLNDVUeTUzSGt5SkZmK0lWLzhWYnN5NFhYWDdyNjB2T2FSc3UySFlRSitPekxyWUVjbFF2T3NxenJqWkkxVmJNdmJmVTN1dTdEcCtZYVpmajc0STNWRHR5NGppSkY0U1B2KzZFUGZmUmpiOHVvWWN1NlN1NCtPdmUrQjQ3Y2MzcHhhdXJ3Mzc2Nk5qVTdVSWxmYlJqTDgwdTkyQ2E5anVOM2FSSnFGdkZ1OU5iV0JwQUpLRWx3OXNoQ2laQnkxVkNwdXMrMmpoT2hKcVJpWFllb0dnN3ZTcWpVc0V1elV4UVQ0a0k3Ri92U3VKQVBRcmNiUml4T2RvL0VUVWlhRHZjMk4wUWNSVE9HdFlCMlJJd1hpeUZBY240bEZ4VDlPQW9GNXdyOG56cnFkb0xod0t6c1BxazI2R3hSbkEySVlMNUtESWg3SXR2d21PSUhPQ1JJczFEblMwVjZBa1p2NEZleDMxWDJjVVRoOHZHenkwZFA3RnJTUzVCRW9xR1NnWkExS01VMGpFblR0dHNqTDJaQ1RsOEdTUVE3VTNTVnlNaFNZSVpDM1pEU1BBZElDMGxaVUEvci8rU1RUM2E3M1NMc1g2aVZDcmxRNUZ2Z1JBdUVzcGgwL0lpUlJFSTdFTThPeHN1RWt6dUEvMjYwRmNKVnlaRVFNdDZaN0RJWmQraG5mZDZFRkt1cm1WVEwzb3RxbTBZMzIrSnlxbmsyWHluUFhITTNML2Q0eWx6TDhzL3gwWU5vVlRGM1R2bGJYRnFXZi9rSC8vQkg4MisrL01KM1M0NTJZSG4rM0hNdmZ2dmIzNE8zQ0lNQWd1Z0hEeTlwWmFmdnhjcE1rMWNibzg2b3M5NjVzYjV4WTd2bE9QYWg1Zm1qSjQ1Q3loTkhnVjJ1eng4OXVlT3pqcjJGbFF6Q2NIMWo2NVh2djd5d3VQVG1sV3RjMDA4c3p4bGlVbVdPTVdkejVpVDlqcVdZaXBCUzBmWXBEb3VtWkNyN0xMSytGcW02cDRtNXhUanVJMjM3bG5JdEluNlRKTmRVYjVUdGxZYWl3SG91NVorMnlSWGFBckxwT3RuQlROV2FVNFVmdnArcVA3OUpTN3ZZUUZqUWV0d1pSZWFWN3JjNEozQUg5cDcrT2s5bkVIR0Y3OHorSldhUnBxd1pmTUp6RTRHd2Y5bXhsZDF4LzRrMnhSMzRmNUhKd2ZsKy9PTDlNWDhxTXh1cE9pdGF1Y0FSYWxJZEpoV0t5U3R4b211UjhWU2tQazcyZ3pkdFdjekFuVUhUNEV0T2NNcjdiZ1IzVjB5aVRCOVNYbE5ZWGw1MlNzN2J0Uzl3L0dDdk82WUJtOHpRNkdhM3Q5M0hZVFhJb3dISFgzYnFaYVBiZDErOXRuYnN3TlRKdWRxTjdlSExWMW9ESEFXa1lpTmZ4TUxBZTdzZkNvN3QvdVhwK2xUcDlOMG5xbFV6WlA3YTlvWVg5TTZjYkVKNjN1dTUzMzNqMG5SdGJxcFVXV2xmYnN4VlZjZGhSbmoweU1HYVRTOWZ2VDVic1djUExkRzlOWDFoalpNSVpZTGxxQk9tcU1oNkVRazZlSGNaUVdOcEg4Y1NZV0tPVHhMT1o1UWtrUi83WGhTaVN0K3U3MXhkT3JMMnluZTRnUE5UaWk3bmtadytKTXBBTVNKdHFLUXJkSXZRY0tCaUFMeGJ6UDF1UHhnTmQvWDlTUlNGL2JZMDRacXVtUW5scWhlWmVoV05mNEFaQ3NLM2hPT3dJVlVxVThtVUpCSFRnMDdjYzcrejZ6aEh4djB3aGlpaGJtdXhVQWl3TkdacnZHenlvUjhFZ2drc3kxS3lpQXVXVU5Pd1p6Y1NBUUd5eGhMaHRxVU1vbWcwbFNWbVFiUFN6MSs0OE5SWG4vckVqMytpU0xobHFSeTFiRVVqc2lnbW01K1F2eUthQlVRRGdvcE5LNktLUysvZy9mdFUrbE5lWmtJa0kxVWhhWTBtdGNMS2p0SG40M24wWkI5RkdwbzE4V1ZTY1Z4T1dNaTFXREp4TVVYU1FWSWxRVGtVVk5XMHQzc2ZjQW9XRjZjVHo0aGQ5OURTOVBNcytkNmw2MDdKbm5FY2w3RXJxMXQrekxXcnE3YXBIMTJZMis1MFY3WmF3eUFNY0tZby9lQ0RaMy9zdysrSHovZDZ2ZHVoU1VJOGJWcko5TUhILytMcmYvck4xNGFqa1ZHcTN2dncvZi9qajM4QVZYNHpuV2xOamowVjNHcTQ0WWdoaFNDSUZUK0toeEd2MXB0N0lJemtMNyszY21HOUF3c0tkcU8xM1k0NWI5UkxTODFxeFRKbkcrVm1XWit0bHBvbEc4N3B3SVBqbUloUWdOdTZWc2JKeU9rWWpWM2ZIUDFyQnJuTGxKVmtpb05aUkY3MGU2UW9rWWtUZmVKa0wwNjc2QmhMZHZZZDdPdThpMDVVS1BtcWU2T3VFdWZZeGU4V3h3RkpVZnd4WVdFU21jL0pwN3lnYmdVV0tZaDJnZjFsZVlEZVJQWGZ3WVNkSENKd1d6MStzbFZaaU44U2pXcENnbDROV05ZdklaSFN0RktDeUFEa3VFTDAvZGJidE52dFNaUE44c0pDRm4xTHJWOUI4RTdqZEpMMVdVcHM1NjY3N3JvTnZqUmM0M3pWYUpZTVJ0aGc1UFdIeUNLTEV1NlkrbFNwVkxKVXVKS1hWM3QxMjdyL1FMUGQ4MTVmNjE3YTdtczRHSlBhT2czZ3hMNTlRMkJvK25KenJ1dU9BczlRWjZjdG04NDJLOWc0cnRHcWJseSsyamFUMGZyRlY5cDErL2hkQzVhdTl3Y2p1MlRmYy9ydzhkbjZ5eSsvY25ubGVtMXRPd2tEK0dqcFBBZ3BEQ0VSSVMwTzJJVnNtMEpBcGdyWWp1Sy9VNXhOeFBWU3hWY1lRY2hRazlCbmtSK0ZJUnozS0V6MmVsYTE1ZU5VdDBNdlRGVHdxV0FmbE1EekFqOE1Zb0xUUmlBN2tRRjFFb01Ga2JyY1lML3FGUnlnb0xoOWY5Q3R6aS90a3BjTXVtNnZLL1FkYVlRTmxSSHNMOE0wVGJnTFM0SEFJSW9TeTlSNHFreElHRWtyaXVBUk5OMDg5WTVIOWpxeEFWd2x6Z01WbkIycVdJWlJaaFRNV2QyeWtqajA0MGhPeXBLek9pbFhVNld6REpqRTFqNXNCQ1c1ZUtVZy9LVU01amlNUC8rWGYvbXhqMytzT1BDYnBzeEJFZW9LWVdCc1hVbHc2b3lFcytSVEVCSlRxVkFYdlZQczM5VnBpYzB0Qnl5TEZsOGxrOFJVQzZSeHNnTllIZWMwZTF2eldOQ1NKWEdUamx1ckppU3Rzci9UeVRvdVBrQmo3eXJ5M25hR2xrdk9kbWRUalVJSStqNytrZmRYdnZQS04xNjlrTmptMVlGN3FkV0JUYWlKSXZqS1pzdUJqYzhUMDlCRHhycEI4T1huWDUydlY0OHVUVmZtRDkvR01xTENYWFBaT0hCcUsySDl4S2swR3NuVzlXZSs5dXlIMzNYdmcwZm1FcFhKc2FVakQ3S1ljT0FHbDFiV1cyN1FEZUpyNjIzWEQ2K3RiYjNyN2lQLzJ5OThLdTk2Mk1FR3VMS3kvdnhyVnp5RmVIN1E3NCs4d0dzNjVtTEpqQTNMRzNsVThacGw2eDFuam4vd2dic2E5VEpZbHdRckRsRm55S3FXNTZSSUxkbHIwUUlXQjU1ZnNSMWFtRUU4SG8rVEtld1hKelVYZTNPWWFFUFlaUU1Vd29KSi9zRHVqWEE3dlBqKzNYMUtvWmxlSWZ0cGR0TUNVVUVoYWJ0Qk91MHdWUU1pS1pNbEsrdkQwL1NDb0xMRDZaQkppdkZ1OVA0aUV2QUQ5UGlsZXFVNDlGMk9yT0ppZmdBWFE5YXhCeHBqU0ttTEpxU0RzVTZxeW5ieWZZTHhsWlZyNTk4OFIxVlQvRmFjdGU2THRGNXdCaUk1SUlDbVk0aFRHQUJsNmJsaDJCLzQ0QWR2NDJDVWRYVzZaT3FVYmc5Ry9iNGZKQnA0ZjhjMHBpcjJUTFVNOTNCK293TlcrcUhqQzU3clh0bnFuMStIbkQrcG1RSzd4V0Rab09SdEYydkJrSlZyTlYzVlc2c2R3eXdmUERwMytNQVNWVisrZW4xMDluaWxPZThzejlqRE1MN21Kc3lxRUthR2c4Rk1yYlowY0g2NlVUNGVIZ2JuZUcxMTgwOSs5VDgzcHlwVHpVWVVZeFJyMlpvQm9hakE0bnV0RFVVMXdKOFRWb1lNVnRWeFF6RlIyNVlXazBXUnBMSm04K3F3NlQzMGd3Z0NnREJKT1FDN0loYlZ1bEdadWZiS2k0R2k5SWVlb3BveDR5YXFHS3R1RUNFdlNlaXBjS2FOT2lQR2gxaWJEQVBIVUNzbGM3cXNEemZYWjAvc1VwajNPaHVCTzhEK0JIQ1dHb1dENVliWWhLL3F4T0JVcDBhQWliZ0VJWkdLSmVYQVlDOGtTVnlkbWoxeTk3MTcyUTU0VGxqWFpLakx4TFFFcDRKSHhEYXRtRUhjQnNjSTR4d1ZxL2h5UEtHd0lkaFZCV0dZSmhzOGhiK2ZPTDU0WVZuVS82MXZmdlBhdFd1SERoMHFlaXdSbXlLV2dEcFVXY0F1K3dpa1dobkpHMlBUZU9LT285ODlkSlA5U0dLMGRkcmZuMEsrbVIrYUJEbHo2OGFrcE1WZVgzN2dLeW5GZjZ5OXdtWFZQeFhBMkdrcmMyd1dPL28wL1RadUp3ekR4UFZ3SXJTWVNMYlpjd2NKK2Q3MURUZytweFptd2NONWNlTG9LQzFhZFd3NENHdmRQbXdhUXdURWIxeFpWY09nZkhEN05qNFh5UzVFUVZ3MkNYam91Nkl6MS9MZDcxKzQvdCtjT2ZMeWhhdmZldlh5MWUzKzljMzIxbFlQb25nNFZqNGk4WEVjUlRwRTdLNzdYQmg4N3JmL2pHbzRlQXlNdkVXVnNrRkh3MUVWakppdWJsMjVwRzZ2RzJGQW80QWtkTnEycmNUVnpKcXJhTXd3WEc3Q2JmYmYySDdwOVNjKzllaTk5OXg5Y2pCME1aYkdwbXVYbFdUanhwNWZwcTVmWGwxZElMenVsREwvbDJvenlyWmJjcE5pWFVFMEVMRytYUnZpc2JZb0pUY21TL01GcDNpVDhBWWZ1OUlkYzN0dnFsV2xnc2lGQURSVjdkdUJ3eGZ6YjVJejVDZUdTZVF3bExBdFFva0ZjcTJ5NDB6NmJ6N0dIQW8zc2l2UFB4K1FlMXQ1ZnlZMkpQVnlwVGxFemZJc0h4S0tHcGlicWJEaHNJODhWVVBiei9Ncnl1ODkvdnNYTDExUURTdHJ1eFFQajRzdUxLVGQwcGlKNXJ5TTZKZWtQZGdRU1hzLy9NTS84djczdnVjMkRrYkZOc0F6RGR4bzVMSlJxRzRPQThpUHA2dFdzd0xmSnYxUnZONFpQWEIwQnNLYnk2M2gxYmJmYzBPZFVFaGpOZDJBejlhRXlQYmJQbzJhYXRzRU1tMU5vVnNyTFgrVU9QWFNpYmtETDN6L2dxSlVaNmZOSTQyS3hZSWhUU0M5anpvalk2Uzg4NUc3NXhibTRmVGFsZHJ4WThjdlhkMTYvcHZQbG5WKzVQaUJBd2NQRFVZajI2U21pVENBbUpxQXBYblJ0SlJRbEJoQ2Q1VUsxOFFzRTE5Q0FEb0Vid2lSZUJna0lRSjhjUWovaFRPaDdyVTNzTVRTWERpMzhxVlNjNnBVYW1qdzdtQU9DTW9uMkRaeU1LSVlyQlVpQzVxdTl6d3Y5RWUyYlVDZTdYYmNHOWQ2emRmZlBQcmVEKzJTOS9mYTdxQnZXb2Frd2tEc1dDcFZnN2lqc0JpaVJvajlLVzR1SFRhYnJ1bndicnBLa0xuSEVaZzhmUHhVWTJiM0NZRUlMaEl0WWhDUkVOTXdGU3hsQkpaT1ZHSkdTVkp6VExqdHdJK0VPRG9sRWtKaHd0a2dxMENWS1R2MlJxS2VjTnJ1aFVDSmFEc0NHMDFWL2Z5Rmk4ODg4MHp1KzdOSlFJcEFVaFV4OXpHRkpobk9XVWpaa2FMaG5PV1RCZTY0K1QwTlRkcjdwQWg3SXJGNkhFWW5yQ0RKUlJxVXlhYXAvWlhvZk44ZmVsNk8rV2ZNNnhSVmtOOWdlWi9icEp3Yy9LVmNLdDJlSEFNTEkyeDgwelM3VXJweGZldENxK1BGa2FscS8raUQ3N3gzZWVHVloxK0U3NnozQmpTSmgxMklmSldGaW4zeXhOSTNybXlzOTBmci9lR2NyWFpkN3pZK2Q2blpSR0ZyYkkzQmRpaElkQUxWMUFoNzdmTGE1MzcxOTU3NCt0OTYxWVZJMFN3Tmg0UldhalZONFRvbXBCb2NPdDkzRFYwYmN1WHJMMTZFRkduVWFlbG9rQW0xckU3TWFyVmFGTWI5VHJ1dTBjVDMxU1E2WHJHckplVTZzVGY5eUEvY1VlamJ6V2xOTnozRDdGaU5MNTNmdk9mTWlabXBtaGRFN1Y1djZJVkdxTm1tdmM5NlZzdGxITjNKV081S0NWVjRMdW1ZWXdhVGc0RHprVDk3SFM1VU5zTzNTbkpCM1d5OHMwUVNjcnBJcWlhZC9rQ0FUMkR4OXl2Mmk5SFNFOHJJS1lreVNkVitzN1FrQitGVEp2OE9XT1dtT2IraWlRcGZFK0tJK1ZndmdFOVVqRjlMeHhnSzE4N3pJUlI4ZCtiQmJlYjlLaWFTVEpmREF3UjFXendRTVpSR2hCUk1kT1lKaG9oUU5SZDllbUtZRE5mU290TEVWNmZiZmZ4M2YvZS8vTy8vQlFldUlqR05TLzBnS3VGUlFVZVJ2ZFhZTnlWWWZwbUlJQW1Db0ZRcS9mdC8vKy9vM2dXWWZiNnF0c0dTZUFUR0lFaTJjRXdkbXkzckRVZUg5REpLeVBYdDNuemRhRHIwemJYMitaWjN2ZVdCTFRjMGFxTFRFOE1ZREVONSs1WUFmbUZ1cWx3eFlUc1lXeDJ2czhrQ3QzSnlmbWwwd0YxZjczYUQ4blpTMlE1REphWjh5L1Zhbzd2dldqeDk0SURmOHlOc1BZQ3phZFRzNnNLeFdyL1grZTdMSzlPTnVZVkRCMXpmTTAxZGl2T0RLeGVCbVNiVXdGVjhNbktlTDg2U3dXRkljalNTSEdDTjg3TEFqd1d4Q1BSUkNsTUNPWHRkL1BTSjA3UEx5NldTUmNWa0kzZzkyS210b1d0UTFZK3dqdDZvbUJYTHNreW5HMFM2YWRSclpoeHlGc1FERW0rdXJzZGhxTjJFbUkyMk41RjJrSTVnRlpzM1RrcW1xWkxJaCtlTmM0Y04yR2RZVlVMZEo1d0ZIV1k1NEptSDM3TTMyc204a0drRWkvMWd5V3g0cXJCMUNSdjYzRlpWVWlySE1ZL0N3VWgwNG1FemNjeElXa1hFUW9BWUZiYXpxMWdPUTBDTmFxRThHdmp1NXovL2x6L3hFeitSSVFGcC95cHFjVENzSHVVeXNqU0RMRmsyQWxzS0FZbWF6UjMzdjN0dE1kTlRrcm9JMlZSVGp1V3NmT1Fja2NyTVNEZlBCckR1WGRIMGcyQjFjMFAyWG83TjdtU1NWSlJCelJ1d1pKU0dQUUtPY3h2M2dxNklhbkM2aUdXRDQzbmx3cFd0d1lpRjRmdnZPbkpFMTk5OC9xWFZyVmEvNzU2Y25xcWJKak4wcDJZZldKeUs0dVNWalc1cjZMWjZnd3NzT2g3R3QvSFJ6VnBadHl3Y2VnYmhMK2VCNS9HU0hYdngydXJHcXl1WDExWlhwMmNPZzluUWNVQzJBYlpqR0l5Y1NpTk80c0QxTkxqZmVxT3NLbFlTUmQzdHNzTGdranArYU5rVk9LcE91ZW9PZXhwWWVNMFl4anp4dzZvU2trcTk0MGVyYStjTTFTU1ZTdFRyS1liWjFZeVdTcjJrL1B4cS95Y2Z1cGVIckZPcG5LZFhWYWJ6ZlNXdGJiZ0EyOGowWVZJUExYeXpVRzFKTy9HSlVwQWVMcDVXTUdpbWFleHFHZkt5TzBrNzczTkZIajRlNGNBekdjRnNNQWZPN3ROTnNxL1kwWmdwbWszOEplUHgwT1JtZWdFdlZBY21tQzZUb0gyeGxoRUVZZTc3YzdRZzFibm1hY01xR3pNQkptci9tWXpCN1hIOVVuNGw0dkpaSjBFS0JWRFp0U3piVVhGb2pGUXJsNFBxd0RpcTIrMzJ0Ny85ckdoWGlIMC8zTnJhZXYyTjE3N3k1U2UvOWExdndlWkUwaXg0WFJielZHUmJpbm1semYxQ2tBdkYwV1ZqQ2R3Qm5HVEkvUDdkdi8zY280OSs4UGJzQzVqblVSQjdqTGU5TUlqQ2txTXUxbXVPampXTHppZ2FSUEdEUzFNYnJmNUdOMWhwRGVHVkRjdE1KWmNwcHFjMlRnaCsyM2svL0c3RG9WWGREQlJxMnpZazJwMSt4MHFTZDU0K0RENHFpaGpFeFdWN0N2enlRVU12SDV1ZmExYTh6YzFnZy9wUjZFWFJ5QTNBMGNZSkg0NlNxZHJzbXhmWHBnNGNLSmNiU1JLWmhoWUdZUklNaWFEaVUwRW9rNVBNaFBSQ2pNTVhOQTA4R280Q3hRbDVxSEtJWkZ6VU5hRUo2dVFMaEhYdnpUMTM4TkRTa2FPdEcxZGROL1FDMW5mZDdlN3d3bmJIMENBVFQ5ekFyNWRLbFpJTkQ2ODlHaDFjYmg0b05XS2RkOE8rVXk2RnZVN2srenQ4UCt5UlVYc2pyWHl6L0pBZ3RBL3ZLU2NMeUxLUEpIalF6THhER0dIYXBZTjdBUDd5YStDQ1o0OFJ2ZGNoWWhOUWdLWkZhbHl5OVdEbzEwcW1HL3F4eCtWbklGOHBEcytlT2V2NS9zV0xGM1ZONTRUbnc3MVNmbjhHQjZjS01GVDkrdGUvdHJLeWN1VElrU0xxSmxaL0RFVGpwQ09TRHBJWEE0R1pMQWNnb0lVM2ZxZkhiL2VpcVhUdVhMaDNObFpLbHROM2VXclpKT21QamEybnRLd1F4NnFacUJ5S1lNZXg2N3E5NFVEMFc5S3NKNXlUVkpPRzdFN3Z5aXd1aG8rcU90V2NvdlEySDFiejRPR05OMThyS2VUYXRmVnZ2WHl1T3hyTk8rQ0RnNmUvOVlJNzh1YW5wai8rMkVNblR4d0tQYjhmK1VQZmN3ZWp2dXMzYmJOcW1zTWdYR1BNajI3SDkwTnFSRld0MSt2YXRpT0lXVEdrMnRRcWRkZHV6SnkrTjlTdHdXaW8ybVZNcnVJb2NBZHd6Nk4ySzhIR3E2WkptTjV2R1phcFF2YVA1Q0hTYXExSFZITWdrSWo4MGRiV3h2VkxjWlEwN2pxRE16S0cralhQSlQzUEQ3eFJaN3R4NGd3MWJkajMvbWhBd0ZNWlptdk4vNTJuWHB3cDZSODZlaGdDdUFQMTZhNExvY2ErRXFXRUxNMU85VHI5bE85ZWdNclRNai9QQ3BtNWZPeTRkUjcyUUxTYnplZXdOMFJEV3BaWktrVWhuWlJpdG9mdnV3WGd2Mk9XNFU2UW44Z3lrMVJUSGY5VTE3UTRtV1FtWmdhbk9OUW0vNzRmaEtXU2MzTXRQMitGd0ZDVGoxdFNHY2xCalZ0dm1QMHhmMEZsRWhOSUdiSWxoVDlXRXBWcWtnZW9pcUl2WXFpSzZNUEdQakJFNkd5cjlNSjN2LzhqajMxRWtSaCt6QUtFTHhESU12U1NLS0VMalZoUks1WFYvb1FseWtSQWh4OGw2SFhjZGZ1UWJIMzJzLy94bC8vamY3aHQreEpFcEROUVFoV2NWbHpTeVlGR0ZTSk5QdzR0WGR2bytxZVc1b2FldnprazEzdmhFS0pkRFVkTUlHK2U2aXBSTGQwczBjUlFid2NCTkhVYUlsM1RiSlRMa05FNm11S1dZbFUzTkJYOVlpeFdGd0puMUVoRVRTOGVROElmaFRSaThQR21wWUxYQm5zeFZiVnR5MTd2OUZZdVg3dm53WHM3N1Q2RTNaRmtyK08wYndIZFEzd2VoMEpqVVkxQzhJT2hWUzRMMkJwbDdlRnc2QkJHNEhsQS84aGg3VFdWR0RiZjJ4dlpsYXBhcWIxNTZYcG5GUHRCc3VHTjRCbHVlMzZVSk5OMWg2aWtNK3kxQjcxMkh4SUN0ZDNaYnQxb09aYlZySmNQTkNGdENMM1J3SzVXSjNnM1lPMjZXNEswd0pFdmdzNmVRd29DdXlyR3JST25nMXRackt0YWpCcFJDVndsWERWRU9YUEhUczh1SDlvSFlJRlFLY0V5QjBVZElzSktCclk4QkRHS1QrdW9aTUJyWldjWVlyUXBMUWxFcmtlT0hUbDY5Tml2Ly9xdmNXS0lvRk5OZTVIR3lMQ2MrNGRaaDJtWTYrdnJYLzNxVjMvMlozOVdHWmZyQkc3TVVvS3lhSUFXZlN0WUpCSnRmV21mRW9lVGdvT0k3bEQ5OWdUSXBJaUl5ak45ZVpKcm5hUjJNTzgxSldOaW5rS2lNTHg2L1ZvTzdFdjRWM0toeGZ4dm5yRmpPWitZMUs3Y1BCQkZQRXEwWTdOVDAvYmVNOVJ2K1ZWZldIWm01bnVicXkrOWVhVTE4bUZYbVpwMmNidHpvRlo1OUwwUG5qbDlRcXM0NiszV2VxdmI2M2FDa0xtdVA5Mm96VmRLQXo5NmFYMXIzWFdUMjV2NXBPb1U1NWdnNFpTS3hpakk0Vlhkb2xFUWVHNjlVbmF2WGxHOFFhUmJDa3FIeGZDYWNOUXpESlczZlZ3cnpSaXBPc1RRWUM2OGJrY25wRkp0UWxwQ29taHI2MGEzM1Q1NDdHN05kbVoxT2doYzBqd1FobEhyNHNYREowN2J0ZnJHZGd1bjNhbGE0ZzVaNEZ1MWF1djY5aS8vMFZPamo3L3ZBNGZuQ0NlM3FnUGpWODJxeG5ZOHpsOTVJY1ZYeGtQdzBvblp2TWdDMmIzRlh3N3dWSEkxUUw0N29XOVhrRnhJK2VyN084Y2Q3elpCSE1ramxidzdWYnk5YVJvOFFDU2Y1L3dBcVZoQWNnZ3NreTBRK3hhbjBFWHhPQW9aendnVUswSHpva0dhNGN2QlFpeTk0M3c4QVhuN3ZoOUgyeHRpakE4ZUlaVVFxWUlsWjhGaDY1aHNDK1VTcUZNMFdRMFE3VHJDeHlSWnFJV05KWVpSVm1TN3VjUXI4djZjVEZaSlFnYzBGVGRBQ3JyblFhSWVuang1OHJPZi9ROC8vZFAvNUFleExrTTM2USs4eE1KSkNVdHpqYVY2dmVkN3BrcUhiamhWTVNBYXVOeHh6N1c2TnpvanVFY05XMGNoVElIRGhHdFFNdlVLVmZXM3ovT25HQXNwaGliV0RtY1RxQlZIbjU2dVFEd1V1TWhDR3JueGNEUlM3QkxoQnNTRG1tN0MveGpFQWlaMnp5bWk2d3paYWRnK0Z6V1htcFd5QmE3WHFaY2hFeWNoRVVxOUJqanloS0F3R0ZGeWlTZ2N1eHRGSVNveHFHT1ZIZXozNHpUaUJFY2JhUnJWRGJLdk96S21GcTZ1YjlkcWpYcXp0Rmlmb2JyKzVQTVhBeStjUGJCNGRMRzZ2dG5lM0I0NU9pbGJ0Tjl6djMzaENxemI4c3pVWUhGcXV1SnNycTQxRnlhby9zRmdNR2kzWlBldjFDcUhUYUpLNVNpMHhiQk1rV0RGQ3h4TEpaeVJNSWhSdG9EUUkyZnZkeXJWZlJKSGd2cDlTUmJ5WXJnbXUvbThpRlFjaDQxOHVFaDRqaEVQY2E1SG1pT3lqMzcwbzcvMW03OFpSakYya0FxdXZsQlNTbG1uK1o1VVpMRlpVZjdzei83OG4vM3NQOHVJdVdQOVVaN3B2NmFBR3hGeVNuRkN4UkJXSlIySndQZGwzdnk5OXYyOHFBY25nZGUwZ3pJZkZNZUw2bXc1L3grOGU4U2lJdWtwMTI0cjRwOEYxZDZkdk83aVFGakRNR2VhVGR1eWZnQU1BN2ZLL0Yxblg3OTYrZktOalhadm9LbHEyL05xdGVxbkhudC92Vkc1dHI3eHhuZHV2SEpqbys5SGptVXNWaDBIVXVzb21tdlcyMTVzNjkwMUNBbEcvbTE4dE90NTRFbE0wOFEwRFBMZ2hFWTR5OFF6Um9OazdYcDFmbEh6QjlHZ0RXc2NRT2l2Y0FmeEFWMFpKVHcya3NaMFVtMTJPbjNQZHdtT29tRFVkSFRUU3NKdzBOdnV0cmMxdXhSUk5RRHZOV3lYRitZM2U2UDJ0Ulc3WHF0TnpmYmNJZVQ2OHRnZ081S1MwQjJWN1lxN09mdy92L2pDZ1UrKzcvQlVsYnNCNGNyK0xXQzZZU0R4bG8ycDR1UW1zam9aVStvbXF1WmlRRm15UXdvRm5ZaXNlbVlEaGxOaDU5M0dIT3pvN2pORTc5SmJyUExjckxHVDlhSXdKVk1ta0hldjZab0JPemFLUmJsVkp1a3N1eVorRTZFUDNoTzEvUXNJaE5EQlMzc2Zza0VWT1ZlUmsvR2N3cFFwdStjWWhWdjQva3F0eWdYM2lZbW1PMVdLYTdKMGhJK1kzc3h3ZkluZ2ZBbHVPWEt6cFVDRUtLRmk0NXlvN2VLTUV4ekJua1N5dnhRQlhpSW55bkZkVlNlMWpwR3dGZ1FCZlB2QW9VT2YrZlNuLy9uUC9XeVJYMzE3WDkwZ0dMRUV6Z1FjeGRsR0tXUVJTMEtGbUhBSml6VnJhK0J0ZHIwYnJUNFdnZ1VUREc3VzFrbkowQnhUTXpWcXFyY3pmQjFuL2FCVHdSWjVLdFFNVkZ1VjByVzJvY082NmhWc0lkWUVPUXk3NXFJQTBYcVdDSEZEZUpsV3FsZk5jb1VUWFVnSVVwR3pNOE15Y2VLSGp3NGVUcDJxWVlzRUNsd3dpYVBnaytJYStNSVEyOW5FdENSNGpzaWdSNTBmSEdzUW84cVBhRjVROTlzQUorKzc5ejN2ZjZSYTBadlRVNDV0dFFmZXN4ZTJxQlVkUFRwM1pIYXE3RXdueXNwbXR4OWFwTGxRaGV0ZVcrdWN1N3Erc3I1ZDFka0QvKzNycHg1OGFDTDg2bXgzMTdkc1J4TkNRS2lIQ0JzMVR1ZVZZTThJNUNtSkdENlJ4R0t1aVlnellUTVl1bjdnOUQzN3RYRUxWeDFqbDE4Y3F6aDFBZDdCZ3BXMnpYNkFCU2xYOFdCVjUycE9tUEJCRXNnSUtRekRNMmZPM0h2ZnZjOCsreXo0ZnBrdnFqU2RHaUl6K0xRNVVnVGN1bW84Kyt4enI3MzYrcGt6ZC9OMDdDUk9VTXFId2VialRPUXZFams4R2MrMnJGZ3JkMmI0N28rZ0toUEtKQ1FuWkUzV01ndmptQXFqUm03MjYwcHhTT3RrVS9WRXA3VndEM0MrcW1Vd2VGV1Yva0IxR2V6cWlPUDYwckxWbk43YWFGVk5ZeENFYmhRZW1LM0Q2WDdpbStkZVhkdGFIWGg5ejYyWUJxcFhSVWxqcHRwb1ZGYldXaTVqMVpLejFkR1UyOUtBSW9MVW96REphQlgwTmxYeFhROFNOU2RDMm94VnFVYXREYkRQVWV4cXBxbkVJUmdNVGRWRHplNTY0WFJKcWRVci9vME84MTBJa1BWU0hXZDBlbjUzYzVVbGtUazlaMVZyZFI0RWtLS1VLcVB6RjRiZHJabFQ5MjVzcmVsMnliSFI5M3Y5WWVCN3FHcktxUTh4QktXWHJxei8xNis4L0xsUFBLS3I5RmJVVEJRamhWUTc5bU1wVWFKSUVXVTZHYlFWOHVnODZSZWluTEdnK3UvMC9ZeE5TdW1sSVFPLzJSM3UyQ3I2TGRzN0oyVjJibGJZelFvVzQ3MHBKZjRncnh0Nkl5V05YK1VOOEV5K2FNSlBDM2VLOWU1S2VlZkVDcEpwQWs0TVNaSnBOeTh3QXdRQ2RqdVlmNjFVaHZSRnhjNDlTdEpDUEtybUtueE1acEN0OXlpeHpnVjVXdFRYeEN3NWtwYi9oZXFQL0JJZGdGektuY29YODFRTE9CdmtJQVpYejh6Ty9NaGpqLzNqZi9TcFJ4OTkxUG9CWXZEaUYyU1VmaHdiTklGRFdDNnBWN2JhVGNOTW1EOWR0ZUtZOWJ6azliVkJsQ2hpdkJDR0kzQ0dOQ0VsQ0o3VE1UUkl3eFZ5TzBZQlBBYjRXQnpUaVE4RDJld0pwQ2tjaS9GVU13bmlaRFQyZkhUMWtDZjZFU3JVUUNxc0taQ1U2NXJLd3BpSGNFUUpZcEVtenY2QStFa0pNSWVNa2tpelREaTdNdkZFZlRvUlpZYWVUeFZzdTZmaW4xTG1Hd3VwTEtGcFJaUEhZN2JyZmxabTZkRGhkN3o3bmNGZzA2bVhJZERvdWFGbGFvckIrLzd3NlJmVzFxOE1QSC9RN25Rc3U2bVFaRzYrTkJpRmNGcG42NlZ6NXk2ODhOS3JIL3YwWk5sbHNCMkVFY1FlV1BGUVlSOXBzb2VERUFpRElsVHR4VUNJK0dFb3l1czR4Yy9VMWNnUDdHWmorYTY3OXlXTG9WQUpFMXN4REpOWUU5T05OWVFRNE5tNTNxaGtxQzEvNUJqbVFnVVpXSjVRTklyRGFIWjI1c01mL2pENGZna21KMkx1a2NDNWhNWVF5V0pvY1RyaE1iWmFtMDg4OFNYdy9iSVJZRXp2WXFuSXZDTGxMZ1FvTFNLQXRPN0lDYi9qK1BmeC9EdUV3QVEzbStRa3JRbFVkUEtWeGF3cmo3MTIvSFBIaTR2ZkJCTnZHU1ptd0xhdDNoYUorT2FiWVVLU3ZMeDhhSEZ1MnR0b3VXRllzV3h3cTkrNWV1TzdxNjNWZHM4TFlqVlRscXhWU3FkT0hsRXRzK3RGN1BvV2JGRVR0U2x2WjZ0b0NvdEdneWdJaVNGbXorRU1hbk1VUm43Q0l5d054dFdGdyszZUtJZ0N4eWtycWpJVXcxRDBlalgwZ3Vac2s3UEk2M1EwZnhRTStxVGFLRlZyQmxXNmc2N0tZbUxZZXFWcE9SYnJyaXVHNVEwR1hxOWJuMTlVZGQwZjlDRXpvVGFXSHBOaFgzRGtUTGorTUU0ME1HQUdmZmFObFMrK05Qc1A3anM4Rk9mNkZoVlN3L0I5VDA0RXVsa0dmekkwSEIvK2RHWTh4Q3VURGx1US9IZndPMFZ1bWZNRzk0YjliOW5aVHpJWnFPSU8zQUgrSytQSmV3S2hFdW00YVpxbzk0WHdScDZrcHlNUHNsb1dMMUFCRkhoR09leFAwcmxXWTZuZ2ZPeFFyb05EQ29LWWxPeW5lcm1mUDZ0V2FwcGxRTkNIVTF1b3pQakZJbU4vUDAwL0YrbjlYS3FtaUV3bkxac0pGVWxGQnRHQ0R5Vk1xdENibDVKbmNnWWdJcnZJOXVLcGxLLzRVUndsbytIb3hlKzk5SlV2UDlsdXQvOU96QXNtelN3cFdlYVJtWnJ2TVFPdGVReUJ0MGJWdFg3dytyV3Qxc0NqNGlZdGROUkU5cjdyT2poY0ZWTC9pZzBQN08zN2ZuQmhac1d3UzVDZkkza01ialNJYVJ5UjBFKzhZVFRzUmYwT0gvVVRmeFQ1UGd0OVNNN0JuUlBiVUMxTGhjMm5HUkZUUEQ4SWZUY1lEY1BoRUJZZkZoTzFlWHdmM2srVmdwa29nb1BxQndKSHdpb0JuZ2R3bnZBTzhCTnZGUGM3TEhDbGdpKzI2aUVIUU5GeHZwR3A3Si9sRUZKYk9Cd3JGdE1NQmRhaGF1bmdtejNlNnJzajdrZUc3NFhEUXdmbVptZW02cFVLcEUyNmJVODNLNTk0NzdHUHZQUElqZXRYZCt5NnRjdVhxQVpXVHFkaVEwREloWTAwbWlxOUxCZUNvUkNtSUdpQktubDRVQ0JPU3VKdzd2REp4dnpDdnJVM1Flb2hUUHBkWktJSUl3Qi96TnJxdEUxc25jTGh3WjRDUzZ2QTR4UkdYa3FCUHZiWVl5VnNCSWpUUTRkZDVqUlZsOHBIeDRqQjd6S0MvcHUvK1dJUVNMVWxudVVXcWVPWC9hZ0lHK0gza0h6QUJBWEFVUFdNRDBqdXpQTFo5ZkVwdk5qQlQyUTZubzdWSVRtVW53ckY3NUJJSzZiMU95YW0zRUx1Rk9sSHNHY3RjRGwvUjQ0L0JaWWgvN2JyOWVwVWZYRzZXU3VYWWFldHQvcm5WamU5TUlBRVdOZW9wZEVhRGhOM0lMNGZlTUcxdFJhRUg0MXF0ZU82VE1tSnBtL3Z5ekdvU1dMZmN4VWNoWVZsTEV5R0VhM1ZGTXRwWGIwUVViMHlmNURXWmtodGpqbFRlbjFlcjgxRUNiZWNNdGpoWWJ2VjI5cnczQkdZZTZjNmhUSmdZRHBjRi9hMFhXMFk1YklTQnZHZzQxUDF4b1h6UWVCUExSNE0zSkd3OFpSRmNmZjZaVEJpRUhMZ3prOFkxazBJUmJueEtQamlkODZ2RHp3VEorSGVZdlBqUEY4cHIxaDRpQ3psa1UrUTVzWStPeE43U0k5d2tXQ1VSQkNTaURsblhCbVB5VTFaZUp5TWY3ZW82NEJSbEtiZDB2ZEx0VjZTL1VyeDhwUko4YjU4ZjhvT0lEQUpzTi9TNGVGS052Y3dyY3J6ck90ZmlGb3FjcndGOTN4dk44Z2hSZjBuUHl2REJOQ2dpc2FpdlRHay9mTCtBOVZaMjdDR2ZFQVJmUkJ3bGl4YWtsU3lWTW9sS3BLWkw4RVpudjRoUlNPUTFzZUVUbmM2N2xITVNrKzFlc2N6ZjVXc2dZRUw0Vlh3OTMveUozOE0vemNONitqeDQ1LytxWi84K1ovN3VablptUi9rUUdMWGpVTG5HMDdaVWxkYi9SS1c4ckgvdnRzZnJYY0dGN2I2UE5Vb1JHUHR4a2xOTlExTjAxVWROZ0c4ekRLSVJtL0RDc0R6TlJtMXNBSWlTdTJ3SnVKaHhTeUswTHVnemlzVzV5Tk1kSVJDcnVib1NOZlRFaXpVNnhSNzFRalZoRXNQUTNSbm9oNFFoNkVobWgwWjB2WnhkWFhOUk1nN2ltSGY0Z3l3R044QWduM3Mxa0dMZzd3TitDa0tZRUc0emhQRE1DSFowVzVGWUt4TnpaM3JCWXBtbG10V3VWdzl0RFMzL3YwVlB6UXJkZWZRM0hTbjFmUURadGxXdVdUZXVOYU9ZKzMrbzB0SEZxWXMvY2lWRGRidjltcjFXbDZudW5iNUVseTRwZHZETUJCOUhFUzBnOUpNUHAvTHBrUlJyZGN3WklkTmw2aGVuQ3lldkZ2ZHR6WUJTUlNLOXlnYXdqU1VCUDhmZTI4Q2JjbFJuZ2xHNUo1M2UvZXQ5V3BSVmFsS3V5aXRTRUlTWUF1QkFKdUd4bTY3KzdUM2JldzJ3NW1oN2JaOWpvM2RBNTdGTnQwMlkzdmFuckhkeG0xekJyc0JXUWd3TkZnZ01BZ2tRRUpvS1VwTDdjdmI3NXA3eFB6L0g1bDU4OTYzM1hlck9OTVNOeWdrMVZ0dVptUkd4TDk5Ly9mRk1valFoeEF4YWpGTU9XWTc5Q2NjWTdVVGduTUg0VXc3U0VFeWNMMVh2dktWUjI0NDhzaVh2OHlaaWZZR05RdkVBUEkyRmVFbDRvNnZmdlVyenp6ejdFMDMzY2d6M3NsWU5RZXFReXFuZ3lmZ1dVb2hoRVV6UTFNc0FtTU4zdzNEZm16bHdoSUpJZlNrN0lOTnNid2xYK2xHRm1RWDFvVlpCV0tUUXFLWHIwL3RxaC9vZEx2dFRnZHphcFpWS1ZjcTVmTEZPd0VLLzFHQ1Q2dVd6bHhZcXBYdElBcVgycDJaaVdyRjBDdTE2bEtyZWZuVTFIWDc5emE2M1lWVzkrU2ozenE3MGpoMDJlN3pYVGg0cEpDTWpVUXNVSFBjdVluNkltck9Zajl6Z05CM1lXcG1Zc2JubDFkTExKN2hTYVhzdEZaOHJwZklON1d3VG85MVdCNTJXOTdxSXZnTkdEMVBUdW5WV2hRRW90UHdXeTF1MjdEekt3em1zQkkxVzhKd2wwNi9PTFAvTUhqYmZyZmoxcWJnaE93c240ZS9PTk83ZGR0V3ZobWNSY0kwNGJoeE9EKzMySHprMmJQZmQ4dkJiV2RsMEVnSk92dGZidkhOWnV4UFBaY09qOVIrMnkvUjlzZFpiWTVuRG1PcTE2anE2NWwyVEVZcm15RjRVRDUwdTFlUWRoN24vYWFGT3ltZ1RBYUZFOVU5UStqditWMWx0ZE1pUmovQ1AvMTRsYjVpSEFucEM5NXQ3d1B6Zk5tQUpHTlBrbXFycHVLdEROcVZ0WDJ6OWQzTU5GTVNIbVdtQ0pKT0lMLzBTYVhGVWFtWW0zUjFmdU5YeUpUVHc0VmR6V2xWcTJJcVQ4OUlya0lzVGFSemx3b1ZaWm9RSFZZY3U1b0k5c3pUMy9xTjMvajFlKzY1NTRFSEhyaW9uSCtTUU9BK1BXRjMvU0Joc1dzejEwWjVnb1lmSDF0b2RlSklZeXJEajFVSjZwSEhETG1ENmpBUTk5dGx4OVhOSFdQOTBHQVlKcmNybWx1VlprbHpKNHpxRks5TTh1cWtYcHNDcDF1Zm1ORXJVMlo5cGp5MzE1blpiVS9PdVJOVFlGY2h4TFpLRTFhNVlyaGxpUDRUcGpQZDVwYWJTRDJBZ3lTQXZZRmJYSU9vR1Q2Zkd3d1Y3dEhMd21BV2RnNzJDNFN4NThld0E4RXRBQitjcXRlRXloQ29ZNmVUM2s4Y2JGdFlyRTFQclo1dkh2L204VlBQTExaVzVMVlhISVpUc25YTzIyWFBXS3hxMkRXaldtV210YkljbkRuYk9MeDM2cllqVjBXaTNGaDJnclZvOGN5WjN2UDN1cUs5QnVZdnh1WTlYZFczYUprZ0dWbE1jYkt1UEMzVEljWWRiSVZBUUlQcEhMcjU5bTJTT3BnLzFUb0JwamFKbElLSEViWVNPTFlCeHQ1MXphcnRtcHhWTEpad2xIR2FjRjFWL29EZ3huR2MrOTV3SDU0N0daeHp2U3AyenM4RG03YlJhSHptdjMyR3ZONXNDNlZvUG9WZTVjUVZSSWt1MUFGU2FXY1NQWkJzTE9XemFlVlV0UXRyRktab01tTTU1WGxUVnBHWlo4QXE5S0JDNnhUVnNyNWt1V0UrTm45OUVpVTMvY1dWcGZNWHpyYzc3VXNBWElUZ1lYcDZZdmZ1dFVhTE5MYU1KZGlQU1ZJdmxhNjdiTzdXUTVlOTd0WWpsKzJiYjhmaW1YTXJUNXc2ZC9UOHdoZWZmZjY1Y3hkZ3gvcGhrSXhFQTJVWm9sWjJkTU1LdzFBcWhSdkpNWHpSTGJOVUNheFM0OEpaWjZKV3JwU1I5SThoWFZlQ0hvQ3B4Q29obEVmd3NPdVdxblVMdHFXbHI2MHNCbjZIbTNaNWN0cGJYZTZjL0xZMGRIK3RBYS9JY0t2ZTJpcUxJOU4xd3FEYlhWbDJKbWM4MHNaTTR0anp1akFMc0ZoTTA4TW82SGlkUjQrZFcrc0docUZ2NnphQjNSVWlLY0E3Qmd4LzJnQk1yWDVhTVdwWE5ENzVSeEZBV2xERGJWNHBTdW5pS083SWx3U0oxUlM0K2JaRitLOUhDV3k0SmpkME4zTnRRQXhtT00rbGFxbnhXRk5IUkJIaG1LYzB3QjhxZmtLYVNDQ1FRTEVpVm5SaUJyaXJkMmI3OTA3dm1xL3ZnclZCQkNhSlN1d3JCYWVjZFJuV2pTcjU1MUJuamFWTnVXQ1hVdGVHR3NtWlVGNEFOUWZxU2hSS1V5U2VWQkZRbjVwMWM5SmhDWi9nMkxCV0swODkvZFNQL01pUHZQLzk3eDk1UXhxNlBqOVpBME8rME95Z09wUEJLbzRWZElNenEvNXFON0YwVXlsYndGejFsSW1KbVlnVnN5WktwWklOL3k0WjJvNERBbkp0SUhBSDgyWXkweGFtemF5UzdsUjBwOGFkQ2ExVTE5dzZLOWU1TzhYZ0s2VUpvenlsT1dVTmZzQnlUZHMxVEJ1YjFnenc0eDJ3Z1FJWEFVYjJFdWxwS1IrRTBUQTFScERpSGxFUG03QnlPVXpITkttUVFoSjNLZlpTNlhXWkNuVVMrbUc3MmQxYS9wSmhwMS8xd09YN1pITzVmZTdzMmFlZlowdU5XdzVNemp2bTB2TkxaNDYzRjVmOFZpTSsrK0xhTTQrLzRHcmF6UWN2YnkySEx4eGJhYXdHV2h4MVZuclVwTjNtV3JpMkNPZVJIMFlHS24vMXFPNDBPS0FNUitlb2g0d29aWlJGMXJBUkVDVUt0TjM3RCs0NmNHanJtNFNGVTdHTkJORitQZ29FNkVnOUJKTzNFSjhadTJaY3RUUjQzY2dOSEdFdnVNVlp6WWJIbFA3NjI5NzJWc2NwRWZnMkhSUjhwZnRXbVhiVmxvT05lMXo3MklNUHR0c2RqZFlEbVh5WjF4clV2a2diQkxNMVFDRC9WRlJoYk9rM05KWjBhQ2hHWlhXc0N4V3lyRHRiZWRFcUZMMjBBVjJUWEdOc1cyT2pEa3dTck5TQ01GeFlYRnhlV2JrWWNBYkZNUUwyN00xM3Z4cjI3a3FyR3lVQ2xvL3JPTGRlZDdoV2N2Yk9Ub1V5K2ZxM1R6eDUrdHlaWm5PNTJ3MmxXRnBydHNCWmwybGp5UWpYeGFwazNPVzA4YkZxR1lhRW40RkhLU3pINVZSNU5KaVl2ZUlLUkFVbVFSaUZlTExZZVBoeGlQS3hJZEJrbHF0Yk51eWo5dXBTMUc1S0VaUG1OVGJ3dFR1ZGRpZGN2bkMyVko5eVhIZHQ4VHpYa2FDemUvWVUwcCtXeWs3SmdlY056eEFid1dOTVNKb1dObW5EcVh0eXNmSE02UlhiMlA0SXRiRW15RlJ6TXAxZ0t0NFZCYm9hbVVmUnhmZVlxbWYxQWYxRXJ6T3cxM25QWkU4TW5zdE1aWThJdUZJbmNraUUvNGFMWkxNdkZtOFlIcWRsV3BpUVVMcnpMRzFnSGZpRTRuOTRubGZBdS9SeVdTcWxydVhKL2tIZUlEbWk3YTlXcmF0bjlsbDJpZEpRV3VaZnMwenJXU3J4RW1WWjZZM2hyTWdiUTZFZkVWTUFqZEdtVUdyQU9nYXFHa24ya1FZd3ZsQWR5Ynl3OU1CVnFvSXpWV3RQS3pLTTFPcGN0OXpwZU85NjE3dis1RS8rZExRTmFlb2FXRzlZN3FFSUt3WXYyNVlmeEV1dDZQbEZjTDQ1RWJCSW5oRU1NYXllSTZlampncVYzRVhVaXNsMFk0UmpBS2xKRXhGR01DWDRPSXRoaks3alAzVkRvdTAydVdFend3YXJoMVlaZlhUSHRNanEwNFl6RFJ1UmdxaHR4K0xBQjBjYlVaZG9MVFVTdk9QWTJBYmZ0aTJpamtNQW5ZNGs1TWp1WmJ1dWpia0tyRUNUQUNkNENBYTlIVTExYjRCbkxyYWptSWVidU9LR2ErZW15bk5UMXZRRW43RFprYjI3N3J6bTRPVzc2dnVxcFJuZHJvWnMxbkp2UEhEZ3RvUDdLekhycm5WaHo5cXd0TGxvTHkza245TmN1aEIyMm5BRFNERUV0NGxyTnVFVXNITWtJYmNjeDhabmhTc0ZnUXVLR01mdmR2ZGNjYTFicVc0Yk9NSWJpbUxFK1VXSkxMc09MS1p1Z0ZJQkdqYVZpckxGYTVaWnNRaHVMR05UWTJEK3F4a1IyQTAzM0hEbkhhK0trZ0RkSklrVkJEMFRqTTR4NUprNVFWbS94eDU3N0psbm5sRW9WRVN3c2g3MldBRUZVdTA1a2U1MkZZOWdJV1lNOTl0d2pYR3BhM2djWUd1WllGU2pWSXF1SXEzVUV2MW5CdE5tR2FXeVhFOW1ucDJ6dmU0bW1ZZVBXZGNnbHowU1g1NTZIcGlmMUZpYWhtdzBHMmorUjZ2T3BBQnNkTlByVTFPMzNIYUxGNmxhWE56MC9aVjI5MXZuVnI3MjR0blBmK3ZZMFlYRnBhNG5pVFFhOWpLQnVTVDhhQmpIY3FTNEg3Vm5TS2tnWXN4SFRoRThCN0NmaHlRUHdldnRSRkg3OUNtLzJiRnI5VENNWWlZQ3J3UCtkZUIxSVZvSFA0RGJqbDR1VjZwVlU0cXcyVURzTGZnRzlVbjQ2T21wR1V3VUpvblhhcFNuNXBwTEMwR243VlFuL01acTJGb3JUMCtibGxteVRKSmlSY1NNaldsVndhSVF6enVFZjhtblR5d21RenhSdUEzU2RrbHozaW5Sczh6OUFGSGdaVTZ5SXByTUZQdDZrUXdhZnFsaTRsU3VVVlhJdVN3a3lYTTBmS2J2SUVoSTFEVE5FZDIrVFREL0EzZ0NocExRdHFJWlNYMlJkVDljUEhZVXJTMVZ5cWw5UC9WWUNvTVVjQlRMUlFaQjNCNWR0SlU5TTF6OXluMzd6V2RuV28yR3hkUjlraW9jUkR6S25GT3hsdFBweHFsdGkvUi8wamIrTUE2eldTbVBIcnRPTEFpZ2tZUk81b1FieE4ybDlNNUZtditnT29vcWZNbE1waHVPV3BqL3IvM2FyeDA1Y3VUdW5WUDZJNFVGRjAzZmczOVBsblhYMEM3NDNwbUc3NGNCM0RYNTIwTEhGbk93UjhneWsxRGhvdTQ2RTQ1TndEdURqMVR2UjdnRktod2hsNDQ2ZTNBUmE2UW9qeTBjbktRUUtEOU1QRCtxaTA5cEZsUFhBK2FXOFVDSVFrTHRZT2tGclQ3UzFzSVRBMmZLNHBxUlZWN1NQQTlTZHdpbXNsMkVwQ00yQldrS0xHU0FXWXZ3QTB3RFJabVM3Um5FYXJ2M2xHcXVSUG9CM1hVdGJhMWxzdGlzbTRsMGo1UjJKL1FoQ1p3aXpaYVFZY20xVEFnSFRDM1V0V0QxWFA0aDdRdW5UUU5iaXVtSTVWaXdRT09QYURqU2UrYWtMcW9ueE9BS0g0bUpqQWl6d1B1UDNMcnRIY0pLZ1hNSEMveE1DeEp3K1ZGL3dRdVNzZ25Ca0lZQkRXWTRXUlhCejBHWVNGTm5EbmgxdkZkbGZPdmIzdnJRNS85UmtjblQyYVVyZUFwalBhNWY5VS93QXJ2ZHp0L2YvL2QwUVBUNitoU3NsWXlPa2hXQnJ5Zkt2R2laWkx3Mmp2czNqajk0cmltZnk3WVVzRThwTFU5V3NPV0tWMVNtYmRFODVXMU5hN2lTSzQrU3NSekx6Y2k2eTdUTXE2WDZLVm91Q1oreWxpcHBIMFhvMUd3MXdlT3VUOVJIS1dEUUFnYWoyL0c5NjIrOTRhRXZQcnF3c2lvTTl1TEM2bExiYjNpWTB1ZlU4UnRUT3pIY0VPcGhheEpUZElLb3IwYnpFYmxXaCtNODlQVHFSQndMNnY0MXdCOUd6QjJYWmN0cWRicytsOVhRbjkxL2VXdDUwV3QzVE5zeElSNXFyc0wraFhEZnNHeGhtczFPMjBJbUVQalZ3SjZvdzFFMUxZTmtyV0VIN2M3cHBnNW53ZVRNK1dlZXNPQmJ1dDQrY1p3YXVPR0E0eEgxMHp1dUhRUmgyYlE3WGpmcUNodEpTbmpzZDQrZVhsbHNkaWMyMHVEdUR6YmdiREE4ejZlZGxXYXhlVi83ZXhHTEl6SXFadEtGSzdEZnEvSi9Wa0h2NFd4U1RhZWVES1Jxa0pkNWxtaVlZdi82MGhMckY5SmREejBaUUtoWW1QWkhMR1JSbVpCdklKK1krcmdKOWIzelFyZUxUTnNWMC83aDNqTko0VWRaWkM5SDZ2R0xkWEg1ek56QitmMFhMaHkzL0FqRElkV3dtRFhpa3pGQ2ZaYzhRbEpNaWI3ZnZlMzJPMzd6M2U5R3JDbHgrcmJiN1JkZmZQN3IzM2o4UzE5NlpISGhuRzJWRFVPQi93VTVQa21TQ2MyQzg1OGdHakF4bENCU2RxRENkOEg4TnhwcnYvM2J2LzNoRDMrNFZISjNtQkJEVWtMZms1TWxWbktzcGg5Mi9LampoYmFPUElnTlNZNVRtcU5GVnlaTThBbGF1dUZZZXNtMUVlKzM4dzFKYURZZERKMWhHWlJKSnFjWTZSRHhkRUJ5UFNLMUlSMW9UUkhLWUNhRXlpall0b2R1TEtuWm9kUU5JM3VrS2NZdUhSdms4SERUMENuUmFIM0ZWTWZTNmZEQTBGbUdBVXI4WVRDcUk2RS9tSGtNcUJrNUlhVDFSNHgxMjQ3eTFQVEU3UFRLbVJQbDhoUTJaOGFCTEJzVzdPeDIwNHg5dU9Va2lZSTRtS203bnUrWnBuQnNEYnphUVBQQzVxS0lZNDBTYUZGanNRTDJHUWtoZFZKbk42Um1rTmtXY0c3UTdZbTBja1hXVW1jd2tjQ3RUYzBjdkhKN0lDY3VkMWx4N0RCT1hMUUVFZzd1SU1RRWlXdXlJTWFEd1lFelFZOXJwdDVBVkNBckdacFphTnk0NTNYM1RFOU5yNnl1V3JhVFp4b0h0TUlVN29ia2Y4eVBQL2p4ZXIxdUdSWVZ2Tkw5cnlOTnRWQWhQeklTd2Q2V2laWXFkQ3ZEUDdiOW04Q21Vb1NVbG9INjA3TlpiWCtpOE5kNjdQMFpOejgrYzEzRDdtYzhTUlRMQTdtaUtOQ2RkclhrYWQ1Y1dpRURic3FlaGh2bFhXWG1UVkFSaHpXYWErQ3FXdGFPQ2Y1U0Rtak81dWIzVEU3VXI3djI0Yk1QUDZLYkxFeVNwWTRYeEhFUWhYRGNtT2loSTgyTElDN0ppR1NtQjVMRE8zMk1NeVVyV3ZISzA3TWxSOGRHM2dRN200TEF0OEFmbGRLeGVNblVEdXpiMHk1TlRzL05uejErSE9XRDExWTd5d3V1N1dBL1hCaFZKNmJRYis2MndVODJIQmNPK0ZvY0xKOCsxVjY1d0VxMXVOMnhaK1loMFBkWGx5ZXZ2Wkg1clNqd0szdjJ3NGtkZUlGaFc3WnB0cU9vT2pYRndIWHdPbFBUYzFFWVFzd0FkN0xhN0R4L3ZuSEZucm50c3hlV0E3Wi9BQ1ZYTkt6OTJ6T3pmS3d2a29uamRZREIxSlVndW8xZTkxMjJwRExlYUh0b1NzZjF6U1lEblB3YmRQenpuc1lQUEsxTzFObU1XSERRaDVDb1RkWHpZRmhPVjhBR3VyV0x6QWNEaEFFN3NQMGU5NmNteXErYVBmeU0vVmprcmVKaHBpRkRMYVBlUEVrWWRmUnZOWXpZOGlXTHRCSkpzbXR1MTV2Zi9LYUJENFN2UC9mY2M3Ly9CKy8vOHovN0N4WlQ5UlNQL294elc4VllxTjRhcXgyWU9XeHBNeFdGYU9ablAvdVpoeDU2NlB1Ly8vdDJ0REYwTE9ZeFF5U2x1Z1grNlVyTGE3UkpNQWQ4a0REaENzU2dJeCtXcnB1Nm9YdFJCRGZqSWs3R01FbWdubzhFQUphdzhMRzNKYTMzVXRpUGllMEVFYzBwRUVWeHZaS0NsVkJONFhTRVNVcjlKWXo2ZERnSjlhQlBoNFRLZWhJbVRCRXFVa0VhalJPWTJKaXFNTWpoRzJwY09WV01BUC9ZTXdkVEEyY1RZVFNvVXcvR0ZmMzFZUktiY0FUVTV1WlhYM2hXU3p5Tm03V0tvOXNRTDdDa2pKbURLRUphUFBEMkt4VTdDTFcxVmxkbnNXM3lTc1V5Z2tiUWJyajFhYng2WjZWU2RqU25KRkVUU09rUElXdWVnZDJQUk9FamtTbGNNVVRHR1AvSUpBcDNIYjZtTnJkN0dPOGJmRFdzak1BSENnaW5JdXBCRWF1dHlLb2hiZ25tck9uU05sSEtPVFNNTGxHZDZBWGJmKzIxMTl4OTk5MFBmT3dCZXZSd2owa2U2eXVualZTbWhLRVJJNU5sSG52dU9heHhtcVpLTUdzWmFJZWNYVlJLTnN4ZURrd3h4U3J4NjdHbDN6UjVRNEJLem50VlNwV2wxWExTc2g0L3J3cncwVnhidXJsdjk3N2l1U2xvcVh1QjMyZzBBdCtqUHRnOGo2Q3hRckVnSnd2SUQyeVJOaHh4SmRIVWFEWm1aK1pHaWZ5eHBnWld4SzFOMUgvZ1gvN0ExeDUvc3QzMXJGS3BFOEdOQlFrUnppbkN3b2dxUkVJcUxtSnEvczdhUjNjNllNSFhLdzQvMndxV3orM2V1ejhVblVqeXlVclZxRmhoRURSOGY2YTZDemJKWXF1MWRQUm90OUZ3SU1id091M21Nclk3ZzlVMFRGanJTUXdCMGxxbnVRSkdIWndIY1BJdk5EQzN2N0xhbnF0UHVQT1RpVk5lT3ZtaVVYS05Tclh4NGpIRExaWHFrM0IweGxHZ1lUYzR1aHl3dTFiT25DbVhxNGFtdC8xUWQ5MXU1TUdCdGRqb0RKZWp0VFpzbWg5SWpNc2NwWitDQUh0dGZ0U0RGcWRlZUQ5TVpMMlp6Q1FEbE0rbkdUdmtiMTFQR3BFdHNGUWlLcXNuRFBvQkVNcDJ1MTIyam50cWZRMUxuUzQrOW5WclJkQXJWeHJoZlBENUZLWXArV2hhUGxJVFVVWGN2T3ZBWnlkMkhXczI0WkFPd1puaU9jb0FuM1ltY2FNS3RESVR5Rlk2c21KQUR3Tk94cXV2dnZwUC90UC9WYTFVMy9lKzk1V2Rpc2ltalQ5TXhoVnp5OWx2b1J1QUpsL0xpNm53Q1o3WCtjaUhQL0ttTjcxeFI5MDRZUHVqS0tpVnJiTE5HOTFPRU1Sclh1eER6RStDN29qalErSmRpYUtOQXNYZndEZUh2enVXVVRKdE9PdkIrSnM3eC9tclptUUVlYVBCeHJreGhjeGdpVUZON2FnemhsNE9HbmdLK2ptUjl4SExvNFpRWGFkY25qNThKVDRaQ0tCcGc2TUxvcG1DVnRYeXlaT3dxN0dhZ2xBZDdLaGs1TDhZOEtGVVQ2REtXYVRSYTRFWklGMHhUREtKbFRXSzViQ0I2TlJsQjA4LzNJMmJUQ3ZqMmNSRTE5YUVXWEhqT0l6MWhHcHRrV0ZHTnBlT3BGbzVHRzZ1RzNFMzZqVEI5b2VkWnRocTZsYkpNQjFtRW5NL0FoWjRIRWJnWmltdlRwSnNJMVgzWUJvb1ZBZ1BaL2J5cTQxdEcyMHBOeElsMGpaMGlLRzhPT3o0U2QxMXdTSHhRN2JhanFkS2xtTWc0ZitFYVRZWjVzMHFqdGx1eVN4aG1CNDNyMy85ZlI5NzhHTnAyMnBoeXlHa0VoTW5ESlVUa1pDS0s3THFoTnhXV2FEeTFmRnBreTZBUWJMWDJGd3NCRXVwTEJUNFl4ejZiMTcxVHpVNysweC9NY0xoTXMrckNwWVNoaW40RVQzWUhrSUZnblg0VXkxWEZ4WVdXdTAxWk9ZZ0c2RmwvVk1aeEM4N2NIbGVFdUFLcWFlVWd6MGZpL1U3cnY1bThTaDhqdS81Tjd6cTluZSs2eGQvLy9mK0VKZEtnblNvVEdoeEZPRktwNjdXb3N4cmhLMi9ZclRhRUVmWWoxR0IzMTFadEhmdk5zcHVuTWlWNWNVNDZIaGVBRWIrUkxjVFIySFFiRUFzenAzU3hQemVHTlB5YmN1dE9wVWFPTjZPYWV6Yk5lVTNqVFhaMVNZcmNFcE1PbzRzMTFGMW8xWUs0eUQwZGFlbWV5c1hyUGw5NlBSNzdlcWVnd25seWNHdjdYcGRabHExZXIxeDlwVHIydVZ5dWRsdVF1emt3NDk2SHRPRzVTekMzbXJkaExNbFkyS1dSZkw4L0hFVjRIR1oyNWZKNUdEcUU0N1dMT0dkTlkzeXRNT3ZIeG5hTTVhby8yVU1iMVkyNnk3Si9KSjB0ZkZDY2FrWWhWdlVQaDRTN2NwNnlPcEFxb0RuTkhxTUZ6NUd5blU2bGtYWFZqVVpqV1Q3a3lRdy9PazlsU3YySEhoeDRXUVMrTWpEZ3hvOHloQlRoank5SjU2WFUvSXl5aGJqVjM3bGx6LzY0WStjT0huU3hseFRvdFFIUktiVkxQcUJqbmtiWVo3aytmSWpYMTVaV1oyZG5SbCtZMFNJQWdzcnJ1RWEydGxHY0w0ZHRvTWtJZ0lpZGRvb0hRR3NHZk1VL2dPSHUya2JqZ052U0lOSWR5UmVQMFFQcE9RR21mSXhwaGNJN1lpNVBwMzRrQWhjZ1AwRkJIWkRqbDdxUDRPandTeVZMcnZ4MXMwa3hicHI3WGpwQW9vbjRHbUZaSUh3VWNnWXFEdEpHREJNK0d2Wmc5VjA3QnJnTWc0WlF0MlY5SUttUks2MkhkWExEcGZuZHZ2TjViQVRNZ1AySHZoOFZoS0JNeEdaWUt0MW5yQUl4WG1UUkRmaFBpeWlGYTB3Z3dlZE5majFzTnVPQTAveEdDS1dEb3lqWlVyTWlaQlJGTXFtWXRsUXFSZWc3eUtZV3lyUFhYSE5jQ0Vqb3lvcXhQdFJ6UFE0U1ZrTkxkTUpTVHBBSkhGSk54cEJVTEtOTnF5RFFJSVBGUGZYVmU5NzQrdW5wMmVXbDVaTXhBRHlYRUNNTUVWRS9JQVpoVVFuTTZNUXJUSmw2TUNNTkhoVjJJZWpxVk9KaEJoRWdqa3RKTFRXbE1TV3lPWEp4NlAvQlJLcWk4dFV2bzhQZUFCOVNkRXMwY0p5aFJhNVdlVlltNXViQzVFSksxVGNZdXBsS1FuVVZBNVdwQWdweWRjbGswa2hoc3BZTzdIOUdkTThTYlRnYTQ5aS9yMXZldjNqajN6MXdVOTlqdHMyaXFHb0ZtamMzNG5xY000N0VYa21ZRENLODZUcEs5MFFybGllbkRseC9MbDJZNm05dkJDQTIrMTNOZE5CMXdvN2dWeHNwSFVjczF3T093MDQwaTNiZ2Y5cHV1SDU0YXRmZGMxLy9KWC9BZXNpSkNSSWJrb0NianBEUGpIdmw5NzdoMTk4K29WbzhSeFk1VXFwbGl3dFNHeFhReVZQditPQnNlK3VydGkyRzY4MTRHaXIxcWM3elFZY3IxTzdkM2VFaU51dGtQcU5oNXNJZUc5V1JNbTVuUFl1QS9scktaZDJmeEU5NWVWVVVRM2l5UWlObmoxSHJtQjFHYU5NbXZCZlY0OW5ROUQ1YlIzOTkzRkY1MG82bVljNVVNemhWRjhJbzdaTWxULzVlc21KOWYzRy9SbW1RYWFqZFRTRm8vYjRZVkZZeFBha2ZlMit5KzF5S1ZiYTVDTGwxbEJjSlFxM2dpd0tsTS9NMmdDM09lSm1abVp1dVBGSW5JUTk5UmtTWTVLRlZzVWVIWktXOW9NbE5NQWxQSEVDM0lZVE8zbzNWR09Md0lwM0k3blNsYXRlNGtWQ3lTS1locDZIQVJIYUQwa05DOWcwYnhoZ244QVB0UXpkSEcxQjZBZ3lvOG5GY1lKbFNGeTVtTzVXRGFxNlFjcEI4T0VHMFhxUWtCMmpFcjFoS0VZQkVVVmJwQmN4ZlJnalJ6S2FkdkxYME4yZ2xoRUUwWVVCdVFJNjAvVkV3NzRabEJERUhnRncxUTNUTUlZVUtyVnI5ZXJoYS9SU2lWc08rRE9veEJUN2tkY0l2YmJYYVFWZENMWmhlaGpUYUtvNXdyTE5Tb25waHIrR3RJeGhwMFZWZkRPaEtGcTNERXFBQy9WT0tadGpNc0kycXZJcmNSTkZUbjE2MXhWWEQzbmlkc01RbVJIRDBNVHlrNTRnS1M4SEsyOFR0TUtQRWdWVmhkT3M2aUJYc21Qb2RqK3YwZFZYWDMzMzNYZWxkaVU3WHhTdEdDYnJTVmVhVTh5aElnUDFyWjZGU25jMkhpbUNzS3dLaGFnVEVSWkxhYS9FT083ZmFCVkwxWTBpQzhsdTFldXNrQmZyaVUweVVJQVlwRFZaWjBYS3BZcUMyZVRIYU1yRGlLZVp5cGp5VExXaDF6K2R2eVZZVmp1ZWpHcE9JL1ZXU1ZWb0NHUi82TWYvMWZ6dVhaMnVsOTlBandlYTBSR2s0YmFWYVEvRGFGQS9mbnF0RzJyRzR1bGp4NTk0WlBuNE1iKzVKcUxBc1YxRWxobTZaYmtPbUdqWHRWd1hZZ0FKaHQreWRjdVJYS1ZYNGJ3eFp5WnJzNU1UdSthbTRjL2N6TlRjM096c1ZIMTJzclpuOXk1dVdacnRDUEFrZEdRV2FTMmVnOU1BN01JVWlpQklyOTF4SzFYNHh1cjVzNVdKS1VGaGRCVDRnZWVaMlZzY1BwMEJONWJSM0JhejFqd3YwOGlNR0tmWUNFZDBtbWlHTWxhZlFqeXRHanFVR0ozS3hhTEdpdW9qa0hsbi84aTJ2d2pOSzVwZXpyWktybHEyelF2ZVRlYjVyZitjclZvSEIxQVJ1ZWV4ZGJGL0c5dVBqWHA0OFBNcjkxeDJjTzllYkZJRE01V1ZTUlgrV1hYSDZkUWlFeFBNU21RVVBWcy9vMUtwVEVWdUtUS01yeEpDRnlsK1kyT2VUaUplTUxyZHp0bXo1M1lZV3VBR00vV2s0UWROTHdraFFxUm9HMk54UkpVcnpnRk1XS3RuWm9QakNSNjBoYlRZcGpHaStpcDVManBxN0JGU1NjWFlhQmVvRjU5ckZqeE8xRWVXWUI0UW82NGVxWW5RZkd6V0kzRStiU3ZSYTh5djY0Uk1obTFyUVlDaWcwRkhacnBFTmNBZ2sxK2NhTWovb3luWkhwZ0kwdWNnQndCZFp1aGN4dFQrSzAyM1dwcVlOS3Qxc3pLcE9SV2pWREVjT0ZqS3BvVnhBM1p3d2xIaWxFelhoVCs2VStHYTQ2OWgzTzgzVitBMmRKUU5zOEVZb3J3QmlkeEN6QUVIa3VmN2xBNUpLZDBTSW44RWwyYlhvYXRLdFlsaGk1MHN0ckQ5aExoZ2t4QStzMnhacWl5czZEeENUS2hnT0M2UzBNWG0ycWhzcC94VStYajcyOSt1bGdxeXpCUTNtMVJmRm9xeVdyR0k5QkdMVWpSQnlCVk5CYTdxWkZjYUFTcFBZQ0JubFRHTyt6Y0V4OUZyNHF3UTdxU0U1Tm01UENDU2xvbC84bTJmSnpGMFoycUF4WndxendrRDg0NTZtWktyRkc0Rm90V2RJdThVTlJHbWdyS0dSTENBQjY2NjZpM2ZmNjhnbG9pWWVzL0pSTUZCRkVIY3ZXL1g3cm5KZXIxY1VkbE5hNlFlc3lpS0c2RnNMcDFmUFhzU0R6UGM5YW9pak4za2FQTnR4eTJYbkZJSnJvRWxOK3pDai9ESFRGc2h0eEp2MDNvODNHcmdlMUhRVGJvdHB6b1pkN3QrYTgydDFnM0xDYVBRTm5TLzI2cFU2bzNGczJEUExMZlViQ3pENXhtV0MwY0VoQWNHUlNCSm5BeHQrMDBGL3NqZWUwKytNYTAyc3p5b0xZYmFLYnNmc1hHSUh0cXQ5eW1xYjFBeE9paS9MKzBrQkZjQWp2bWQxbmNHeFFYNnJYSlBnbm9UNDIyaVZyd3gyUG9yUlpZQ1l3TWdnR0pNdjlsMVZWY2tNV1N3cllWRGg2aGhtMngrYnVxNnZWYzk4L3p6TXU3bSttYXErcGEyb2hJZENuVkdGWWdUdHNUMXJGQkVxQ3cvS1FWcUxOUFVVdFUvTHRsQUZpWHZ0b0t4dXJhNm81Y1VVdmNXSENWZWtIaUJDR010RnBHSkltd00rK3NUMFkyRktqbXFoUWJMMUdRY2FYME5vdnVCN2JGenJKK0NyQXM2K2szRGpsR0lCeUY4QmxIYWs4WnNCZ0ZFWHdCNVRmRkVJK1lqMUVnME1QcmY0bkJESElHQjhUdmFLdXAwd3ViK09LVDhOSUxlTk5NUlZGWGtLWDhadVRzb3ZxaHlLZHRKYXhWR1pjOUJzemJOWWw4a0VkTmpzUE5NUkduaGdCSDJreWVZNjRZM2htaCt5b0k3UFBZN2VQYTFXMHgzOEdhU0dHNkhFY0pmSjBBQzlocHdkSUN3amtEb3Y3Uk5pc25kMXg0Wi9rRjdvWFFsMmw1c09HUkdHTVZJOXNOWWd4bzJTcWJXQ1FNdmtZNmxnUzhVUzFHeVRiNHVYL3o2MTkrN2UzNyszUGtGa3dpM0V5bTFZdktOVkxKeURzMGN2eU5KaVNoTEZLZGs3RHpua3MzK253Z3ArVGpvMzlMNFoxM0xxWjJtWXo0blBkVXlIZDVpcVZWdXY0QVZZMENhMlZPc0RlbUIzSy9sbW5NSXBxck45R1ZCc2VTT29FVnBIMEtLUktNZGpVbzY4cC85NEZ1YnEydi83MGYvSVpTd1gzZzNDSzg4ZUFCMmhPLzV0Wkp6MHl1dW5OMno5LzZQUG1qRWtSaXB2eDhXdmxHdWFtd2hXM0prMjhBcGQxeHBPVWpVcDhFbXhKS2owRGg2TktFd2JkY3BseUVZRWNpaXhpeVdiSEdVZ1prUG1nM0Q2OXBUdStQbUdqYmpsU3R3b2htMjNWNWIxUXk5MDJtMGxpNWNmdVMyRHV6M0tBekN1RHBaV1ZpNElLTndhdGR1K0xuaDE3OUpBNmtHdVpabDlGa2gwTmNLMXBRWDBRQkt5RHRKa0ZCRnk3dnQrOGlnK29GMXJPY08yb1F4SEMzSzM2U2RMNVh0M2l4Mmg5blp0aE9HMFdERmlNbE1LcThQUzdpZTlvY042aHZKL2xJYUc3SGVueWpick1ucWxIdmJaVmQ5YXU1cnF5OGVkNFZpRXlUQ2hZeU1GNWEyaGkzbldpS2lITEcveFNldnJhMDkrOHhSWFRkNTlrcEYzaUtaUFZSQk82VEloVlFVZGRocC9CUkwxTzBRd21oN01keXNGd1JLZk5ndzlCZ2ZkSUtNRWhqdElSdE1nckF1ckVzakhZOWxHdVRFajBLeVRTRW52QUxCaFNLTFJMQWVTL3MxbFhBUjVSdFUxNzlValdDS0haWU1oY2EzNVBiR2VtVWNSOVRtai9sUGVqUkpIUE1rellsUjBVdWtaUzRFRitoNERzSnhZSEFaUjdrbEcyWTRFNVBPMUs3MmhkT28vZ2szRzRlcWVVQXA2S3J6VzRrNzZaYUQ3UnVVYWdrOUwvSzdYcnVsV1M2OGJnaTZ1VzdwQmgweUFrbkhFYXB0V3dvMUVsT3hINE5tbVREYm1ibmkydUVmZEN4a2tBak5RUGNwakxFcVgwcGlGN1Y4ZVJBSjErQmxWd3Zic0RxMWliSWpaYmRzb01MaXdLZnMzcjNudmpmZTk0RVAvTlhHanBiQ25hUENzbG5VenNxMkxDdWdrQkRyaHlsczNINVkwaUNYam8zRzFmcXlIN2o2QzF5SVV2WlNwVHhqUEVzejhZTkN2Vm1WYUl1TlQ2RjJkcGlxcEx4aVYxYXhGY3Y2dndhRmY0aGpVR2F0aFR2TTltVjBNL2s5dzM2dlRzNzl6RHYvRFJqNGRyTlpxMVVmK3R3WDc3cjdWU2hXeFpMTDl1Mjk4WlczZnZCRGY3L1c4ZTY0L3FvRHM1TWpQTVlsWDNyY0REdHRUb3JwZU9MQUFhdHpvendKdml3MittcTZCMTU1RkZtY0llT1laWmlWaW1GWTJIRmJxWXBXc3kwMmZaU3c0NlBRaC84elZOcDE0clhGeXRSc291bGc0a1VVd0ErVXk5V1ZGNDVXWitaREVhOHRuREh0a3FHYmptVkdyVFhkdGR2dERxOGFVYktEUGhmTHNoSFpQZ2hpbHdVeXhtS1ZQTjJKTWFGNDRwUkdpMmprVS95bTVQMjkrSU00RW5BNDdKMGwvQWZjMEEyUmV0dVhVMjBISGs0TzljamFEdE5tcjBLTkl3TVB5TDZDZUwreklqSS9LU005U01sMWRtNzdpYVFQTmVLNEl3L3VuN3Y1MFA1L3ZIQkdkSEt5TGJ3dGd4TXp2TklKVmhuWDN0dmE5SlAvN3UvKzYvSGpMN3B1Q1pQaFdpcjlvNXlYdER0Z1hjK0RnaGZHQ0dKSFI2WldyZTF3UTRKdFNCcGUzT3dtelFBTHlnZ081eERaYzZ4WFlDMkRvUWxpbWk5VWN4YVdvazFLb1JNaGNUUmF5S1lDYnNWOVJBaDVBKzBmelFkVDBFaHFxS1ZCSVQxQ1JRYW5LYkVLdG8zREFRODdER1BMeHQ0RWlPNDVvZERoaHVNa1ZLQlFocHplTWI1bExRVlIwbXgwVFJLREhxSXNoNTJJWVpuVm1kM2RoZlBJVGdoM2FTQmhBcWJtMDFNT2l4WUsxRWk5bitodGFoWktldmpOQnNUOTVHaUJYNFdOY1V3cFBBdWtoa0E2U0t4UkNISjZFSVdBQVlrWFRlNC9YSm1lSGZvaHczdlU0TFljRFFGM1Zic01qNmJwQjlNT2gwQS9qS1FmSkhBVTFXMmpnNlQvcU9aWEFRK0VpWUhwdzV2Ni9qZS8rWU4vODBGNDl6ckpVcXZTVlpaakZHa1RhMzYrRjFESGpMb0dzeStpempWSldvaWNZdzRjSmI0ZHcvWjM1ekN5RXJ0Z0l2ZDF0U3gxeUdYSzdrYVdtTXYrODNyclFJMDAwTG9LTnA5WEVqTVZlRmFvSmVkTldVVk90RTB6cTl1R2cyd1FrVTZKbnlUV25kTGIvL1VQUTJBUmhzSDN2T0YxbUxlendPeFdZYzgyV3Q2RG4vaTB6NHdYbTFHbFBJcHcrWXNkc2VMNU12U1IyMHN6TVA4SGk5Z3VsV3QxQ0E2UzFLdEdnSEdRWUYzQjBwZ2QrN3dqdEhMZE12WGxLTFpMbGMxdGZ3S2hQSnpPdWxzSy9GWVkrdTdjbnRqdmRFUUVUa041Wmxma2RjSW9Oa3ZsNVJlZjA3SE9vazNQem5SV0ZpMjN6QzBiVHFVd0NFUWM3OGoyRDZqM0ZwQTFyS0I2bCtuYWNCWDNoekZDandSUDJaOEtQbnBCREZwbDB6bnIwZTBoMjdscDdlUmdUMWZsZW5MSkFUOVNHYlhORmhMaXJrd2pSSjAyVmt3N01kNG5zODV6K3FzMHo1SE9IUW5FZWtpSVFhOW1heXU4VGIwMzFldmpiR0t1OXZycmI5cTdiMC9JQkJ6ZU1WVmxaZGFiaDI0bW9yVmpMUHFxdWpJeXlHN3c0YkFFUC96aEQvL21iLzRXcDQ1bmhVUFBFaDE5bTQzMy8xVmtUalFpNFhWemJtNW5mYmM2SmQrYmZoZ0s2VU9zakQxYUxNSndBd3RmZUxkRU1VUUFCazJGb1oxSXRlRlNJejd4UFk5aStSV2VnRWozNEQ5TnBBdEFyQjNXNXNIT0dTa3ZRdHI1VFdKSlNzK1dQSTVrYTZnSUFtSmRCNDRQaE1kSHNRQ3ZISHZSeU9KZzA2QWdEVG1STHBhRW1Jb0ZNelN3dXJHQkl2ZmJhZmoyVDhhZG5aZVluRmVlcEM2Sm1aZ2pUN0NsbTY0R3NZVmhLdm9nWlBJaUNudTRuYlZ6SitFR1lOYm9seEI4Z21YYzJVanl3MDM4TFU0T0Y1V05ZRDNEN3QxMTFTdU1vV2xWVUh5Qklhc0VyQTNzbWNFQVcvaGhzTkJ1VTg4L1NveXNla0VrNDVJcFVBbEpZa1FFNTkzNmo3cnpycnV2T1h4WUpwR2hLVTFwVVlBTG9UeFZ4djJjRW1nTGV0cGExdmVTcmVFTXdFWnRoQm5UK05qdWIxWWdGK0Fyd1I4VDFnbFBZRStZSFA0cURBNS9GZFRTak4vbFdrckJxOXB3VXRsMnRwVkNlYU81NXZ0ZTduNE41QXpTR3JES0hCQnpjRmF4WVFVOGg3WlQ4NS9GVzMwaVE5a3VKNWNiekl6bFRPK2FuNXlaTFpXcjhBRGNVdmtUbi9qczhaTm5xaE9UeDA0dmZPUFl5UkVlWXlpMWRxTUp2cjVtS0NKUkpQTTMzWXJsVk1BQTIyN0pLWlZOMjBZT0g1MG5sdFBXN2JiaHh2QnpZUWM3L1VvVDloWklOem9GWTYvTlRTc09BeXd1V2hBbTgrN0tDdmd4ZnB3MFQ1Mm96TzBWN1FhNDFLWGFSR1dpbnJTYlFhZHAyWGFsVkVJeURFUUJhenV4L1JZeG1NbjExclNZOXgxSUF4TjhPRVkvTzMwTHN1aU5KWVFIVE45THh0cXAva3JkZmNhT2JEL0xzTDFrd2tSQk4yQ1EzVytMSlVTY2RaYjZoR0tLYThOZWY1SUFCdE5BcmVPSURjWDBxcFl6V3ZaL2JONEpPV0s5bnlyNnhMRnFXemNldU9iMmEwNSs5TXlDYUFYWU9KN2ltZFBrQTVMeTl2WWk1clJYVjlkMEZHVUJieS8yUEc5eGNlbUZGMTY0Ly83N1AvS1JEd2RCNURndXl2d3FRcjNNUnhiWnExQjlWTGxmcG5oVzZTbzZiT1lEQnc3czM3OS9oMVlZYVR5RENOeEMyczlZQk9CQkxJSkVtZ1pXcUJNNGYwUVNKd3B0ajc4U0pJb2JMS0U0UUJzTm81VVZOUlJiYVVyc3g3UDZuSG8vbkFRUnBPcHVwM1l5VGJFTjZEeGxuTnpVb3dGelN2U0lDa29UQmdSMVJTT29NSUFzRFZNVmRXSk1xbGFDZXMwRkVqRHpRYkRiMXFNOFBXdFdLaklKNEhvSXlhT2NFQ3JWSW5hQlFMbDRMVXZYVXdvV05idm1tZU9JNXpCTTBtZkJUQklqZDVGUUNEcDFRUXRLalVURWRzQ2pLTlF0YS9yUTFUdDR5cmhDUkFjZG9LUlNzcjA0Y1hRaStwSjZFQ2NWMnp6VGFNTzVFOG5FdGpSSDZLMEFkeGc4cy9WcGxYMlhYZmE5OTl6ejVOR2p5Q3FEelVLSjhxalRydXZVTUNEOU0zVm5FWWtGenlCRFdWdUtsTDJRb2xmMDFiUXh5SCtUUFVJRklwa3FsNmNWTDlvdTJGUkN5UUNLY1JLV2ZqT0ROMU90WU1OZUZWanRZUGhYVnBmeVF1SVdjVmpQdExCTW5sRlJDcEZKMktudEo0SHlkYjNhT1JlcVNKTS9VUlNyclExWFdseGUrZGduUDJQcUJ1NHF5b0tPOEJnaG9sazVlNUtZUHcwS2h3bFZhNWZoekRNTkZ3VkVWRHlwOFNoSXF2VktGR09vQTU1UncvZkF6WllRRXlBWDNzYkJCaXFBK3gxTzJ3SE41TVIwN0hlRmFXdWR0alk1SFMrZlF6bEFHUVd0Sm5OSzFYSUZQUEZtYzJWaWVwZWVRamU0VWhmYmdVZUluWDZtNThYcmsrcnJHL3lLcjVqNDczb3ZmUDNyb3pkQURQTVpJQmNONFE1UmZoblhSSUZpS0UxSnlHSnpuVnluOEx0UjJ0L1Z0RmJXNDZJOFcxSDhsY0xzV0NwR25EVXZwbTF5ckVlSHlZbytDTjhxN2plMlRaV3JRaXpUWTdmbTNuM1Y5WjkvK210cnJWTVFNQksrU1U4MXl1Z1dpZk1FOTVYcmxyN3lsYSs4N25YM3FDSjlRam11eGxyai9JVUw4SkdXNVlBelNDM3AxSFhKZUtLWVQ5S3FOMU9aUGNWSW96bzMxTHd6M0tlNDdycnJabWQzRnZmRDUySTlPTkc3SVZoL29ta2pIbUV2QlB1dUs1ZlFvdE1jZlE3TXhHdWRNSTR3eDZDREo0SVZ0SkdBV3VqSEVHRVdjZFhFUE85WGpHTVZEU2RrS21qbEtWYzBTd05nMmt6Yk9xZEpTSDFjWjJpbFlDZGpxamxPU3lkY0YzQmQ4R1FST3BTazE2VVN2VVpBZXpZTVRHcWc1RitiS0UzUE5TK2N0ZUgxRWV1NHBwcldxYU1KSVhzSW1LRGJ4aFk3NUZQRlVrdHJqVVFkOVZTNVFhU2tISGpuTVBjbzBKRTFnbE5IQktjc2s2eE03NnJQNzl1SjlaQmcxQnVDdGNNNFRDUkUrQkRueEpoTDBGWTYzcVRydUxaeHZ1VlBXR1lZeHk2Q0FFVmpMWlRyRkRIVWVPUDN2Zm5QL3VJdk5FVW1veEZRbis3VVJJNWVRbEVnNEQvUmxIaGZGak1pRW9CQVlka09WOUxlUE5lOUlIR0hSSTV4L2h2Z2l0STJlNTRCNVRJbFQ1TDFJeEFKeWxPUWY2blNZam1BSzRtamRxdEIxSTFTUlJFSW5nOTh6L2VDd0tjVW5yWStFNnVPN0tMVGtIK1hMRGVSeXRBQ3NHeHo1M0YvWDRTYUkwSzRLbHVvS2tZcXRvcUxDZGJxNTcvNDZMRmpKOXh5R1Z4eVJtMUJJenpHYzhlUHJTNWRtSnFhU1Ntb2taKzJKSW5WdUF2VzNYSTRWV1d4ZGJsY2xlQ01PelpEa1pnd05OMXlaU0tFZzlIM05zc3pFdTJZSVdKVVF3TTdibGNtWXE4RGF4M2hVSmJwcnkwNHBRbHZlY0dxVFRuVkNWdmpmcnVyV2E1aHUxSHMrNnZkOHRSTUkvQzdPOVJIdG0wbjFhL0wwdmM4Ni9CTW9aVDlVYlZTMjRKWHp6YWh4MmVGeHQzVUZhTzhISFgzMlNNODgxNmJUMVpLSUswNjZ2SGtlZko2NHlDK2tQYUhZUVZCa0FORk1rQ2lMQzVPNWNqSS92aSt2Njl2MExrWW5kTlhLdjVaaXVmaktMSk4vZXJkZTY4L2RQVkRKODRaS0NHUDFXTUsxRk1pcXBSOGdmQnFyWGJuOGNlZllFV0tMc0kwcXNNeFVTeCs4RkFTcVFqZE1yK1lrOEtiek9qUW1NaDlmQlYrVWNYb3pXOStzNzFEWEVZc2hCY2l3QndwaVNNMFVCRDN4Z0pDZi94MFN6ZXhZTUUxNHRzbFh4eGRGZ2hGbVduWTlQVmtsS0N0NEhWaW96ZWlJekNQQWc4Qm5xZHFvY1JOUmVvUjlHb1RRamRwYVlNS1o0YTJqV2ZCQmNrZndndENBaE91ZmhWeFBYR0VMVWFHR1l0WUZZczAycjRNQ1djVDJLL0tmOXpSbk9BRHFuTjcyb3NYdUtJbW9vY0liNUFqRlRtcDc0R1RnY1VMZ1Z6NVhFdElvRXdqRGp6RTRCT3BMZkxqcFE0c2FiY2cvUlpYYWlzYVVodkY4SlhwL1lmS003UEQzeGc4MXJKbGRvT29iSmI5TUN3YnVDeHREYUdGNE5wZGFFZDdKMXd2U2k2cytqWFhCQWZQeGE1RWM3Tk5jZmZkcnpsODZQQzNqeDExYlljUkhYSU9EMGJHL2xTZ0I1Y2lkV1JvaVVpMTJ6TDFaNmxsbXI2d3hneW1xZVFXTVRwcVkwdS93ZDdNeVhRSjY2cW52Q3NzWTFoaUdWQmJaZ1QvcXVNQ3Z3M0I3cGt6SjlNVHRzZUFKaERPbm9veFp1MFg2L2hTMW5kUHJhL1UyaU9aQkpiem04bWVNVTJURFJrOWUrcmVhQ3dNbzg5KzdoRnMyWEZzNlRpYTQ0N0k3Y00xcTFRbGJUQUpMaEV6TGRNcEtaMTR3N1RoaTQ1dDQ0RWVodHkwRXVMUjBpeUhXYWpFYTd0VzFPMHlvamZkSk9XdjZXRHZreWpyYlBFeHRSTEh0Zmw5Y1dPbE5ESFZYbGtxemU2MnFuVVpnUS9od3dzb1RkUmh2VWRlRnp3em1HamdCenZWSjBScFFiNEJIUzh2V0VWdGdGUi9mZHA5SXpSR2NUSEF3RTQ3d3h6RjZtY1hMWDZSWnpqVnJPTEExdWNBQnNNcXh5VmdZNUZkZXQyc00vTmZSRDNrRnI3MzNjSHlGaCtsM284dU1FVXJTSzZPbGlxdTFVcTNYMzVWYlg1RzVUVHg2K1Ryd0NJR2MwNFFENHlQRTJKcUs1WEtwVklGL2podXlZVEpZVjlwaXRYSDd0TU10NStpd0RTVmxrK3hER3FUSk5rUGE2bUFGNjYzdzRldmVNdGIzckxUalJFbG91MkhFT1dUSERFNkZhcVBEcTRhZ2IxaHdxVGJNRkJlRG1IeUJoSFRrclFPQ2M4Uk9HMjBFd0E5RzFRdk5zQkJ4ckl3YVFNYkpGYVBJcjRXeWdjUXc3Nm14Qm1WbnJOTzFHQk1paTNnZmhTRXF1U29TQ0dKU1lxOVI5OGw2SExLN2Vza1VhQXBabk9XTXVvb0oyT25KZWphM0R6Y01tbGNXNXB1S1RwRU9MVGdyM0RBZ0p0dllCTzdRU2hSOExTSURvY2pKZ0NPRlNvSkVEOE82UmVUc1U5b21reko0S0oyV0F3dlNreGRmdVdPamo4REZSZzFIenRsUktjYnhZa1dvV3hvUXN3VFJ0TVBUNjExd1Rtb3VOYVpsWERGeC94bDJUR1FQM0dqNmRlbkp0L3dodGVIQ2JxbldkSVFYYXdZd3ZhWW9zdUVhQ0ZJZlFHN3Z5aTZWOFM5V0NaU3BHRlV3b29WQmhJdEFLa0o4N0djejBiTFdHVGE2UlJyUkJJTGNyQkF3V2xOVU95Um5xNlFPZk9PWXNIUlNKMVNWOEs3dXBLbVRudTJjZmYwcC9TTGxkMCtrdFM4RXQ5WGprdC9DOEl4MjNGM3ZPbDV6cU5PdlRxMFdITDhZRnFGMWxLNHRHMlpSNzk5L090UFBGMnBWV0diV0taVnJrMnlrV3kvYmxyZzhTTVhLM0x2b0F5SkpFU1ZRTzBPV0wxSnQ5djF1aDBFRzFsSVZ1YVdxMXpUUXd6cXpCQ2lUcitMSHNObTZ4T2ZobTA2WmJnMXUxTHZMaThZRm1wMmRadXJtRkp0TlkxeXRUUXppOEx0NU5ERFRoWW9XdVNGWHFCYkp0NVlwMjN1c0UxYWRmb041TXJYaytmTGZ1WS9Lb3B6YlIweDhnQjBvRmlVZ2F0b08vVExaZi9WaThLN0xMdTZVbXdoVG5mRklpQTJCemM0eEw4dTEyc1dEUGIxNVp3L3FSL01NaFlBbVR0RHZBQS8yc3BaM05aMFpSa0FpdWdzZm1UdjNsc09ITlJzN09RMjZEUW44d3kyUmV0aEpyRmJYYy9yVm9vemk3UUZVOWJ1SGllYXVzWE1RK21ob3ZKMFNVL0dXS004cy9pWm4vbXBnd2NQN0RpMlFCUllqTmFkT0hQVUU0TVFPSUxUaGpNL1FwMENuZlR0Q2Q0Z2RPcm1DaUY2cGhqT0dKb0NiM0JESW1rZzlkelF4SlZBT000WHVmWTBqSTkxSFFzTllEVENDRU5pdUVrSUtESEVTWmhxeDkvY1cxVHVWODV6Z1RFMGJtd1QxNW1wVzA0SmVjbDFhcG9RbWNnQzdNMDRra21FczlJRjR6dExRYnVUMDA1dEtoWlVGWUVOQXlZZm4xbldlSTNGUUZPendLY3hrYThRZXhwMW5yM3hWTXVPMWlZbURKZ2s5QS9NTUpaSXVCd1NtazdBYVR0OStWVTdqSGp3dFFWUjVFVnhJRVFyaU51aDdJQlBKeEZoWVJsOHpmUGJnWml1bG1wbDUrUkNkNmtUVzZqS3ZDbkQ3ajkvK3o5M1RiM2orekpWcmM3a1kxT3lGQjdIQ1UrWlFnWEpUN09DVkR5UnhHUnlsN0RBWWxoMUtxTGliTXp0czBHTWdWUTNFaW1oNDVUY2o1bzlNVXFNUmRxcUtnaTVTdTFBOUYrcHpGOU95WmRYU2hXRUpaTUNGREtqNngxVVRPazdaUE4zVXp4cWhheVVhOW9vVE43a3FwQ1doMHBHY0FxUGxMK0NDVElpOHFERWhiQnM4MHRmZmFMVDlUR2ZxWUZ0cllQeEIrTTZTdHlQcVZTdFhKbTBNYVd2YzJJUklVaVFFY1VoL0RzT1FqemhkTXl1NGNxTU1ZTVBoNVBBd3llRXlVZUJ2N2wvSnNMUXQ4b1RJZ3k4NWZNaWljenloQTd1UWh0YzYwRGFkbTMzUG05dE5Rb0RpN2d4TE5PTUE3L2RhQmkyYWJpbFRyc1JkMXJKVG5EK0xDWGFzOU44U2IrTjN5eUxQa2dCdVM1U0g1RGF5eE1NbzFSek4rSGFZOFdlKy9SZktkZnRaajZkZ2F5TDV0Wk4vSDM1ZU5vUnFtd3Jzblp1MlZNbllsa21kU3N2VXR2YTlLYzZabURka2U4MkNaTnd0ajU1OTlXdm1KcWJndk1mK2FHUVBFSlRBTDhVcVVlYkRTbk1TTkJFbGFVeDRzKzJKMUVBcFhBYlpSYjB6SGlRaWVXOTdFM3VGaER0WGhnR3Izbk5hOS94anY5eGhJMFJSbmk0SUpZVHphNkdPR0pHV2plcXlaM1NHNVNXaUJHdWhvUStLSFVUSkltcHE1aENIOGtaSjExcGdnenlESEdLOWc0elRJYnlBNGhTSHk0TGxnOGpIUFN3a0RNSDQzZEdQc0dXSUFiRlZwcERwaWlvUnRGQkE4eVI2ZGdhUGsrZGlCZ2lKZVpMbG92d0FLZ2VZT3hVcEFBK3NEeTdHMTVwZ2k0S1l2VEFBNUI0NWxBekJDTlNYMDNoSTZpeGtNcU5YRUVUTWhrMitEa2o4NU14WWxmOWIxamcwR1FjVHV6YU83R2pZajkxU0hxeExOa0dISzFCbkxRRGVHcEdKR21TV0VVeXk2YmQ5bEZwK09Cc3lYYllrMmRiUyswRWpxZk4zdWhOdDl4NjAwMjNRRWlrV0w5STlwQ2tLM2hDSERTNnlsK28xQlNXYkFnS1FDdGI0eXIrUjR3QThUSlNsaWtWcFpmam9IK2paWXlsUDFLdVJ4cEVPdGZvR01uVjdWUy9LbnhiVUlZbFNYdFpzSlFVMDg5bU1VTjY2Q3NSQzlKY1VBNkN0bUd3V0R4a0ZYdHMvaTM0UU11Mnk1WHFLR21NL0pOWUZyY1ZhSHBURWd6NnEyTmE1ODR0Zi9ZTFg5VkxaV2E3RVAwbDVKS1g2ak1qWEJkVGNRNHE2Qml1cTJNemtVRjZnZFM4QVB2ZkN6Z0UrN1lEUGtFVXhSQ1JnLzBHbjhDcFZJaEFEQ0x6WUt1a0ZDN3J4Q3BYOEdRT083WmJnVVVlQkpGdU9yb1E1Y25aMXNveTZoQk9UQ0laT1VvUndnZEczWFlUVXdCZTExdFp3bnpxRnZUa213YkVkaEd4a2F2eWJCZ1RiOEQ5bk1WRlBEZUU2eGp5bGZqVHp0K3lMQzZrRFcrbTRJS29ackZOVFRGeCt6dkZ3R0F6VVo4K3g0TVRicEduTEpTcHI5dWZtZGpDYW1uYjFQc3hkeHFuM1F3bzJ5ZE14N3gyLzRGWFhIR0ZYcklUa1FWemlyOGlSYy9pbnlTVEs4MGVRRW9GSkZYOUxzM09NWmJCZEF0dlMyTUZTdFJzTDhwdXQzM3c0TUUvL3VNL3F0VnFvMnhJOEdyanhFZjRBcDdjeXRzQWMyUmdlemwrSllxcEs0MkFjeVJ0TC95SVJURlhJRVF4b3FnMlpkMVVkcDBNUGNJZDB0Q1hGMHFNR25Ic3E0SU5vbk9rdWlBZWNQbzJBVWJHYkszYmx1MDZtbTBLSkY0MmxFNGdndHV4OFU5azJoV0NIamlhWjhxaGpOSjJWcHFhMHBDVWlaTGE0QzNCNDRLcnVTV2RaSTdoV3hJUm9HREhqWFRUa2dRRVBqd1VBV0pCcXlXaWdMTDlkR3FyU2twMnlFT1FQSFh3c0xGRFZ1MkV1bHdySnNKUEFrSnB4SVI4YklVaUZJWmpHREhKQm5jUzJmVDhLM1pOVmwzNzIyY2I3U0RlYkMvV0ppYnV1ZmZlRkZGQjg5RjRnUWVHK3MxRWxxZU9LR2xFcG9zcHNsK2xGcE9ua1JFVFFEVEFtamJPK1c5VmhTM1llbVdBRllJNDVXVkpDZHNMV0gzMVcwbUJRaWMvbDlOa0xPTTVUVzkydlBRTVE5YUNvZEQyUXZXdTVzanRxY2xwZ3F1T1dNVlFWZHVFV0RRbHo5dGFTVHcreTgrQ2svNlJUMzVoc2VXN3RVbGhtS3B4V25Nc1l5UldlU0ZqcDFxSEVOWXl3Vzl4MGVuVnNBQ1hFc2ZHdE5vUlZnQnhPWUlNRXR3VVZBdEVxZkNZQmI1TXRyRE4wcUFxYWFsYVIxSVJJVnZMNTkxcUZaNldWYW5DQjlSbWQ1VW1wekY0aWpCb2lRSy8wMnBNbEd0bDEyMmNQV1VRNnd6R016dTIvVmJXUVNaNUlXM1diMTl6NjVqYThvRXlPUnRRaDhsZzQrcUhESHBFbzdoNDY4ei9abEY3ZXM1dm1UbDJIRmRUa1ZLL2RXQ1orUFQ2a3NlQXJ5UDdRZjcwbjF1SmgyMFQ5aVVGcUNDV0xsRERuTTFOejkxeCtPYlN6S3hTUzByUVp3d1RSV2xDZk9aSVRhOHhucVU5d1h2Z3Vkd2cxVHlvRTV1ck9saDZSRklVaFloMzNTRE5iaTMxOWpVTnFhU0Q3bVdYWGY2QkQvelZrU05IUnR1TlNPYkt0R1lRZTJGSVd6SXhUSlJrazhTa0cxTXdnVzRKbGZueDZEWVF3OVVPaEVyYmNVTWZBWUNUeG5vYWlVaW9Sa3dxL2VjY29seW9KeVF3UHNSd2trSm9sSWxWZ0Vlc01XOWhMVGlDQnd3RUVHQjRENkVuSXh3QkllcE4vS2ZwT2xpQ2poTDAzNmg5RVNKdGJLeFVwbWlrSjFtcVR4cXVqVGdGeXlWMlhyaGpzUHFtWnRwWUF0U294b0dGQUtyMlUxNWRVNWtXUW5YQVpzWnlyRkJPb0lEbmFxWlNTckFNWXJqNSthdVBqUENjWVVHaGxGOGF3TVZoSEpsd0E0a0dGaDRlQk54dkV3WEo0MVlBd2I4OE9GMHRXZHJKcGU0V091bjMzbmNmaEZCK0VBZ3FYeXEzak1UNGlPZUVLZWtLM0FGSUlTNXhnVEJCcmlKeUZiRXNDUzN6bmF1NnU4YzUvKzBjQUY0NFNkT3NsdEkvRkNwd1VJOHljeEhFdXJ6b2V0aFhYMzVZcHVsTUtYTkc0Rnh1TmZWQzRkTW5KNmRkdHp4eUhrTTFIM0tDd3pEUjgwUUlLeUl5L1I3ajJNbnpYM2owS2JkVTZRWUJzbUdpWXZkTTJYSGRrZnhEOUp1NEdUSVd3SW9VdU9zZ25pV1ZOWUdWUU1kVzVUY0l4NUh6UnplUUIwTkg5WnJKZWhWQ0h3c0RFMlByT2dhaGQ5Qk1KcUVIKzZ2a2xIVFUzRWFnRC95eXJXc1FMWWt3V0x0d2RtM2hqRnR5S3ZXSjVlVUZ3M1hnNmlSUG5PeDBVb3B5SjlNOUdqUjVhWktGcDl0ZTRUcldwY3BsUDV5VERTd0p5N1F2ZnVGdWFQalgyK1l0TmorNElMWnR5Mzd4S2xid1ZkTlFaRHMrSzlaUGdiQUZURTNiT21qVmVtbXJIQkVqREZ1L2Z0K0JhdzlkRVphTWhGNExkWmVsU1FmeXpSTUVkQ085RDBSaUdHbHJYQUVDU0c2V09pRFNabE9Gb0ZhM2dnalZOSElTYVVZQjJhRGlLTGpycnJzZmVPQ2pyMzN0YXk3aS9XaEJ6T0lFNnd0SXEyTmh5aDNNVjBLdEJvakFRNnVKUGU5Z05KR1ZnTVdNU3NpVXljVUV3V2lYcFRZeEJWRm1hZEtIbXNKVVdWTHBURE9sTUVlMWVXcVFVNXBtQkRQYjBsVkVWSjFsWXBUdjJCQlZHeFpxQmlLZkR6aGJTbG9HZkFDazh5UU5XWkVHVXZUZ1ZRK1RHQ0VLdFVxbDZ1U2tBaUZ5aGZWUFc5ZDFFaWdpV1VMVnBFQlFBMVhzMU1HdXh3bXlLQ0JUSWdYU0pGdEFyUndKdUFvVzJNNHdjT3ZUdGIwSFIzREJ3eVR4WTRVSHc2ZmVEZUhRWTJVRFNhaWFmbEoyZGN0a3phN1hEcEl3RWQwb25KdXlac3ZXRnB2eDl0dHV1L0hJa1lSUUtiZ2EwVGZWOGtJT1dYSDFWaFhWSHl4eFErRUNGVTFreGhOSE5FTUpVU0JJUGpiOFd4eFdXWVREc3hibmpMNjAwRW5GQ3dpOVhrYTNqOGFrUUtyVGkvWlNmdGMwWTh4NG4xNW8xakxOTWdLeHFlblppZHJreU5QSmlJTXp1b0tVUFpqcVR5bWJNSzRveDdZKzlibXZOdHZkS0k0czE3V2NpbDZkTUtKd2ZySnVsU3VqMVBzbEM3eE9FUG9pUXZVU1JEVmhwVktQcWJzWXJHZ1NveVJ4RW9ma25xTWJYcXJWVmJvRi9ISkNBMndWL3FJT2FSUWdOeWg0UllGdm0xYW5zUXFYS0ZjbndPc05PKzBrQ29OMnM3VndOdlM2MVpsZHZEUng1c3hweHkxWHAyWVpOenJ0aGhBN1h2OVk4cmRKZkx4SEZ5c3loazNlbjk2V1NxY25DM1k1dGVZaWJvdFRkN09HdERHb1BFTC9KSUE2dFl5Q3hSMTUzVzZJSEZ4L3F2UnMrWllQd0hGS09WQy9qOXBPV1Y2a3UwaGQ0UTJnQUZMbVBTMDk0N05WNUxnMXpwLzhWNHgxcUJwSDZsUEU2TVBqK2x6dDFkZmRVTnM5RzdHRUVIK0l2Y1Y4TWxmbm9KNFNta2dGMDhneTUwaVNieURJalF5aXBrd0VBcklJSzUyZ2x4QXIzMUF5M3dzRHYxT2ZxUDdHYi96bS9mZmZmOU5OTjE3TStSSWh6ek1tdXkwVEFkNmNCSHFvSFlGVUhia3dxYTBXcStPWUxOT1JmNDVyUVJCSWFnbVFXei9GelpldTZpOUc0QjVQVktUT1UyWnBDcGgxQ0h3RmdRTEExUWlwZklsbEZpSXQ0d0w5YzJPTGlnMzJDOWdtR0g3RHNmQ2ZyZzJHbVBSQkljcVBHQ21FbXpiNHRZNEJzMkU4UmlVaFdQdDBDb21za0xQVEkwYlgzY2xwOERPSVZrRG5hVHBMeWFLbkRnNlIrTWhjUEswbnpzaHBrYUFkbE5UOWdMK05WQWNrZnBaRVVYM3ZRV2VpUHRKR1ZBc09VUWloa0t0QjFJeDk3RzdRa21ibyswRlNjVnpUTkp0ZTNQYVE0YUFiUlpXU3JXMnV6MWlwVk43d2hqZlFMbEFDU0NnRWxmYWgwVDhveWFDcEhVcVV5c3JBTXlSb3ovdFZFR1NLNUFYRWFxQkpPYmI5Ry92SHhWcTVvcmZxNThXUmlrTkpGc0s2Z1NLckltek5ZOEZpUUpZYml0VDBwcUtCaFJaWDhyWVI0V3ZvYzdQejlZbXBpNXRQNFZET0JEbDZ0MHAzWjF2R2hhWEdWNzl4RklWd09tMmlvNUh6VTFOVDFlcjV4UXVuVDUwWTRiSUdNbmh6d3k2alMwMWEyNWp3MS9HNE0yeUxVUThxN0RVd3pMaXEwVWZYSE5LNjlOcGV6czI2eGFTd2N5YUs4QUZpd28rQmt4RklZVS9PZ01zZXJLMkFQVFVrYjV3N21ZUytWcDloaHQxZFhZRmJzRjBYZ2N3aUFoTTd2Q3huY1pCdFZpa2ZNYUNmbWNXa09lR1R6RVRraVNhUHBlUzRhYnlqU3JvOXU0MVcxTkE0eElHWG9GeTFQc1JmQnpFWllxYVdrUzM5dmdSQU1jSFEzL2pYQjJua2ZLQjdaZXVMYm1YN05mSlBLZHdoU2szTUs2T0JoTFBRS0RsM1huSFZhNDdjYUU1V1l2SUoxSGNWMWt1WmYvWGtlelJuR1JjcVp0QlZFMWlLMzBlSVgrcmNKTEJ5dW43UWpxTHUvdjE3My9HTDczejQ0WWZmKzk3L1pYWjI1aUxQRjlnQUVPNDdqb3M4a1N3Tks2ampEcmFINmNEbU1FekJVRXVldFB2QVE5R3dKelZteWhYb3RlanMxQjRwb2c3MUJCZ3ArSW9JOVdCdzNvbVdTbjByRXhQTEpHUXlTY3VRVERGMDZYekxoSmhtMjdwdFVaYmRVSUFXQzUwQVUwT2ZRVkRvajNMQVdJekgvSVdXeU5SRVlRZWNHTEgyN05ickdPY2liNWhHRE1WVXBzRUpKenlKdFNTRWNKdUZNVlZzREZMOGlmQnUwbW9ybmk5d0NNa2dVRUlzaUlBZ1pTUDRtZGtycnRQMEhXOUZ4QWthaXNlRkd4WlM5OENTUks0TWpVKzRMamc1RFQ5cGRxT3E2MWJMOWxySDcwUXgvR2N6aU9XV2djZy9lOXZiWE50UjNPQ0U1MWZFOC9SVWhjamNlTXdrcVRvMTlmc3hualA4VXd1bFRWS3FLZGZQdU5pL3lldkwrQ3RsaXZOaklzdmw5czZ2Tk0rL1RvVkZuZXhGOW1XZWlsZmtiWHV5cHdHVGlmOXd4VTB0VTVDQkpyVnFkV0xQL0dXVlN1M2lacFBsRndvME1uMGk2eXhOQVg3bzR3OTdRWmo0WFlkTFY0bzkwNVB6dTJhVzExYWYvZVkzd2FxT2NPRlgxUGozemh1V1c2NlVTdVg2SlByV3B1bFdxclNodUVMV2NFcTNDVHFYbWE0M1c4MXVxd25maERBclNsTEEwMlltRGtPbEtJajhkbTJ5cmxrdU4weDNhcTdaV0cydUxHaHVXWGZNeFJlT3d1TjJkKzJEYjdVV3ozTVJWOG9WT0dTNlh0ZnJ0SzJwR2FzOFNoa0ZSVlVNTXcwalZkOUVRYVdtWU8xWTN2ZWVvMGR5WjFFUVFib2d5RWhDWG9EeURuVFRJbUtvVVZadGNmU3Z2VUhuWUVoaENEaGhzSzlCOWpwVGVIOENnQmVFZlZqaFp4SWhlbnlYZlE3eFZxbkdyYWFORW5HVUxwSUphckFobkVtVGFlK3NsdFFteXErOTVzZzNuanQ2ZHVFcEh1ZjlDNFNsSXdvenhubzhwenpYUU84ZGZ5bGJUNTlSY2N2WFgzLzlLNjQvOHJwN3YvZmVlKzg5ZlBqUXBUcGZCTXJiSkpZbW85Q0xvaUFNbzFoWVlKbmpNRUpuQms1dEpERVNVY0lpN0pGTnVpR0xJdTM4V2p2d1FtUWhSRGpaam90VkZOQmpWajlGR3FldGpuVGVnSm5uQk9sTGtHU1lOUDBTRVVZUysrNXdjM0t5WmpxWFc0RTE0SFZvUWtkektyQW5PZzZ4VFNBaHNMQnJ5OERIaTJsTXM2Z0xEY0xobUVUdVlySzRoaDVycWZMdmpzRVR0UW5Uc2Z4Mkc5VkFOVjF0S2ZUTTRkSlJpRXNSWTErSzZlRis0Z0R1SkVFY0FKTnhJRlZKS0lDanhnZGZCM01UWVNjT2dqZ0l3UUdyN1Q4OHd2MkFlVzUxNENBVnV0ZEZ1bkliZXpnWGs3QWtlYTBDWVVmUzZJUnczU2dLSjB0VzJJMVBuVytaSWo1OC9UYWUrRTAzM1hUSHErNzQzT2MvN3dYNDZ2MHcyTktIRm5CQ3BjZ0FwaElndW9JVVphQ1poTkpJNDlCL2ZhRTZsWWhBbUcrZkhEdkxoSHlGeWhybDZLUGM2bXZyK05MN0RyNGU4Um5UTWpwZ1pmZlZUOEZpaExmbWxrb1R0YnJqbGk2SkoxUElRck5DVHFMSDdXOFkrb256YTk4OHZRSkdPbXczWitabXdXR0hGZmJVTjU5WU9YTmFSL2pkS0ZDY3VYcmxoNityZmZCVTUwek1MVnNMc0pOWkVEMlIxZlk5MysrWXRndVRGUUt6aVlialN0TmlVU0E3WG1MZ3Bva3BzTjlpWG5IUWpZTHVnY3V2bWJMMXhxa0loVEc2YlMyT1VaN0FkbGRQUEJjMFZpWU9YSUU1M2RZcXpMRTBOV1ZaanQvMUlxOWJucDdXRGJlenVqTEtBMFVjdmhWaS8yR1BSaTh6SlVwbnV5aTR4UWVvN25vT1p0NFhtblhid1prMUdxeHl3MWZNTnFJWlRna0VoNmozWjJsLzErdDJXRVk0S1BzcGZiS0tVb0dnSW10aFlBVVJJTjVMb1cyZEtOcDhWT3VUbG03QkIyUERIZ0ZGc0ZNZEFSK01jT25HN2M2Ukg0bTduNnZWL09VMkxGaGk1a1grT3BuZmRKYnRUWVhwZUpLS3lWSlNHeUpIMnpiTHBmTE05TXpsaHc1ZGMvVlZodzdEL3c3Tno4L3J1bjVwejVmOUJ5Ni80Y1picHFjbTBQekVTUmpISVhhb21YNk1hUjl3Vnd6S0dFVklUSWM2VUoySWV5RTdlUG5COHR4K3QySlpFTlhaN2lpcnRsUkJ5VnFkVklCVEthbUVLRDNwd01PeUNwYmo2RTJWMEJLVC9CUkVyaVpjazNQTGRiWndHRTNYY2VNU2l1cEp0UDFjV2xLRWxEeXdFU29ZaFdCWHNhNkJid1MrRThSK0NIOFlHV3NDKzJQa1BrcDIwYkt3MDQ4dlVvK0hLaDVvaEtDVUxBa3B4SWhacXBJSC9rMGNoWUZLOGlEYklORU9KYUVQajFuRzZKQkZmb0RkUnA3bnpNeFg1L2VPY0QvZ25GMTEzZlcxU3RWeUxOSXF4R1JKeWRZbUhIdXFna3grYlQ4eU5kNE8vS3BqWEhiSVBMUGFXVnh0MWVjdjR4cmYwZzNYZit4SGYrekMrUXNJcEtEdEpkUFNRcXF6bkhJanB1WkU0REpTVkJoY1QzZW9VRVJTbU1JQnd6ODdPenRLSi9ITGZhRCtCRkpEOGt4Zkl1MjNWN29XUE9QSVF5Z0ZiYW8waTA1dkpLRWZFR2tDbjJlUlRoOHppQ0xZSjlZbHJzcHUxRmxqWW1kTXFWeHl5NloxS1Y5S0t0a2ppNTVISHlzN3VJUW5UNXc1ZitKVXBPbGR2U1JEMWw1ZGlmeW92Yndnb2pob3R6MnZNNUl0RXVjWGw4NnUxdHJtaElPc2xmcjVoYVdKU0V6VzY2dHJEVEQ0UG9ROGNXUWJEcGh3VzNPNEVTS0RmN2NMTzVERmtSZEFPTFJWWmp2R0V5VTRkK3haYzdJaTQrakM2Uk1UZXNsd0xFdTNGNTU3dHIxMGJ2YjZtNFZoTHAwNERrL2FLSlgxV0FhaEY4RG5hNXF2TzgzRmhTaFRxOXQ1MnQ5cHR4cVVNdVJGYWpzVlBSWTBmSk5lcTBjQlNzSjZyVzZrZGFyMVdGT29zMjdFVkQ5eXBlY2EwNHhMTnNnZWtma0JhU00rMFJyS2JZOHl6VEN3R2JLL2p6RW5PY2ptSm5zbC9wNXZreVdlTXR1ZmVRSnlrMXJiNXI0SXhNU1NEVkFvOUU2OGZGdDZJY29tYXYwZEdEeGw1bWJGNUlNczlCeGl6eGRTUVNQVm5mNmQ1em9OZzBEMVloSHBBUmNGTFcrTm1EZ3lEWS9lQ3lSeVpzMDJqVFFEZzh5N083MVBtZHAxdmtGMGtEZUpiQm8vMEM5cW13TndaSlo1VHV2TEJLeEkzM2ZtRXNwOG51bXNaRTZKaWUrd3dKcTUwd05PTmJIM1dKdGx6bUZhV0NvRFc3Qnc2NHoxQzNPcFZJZGhqcllQdlc1WEVGbGhJU21TRnM3UUdhV2JVUTFrU09DSXhDWUptUGJTZGtsSStPUldzNVV1OUw2OWw0dkFEZ2lNRnVOU1ZrVGVxTk8vWEM1clkyYmYvbkhzbVNjVGRZeW13aVE4NDBSUXB3aXlRVlAzaTY0U0FDazdGdS9COURJNXZ2eGg4NTRPcnpwd3FOaUlqZWRnOHkwYm1aMHdrMng4SjZhenNyemcrVjVHNkNJSnl5S0xXd0twU29Md3YzNzYwYWZPcmphV0Z3blRySWZkRnNUSDhBT2RwWVVmZXZ1YmZ2Rm5mMnluMS8yN3YvcXJCei94YVcvMmltcTFISG1lbnpEZjY4QUtyRlJyY1JTREF4NkZubzRWVGdzMmJubWlycHRHN1B0eHR5T0lxYmZ0KzdmZi9JcjN2T3RuTi9QUDN2M2UzM3Y4Njkrb1RNeFZkODBuWWVmTWlSZHIrNitGQThpUWliOXdwankvZjJMdnZyWHo1NURFMTdBTXg3RWRGeG1Fbzhnc1YveFdvOTMxZi9aZnZ2VmYzSFByQ0k4VTdNdmE2bEpSMUtkd2hoWk5DdWNEc1g1aEorZTFKYzVUSng1ZVJIMXllclFEc05WcUJMNnZ1bmFsekMxYzl0WUg3SEhXZDFxdDFwenRtQ0tialVZUWVEMlU5MkRML29BK2oxd25jamh3MlBMSnFla05RdzQrVGtLT3gzaU14LytQNHp0OUJISEdSbVBKdlpnNXNVMjgrbHhsblVwZklqZGJxYllaL1FVTGFUdFArNGN4YWxWYldpNnV3akxzNDZBQ25ycURBa2RzV2haQnVNem1DZGNZWWlkc0hFQlhUQkczcTJlclFsSWRDMTV4enFpWUI1NEtob1B1UlVwbHhpLzJxZmJiL0VLTUlUZjY2OEN2ODB2OGluc2UvL29iNlAybkxBUjdsM29seWczaXhiNjl0VG1oME5qMmo4ZDRqTWQ0ak1kNGZGZU5zZTBmai9FWWovRVlqL0VZMi83eEdJL3hHSS94R0kveEdOdis4UmlQOFJpUDhSaVA4UmpiL3ZFWWovRVlqL0VZai9FWTIvN3hHSS94R0kveEdJL3hHTnYrOFJpUDhSaVA4UmlQOFJqYi92RVlqL0VZai9FWWovRVkyLzd4K0U0TUViS2tKWU5GSGkzTHhHTXM1c3hndWlXTlNXN1BNYVBHTk9jU2E4eUlVRVpyekQvTjQxVXBJNlQ3MEt2U251ZjJMcWE3Vzh0SDdmeGFBWXNiT0x0NGxTVyt4Tm1aVExlbE9jVXRtRjJWYWRhbG5sMGd3eFVXbk9IUkdwS2dNNDNETTdSM00zaVlsL3hKanNkNGpNZDRqRzMvZUF3NzRqWnJQUzZYdnl6WEhtUHRoNlYzSGlXVFV1RXI5ZHJKQkd1TTIweFc3dE1tYnVhVGQ4bmFUZHpkUC9JMVpmY0Z2dkt3V0hxWXJYMUtlbWZSTE1vQ0U1Zk9PRmpoMnV2NTFHdjQ3SDJzZGpQVFJwVE5adUV5YTM5VExQOFR6STYzUHlQOURzNU85Qk50a2ZZa2Q4cXNjZytmdUlWUDNzbHFONktGSG5sMjdhTjgrV0d4L0JCclBDQzk3SXBxcUNjSmRyLzJGajc5R2paekw2L2V6UGlZdUhjOHZtdlBuNWFNRytpWG82NEhaNXJKOVJJeko4a1IvdzVGT09DUkw3T2tnL1RQc1BYME1yZW1SejloaHB4Z0VqQkpvbVVjSnVqU0JPM3YzQVRoM0pOcWduRGNHQ1dhb0hNeEh6bTIvUyt2RVRYbG1iOFVwLzR6VzMyY2hVcVRJSmQrWEcvUU1vY0F4UlVZcnpDKzYrZlovcC9tOWR0M2R0SDJVWEg4L2V6TWY1SWQwbVhVTjRudGxXcWpSSWVEemR6RkQ3Mkx6LytMblYwb09DOVAvNFU4OVovbDJuTXN5bXo4TUxNekdhOU84VDAveGZmOU5LdGV0N09MTnI4bVhuZy9PL2RmY0haeXU5a3hjZ0xtM3FBZCtyZHM1azNqOVRnZTN4VWpYR0JyajhuRzQ3TDVxT3g4azBjdktPYzQxVExXbEM5ZWx2YVY0QmJ6Nm8yOGZpdXJ2b0laOVl1NzZCSmIvWkpZZVlRMUhtYmR4MW5jU2EvSTZZcEdtYmszOGZxcitkUmRERngvYS9iaXJyWElHby9KTlp3Z1hpdDhzVGRCUmNSTUUyVDJZVmE1aFVNUVZiK0ZWWTljN0FTalpiYjZaYkh5SmJiMkJlWjlnMFdkM2lPRlU4aHdtSHN6cTc5R203eUxUY0VFNThhMi83dDRMSHhjUFBWemN1WGNWaVpxMDhBMk5jek1adnpnTDJoWHY1ZFpNOFA4bW56eC9mTFpkOGwyR21vUGxmTVdxWXZBOTcxRnUvNy9aS1hMaDdyQk0zOHRuL2t4MldDanpFNmtUZ0F2TVhiNDE3VXJmNTFwUTZneXlrZ2MrMjEyN0QyeW0xMXhtTm1wbEFENFVnZC9YTHZ1ZlJkNzZJekhlUHozUE5ZZUVTZi9uSjMvTS9TTTQyeFg4c0kvOCtPRkZSS0JGa1FhVTJ6UHovQTlQOEZyMSsvNG90M2o0dVNmc05PL0sxc3l2ZWpBRmZQTHFaMVlaV3pmci9MOVA4K0hPMnI2em9ER1Y5bkpQNWZuLzI4ODRvYWZJQVViYlBkUDhiMC95V3V2MlBFRXZSUHk1Si9JVS85QnRxS2hKbGlCQ2Y2eWR1RGZzTklPVk8vSHR2OWxNdVFMLzFGODg1ZHdvUmdYVjNTR3hSUXhQbnNadS9WQnJYYkRsb212cG5qcW5mTFlYK0hsUmxCRWs3aVhlSTFwdDMyUlRkNjl0UTJXUjM5RFBQMjdhcUZmMU93UytyUDdadjNXanpEMzROWTVCdkg0VDhpVG44WXJhaU0veHIzOGxaL2tFQUdNeDNpOHpJWi9Tano3Ym5ucUF5eEl5MTQ3MkpneWM4Y2R4Zy84UEwvcU43bTlaN2hmRE9XTGZ5Uy8vVXU5WUdQNGExV1lkdFg3K01GM0RsbDZrUDRaT0hia3liKzgyQW51L3psKzFXOXhaemgxY2pqclR2eXhQUG91MmRySlJTbmU0R1hHci93ZGZ1aC9HckwwTUxiOUx3dkRmK3JQeEdNL2x3YkVsMlNFak5jWnYvTnBYcmwyczAwb3Z2Nmo4b1cvQXcvM29veHh4RmlaNlhkK2lkWHYzSFIyMzM2UGVQSzMwcDF3Q1I0V1hYVFhsZHJ0RDIyMklXVzBJaDU3S3p2OVR4Yzd1NUN4U2FiZDhTMWV2WDY4U3NmajVUTldIaGFQZlk5Y3d3RDNvbmFsb0FDZ3pyUmJQc09tNzkzTzdpK0tKMzZTSGY4RW5uSWpISFRLN3o5d24zYlQzL0J0azVxclh4Q1B2UlluYUZ5S0NVN0FCRC9GWnU3Ynp1NnZ5Q2QrU2g1L1lGaTNacU1KOHYydjR6ZDlFSUhWWTl2LzhoK05SNU12M0k1bVJyK2tId3ZtZjgrdDJxc2VabnBwZzJYNnpMOFYzL3I5aXpXTitZVW1HYi9yaFkwemNvdWZUUDdwKzlCZ1gxcndIUGp5aDk2aXYvS0JEU1lnaGZqR3Y1YlBmWWpabCtZeGFuTlg4cnUrek16cDhWSWRqNWZEV1AxUzh1VzdtVGRTdG0rekFNQ0dBT0FmMk13Yk56Zjh5K0tyYjJEbnZuRlJaNDd5KzNmZnF0M3hLYjdGZmx4N1JIejVUcXowWGNJSk9reS80MEUyKy8xYkdIN3g2QnZabWNjdXdRVG5yOVB1ZUlodmh3QVlvNUZmNGtPRVdKUDJMclhoWitqUnkzTmZrNmYrWW9OdlhiaGZIUDM5aTAyLzU4Tmk0Ri9McDkvSlpETDRyYmdsanY0NzlHY3YrVHExR0R2NW9EeC8vMFpKbFA5SHZ2Z2habDJ5QzRtRlkrTFpYeDh2MWZGNE9Rei9iUEwxUzJyNDZhZ0JGemw1N0UyeS9jeG1wNXo4eGcrajRiL0lqbDFPRy8vYzE4VFhmNGdsL2liTytvTDQyajBJWDdqMEUzeUxiSDVyMDJQODhSOWxweCs3TkJNOC83VDQyZyt5cER1Mi9TL25JZHRQeW5NUERMVk1LZnVFWG1GU2FJZmJlaGx4Smw3ODlZRTFCUDVwY3ZTWGU3Q1hyWjNRWWkvYzFuN0d5WSt6OHg4ZC9JQ1ZoK1RpVTBPNU5jWFpEYmxKQk16dWZkUXpVN2lpZDBJYy9ZWDBCN2E5NHBDek01aDg0VS9aNmorTmwrdDR2T1FQbkJkK2w2MWNVcnVZN1JIV1p1TFpmN2RCQUVBWGxhZitFUzNvcGJMRUp4K1NML3pPeHR2NitkK1ZLLzRsdTFZKzlDMG4rT0w3MmZGUFhySjRBMjcrOUJmRjg3OHp0djB2NjdId3lSU0tzcTJoMGhuZmRUMC84SHBlNisrRzMzcTlOcHVzOFdqZkZ5RldYbngrKzgxUFJwR1hHRGVIczhkZ2laOS9EN2F4RnJmRXdqK3dlQ2d6REZmaHUyL2xsOTJEa05jaHpiL0crTXFYWk92cHZpK2Ura3ZXWUVQTlRxUFpHVU5jVGtPblJENy9mMkEzOEhpTXgwdlg4SHNuNWNuM0Q1dGlsRU9mTTduNVAvTnh0dmJsd1k5cFBTbWZmZmV3UFVSRCt2MEdFOS8rOTdMNXhPQzN2QlBzeEgvNFRrMFFUc0t6LzhEV3ZyUnVnaytMWjMvbGtxVlJzd25LYjc5SE5oNGIyLzZYNnhCaStlR2gxcWpGOU5zL3BOMzFkZTIyLzhaZmZZb2QvSUdoQWxhT3diUmNLOWgrR1l2amY3QjlXRXhYMUc3N0FIL3RpL3cxajdBOXIySGJXajJkeWFVbjVmSm5lMTlKdW5nUWJMc2Z3UFM2VEh2VnA3UzdIdFh1K0VkKzkzTnN6NnZaTUVaV1k4ZzYySG1xOTVWb1JaNzY5ME5kc2NUMFY5M1B2K2U0ZHZmbjJPeVYyMTlPWStMOGc3THg5ZkdTSFkrWDhGajhPQ2JEaHpHTnltVzMwek5rV0lzVk1uSG1RNE5ueWJIZmx0NXdXY1lvK3lPMzM0L01ZL0s1LzIzd014WS92WU1Kc3AxUE1HTGk5RjhQWHZTNS81VjF2d01UOU5VRTVkajJ2eHhINHZQdTA5dmJxcGhwbC8vUGJQNkhWWE1MZC9icDE3MmZ1OFBscXdWVytIcC9henpLVnA3Y2ZtL0VqQi82RmI3M3gzbnBJSis0UTd2dWovQnl5UkRCOGJrUEY5eU1wdXcrUHN3SzFhNThIMkZvOFVIdzhtSDltai9BWk1Nd3M0TmI4azcxcnJqeUJUbE0wQytaZHRYdnMxMXY0KzRCTnZVOSt2Vi9pcjhpdHN1ZytJd3RmR0s4WnNmakpSeHFMSHhxcURBM1lYejNiZHFkRDJpdmZVYS84MEUyLzhyaHJhTmMvVlF4UFlacHVUTi9POHlXeER6YzFUK24zZnBIL0pwZndPMjI3WDFDc0hIMmIyWHJxYjZQV1hwb3lBbXkrVnUxTysvWFh2dXNkdGNuWUxMRDV4cmw2cWY3OG4vdGI3T3pIeHgyZ2xmOTlBNG1DS0gvMlkvSzVsTmI1Rm5HNHlVN29sWG1uOWwrMlFuRzU5N2M5eFY3bnJsenpGc1l5bGNWWHU5dkZ6Nk9zYks1M1RMRkRQd1A5bjZyZG9PY2ZqVTc5Y1Z0bkFhNDF1SUhXZmc3S2ExUTNFSjNlT3VzR2pFU3NwbDcrcjVZUGdoeE9Xc082VCsxZXg5MjRVRlZITmxtZGc3ajh6L1ErMHI5Ymo0eEoxZTJmNWppd29mMUszNTFLRnFoOFJpUC8rNHNmOGhiWDVkRFpNVjQzZEJ1K3hSeTNNS29YS1BYYmhKZjJJY042OXZHREdEZXVzZFl1TXJzakJIcjNOOUpuMjFmQ0UrWWR0MjcrVlh2VWFlSXRHYkZrKy9keHJoUjZNL08valc3K24vUHRuWWsyNDhOay9iRG5yM2IvaUU5cGlwWDg5ck40Z3U3WlhPNENmckhNWnJLMk5QbHViL0ZySVk1eEVXditXWHRtdDlMSjJqUGkyLysrMjBteUxHYlNaNzVBSy85M2pqdWYva056bXF2NURNemZIcCswejlUYzN6WGZtYnZIZGpHTEZrWTlpSTkxbWdoVnI4NFRLcUFnM1YwTHV1NzBjcE4yMjhxOE1RN3Z1aStrUDRLMTNrZHBqQzM1ZXhtMk16TjNPa25Cb203UTZFRTB0bGxIWXdpWWlzZkhRWTV3Y3Q3K3RqNk5JdFY3OW8remFBejN2cVc5TTZNVisxNHZCU0hESmRZZElvc3o1Wi9JQlRaODZ1cDRWZkQyY3RtZm1qWUltT0NDYi9za29tNDhEZmJHMVNCVlQrMjd5ZDdIM1BaejdCaDhwb1FoWi8vMng3R0NJSU43OWhRRTl6OXJqN2FVd2lsWm45OHFBbWlnd0VUYkdWM0hvc0xmNzM5U2FYaWpmM3Y2RTF3L3kvZ0JPVVF6M1BocnpmcmFCakgvUy9sWWM5cmQzeDJRK0RvNEJvM3FuMXJxZm0xbEJocjJ6V0hUU1BwS2tlNXZOYm41VEMvNVJ4Q1B1MitXUHp3TUFreDdQVnZQc0dVb0lCN1FMdjcyZTEyc0VTNFhmL3MyT3FYVXhiZVlhNlkrUTJ5YzB4Mmw0ZUM5N3MzREZLRE9RZUd1WmFFMmJXZVpPVXJ4aXQzUEY1NkF3VnNDclMxVzFpYzh1V2JldGhEUlRUcEpwVHQ1MWp6MkZCYnNucGRIenNJYk9ycWpjeDdZcHNqRHJaayt3VVVJU01HTTVrRVdFcG4yMDJRc3cyb3V1QzRHekxZNEN5UFMyVDNHRzhlbGNNZ3RhdjdlYWx3eU5oenJINEhPL2VWYlhNYnNubGVkcC9ma0Z0c2JQdGYwbUcvaGlLOE8zYmdFOFNjUjJ5b1BoYXdvQk0zcGYvdEhXZkJjRmV3OXBGaVQyR1l1NGJhRy9BenpjZXovOWFaT2JIajJTVmUvTUo3K0RCRk82cE5zUEtWNlYrNzMwWitwR0Y4Y0hPV3hEU0tUdGpNc05TYm5hUGpaVHNlTDhuREJpS05teUNJOUFZWC84RDJrSUxQOURQMHlWaTJ2ekhVQmxGVmJhT1MvclgxTmR5U1F3UWJ2SFJOMzlibEpxOWNMUmVlMk43MWh3T3Q5UVFqMjgrTkNlM20vd0loemphWGxER2ZlZjNnaVRva2pKZENsZDRFMjkvQ2lzWXd1Y2JLSGYxbkUrZWxWMGp4bGUwbkNPZDgrd2sydHYzamdjdnY3Ti9JVTU4WXRtbSt3dmpFcTlLLytxZmxjRzM5M0tnenJYOXBtYlVoTjcvb1BIMHhORVh5eEIveUM4TlNBbkR3cHF1WlpvRi9OaFVoM05ZN01TdURYelBxY3BqWndhTnJQenRlZ2VQeGtoem1CTi96STZQODR0cFgyTkkzaCtUZWw2VkR1ZndkQXZHRzRmV0NyYmRlZk55NWJDalVubUN5OFEyKysxK1JNU3p4dlQ4NnlwblRlSXd0ZldXbytqbUtwZTNCR29INlcvT0pOTGU2L1cvdFcrZUtUY3NoNDQzRzAyejN4cWZSZUh3M2piVkh4Qk0vb2RyVGgxazNmTTg3bUpXUlgwWXJROEZaRVg5WEd3Z093S2NlTHJoZ0xEeTNrNTdaL3JId01mR3RYOTFVMVhlOWo3THZIVXpQa0hmaHNBQUlidngvN0YxN2RKWFZsZC83M0x6ZkR4SU1DUWtrQkFJbUJMQzI2Z3l0T0dySGxtckhqdU5ZRldwSGE3VTZIV3RSUjZkVVdoOVRoMVZXYlptdTJvZFcxSEYxdEJhWFZOdlZ4NHhZTFlXdVNoNkVRSUlra0VBZ2tKQ1k1NzNmMmZPZEx6ZlBlMisrL1lVdzVyRi9pMzhJTitmN2ZwZHp6bS92ZmZiWmUyd0FFNk5UbVZFTjZtMlFPU2lZVmI2R1ZmdHZ3WTdiSEhNODdmTEJBeldDemlwbUlCMUhwaGNNL0NRbWd4MW9yRHhiaHJYL3lvcFBET3lOd3dRQk9nOHl0enFNRG1rSGJGUG0rUnU2cXlhU0p5S1lOYXV3czFydnZwaGJqOU15clNITjVjQWhCTnE1b294akgwQ0tXeWdMcldPZ2V5ZENyKzB0YTgvVlpwZnhzZGhCR3VEOFc0YmZzTDgxdUJlNEw2ZVFydzlqdUtkOS9hTDlndG0wNXh6YURNMy93OXB3bkRzN0t1ZlRnM1pBUC9VYzRqNG1KajFFR2pPNGI5aGJkMVlFMzl0Q1RiL25FbFNBT2RjUFdUclVkNVRyRVlYNEcyQmJBOGhMOStzNUtOby91eGRoK3k3NlkybXdNeFZubXRvMitKTE5veExUQWozY2g0VlJSOFUxdzNVSDZUN1A5RTYrWWIyem1tdldPT21EYXVsem85TDFkVGU3MUhGVUdGdUhlT3RRdDhwVUZNeVdQZWZZQzdyaVBtNGN6amJINXl5RHpEVkQyby85aDdsUDhpV0ZiRUc4QXJrSUdHaU9XTnZmbGVEeGwzWEZWN2dFQXpiQllzeThkSkJ2SC9vYldRcHNEKzRMalRVbU12MSs3S3NVN1ovRmk3RGxGZjNPUmFad0RiTmtkRC9nZ3JXNDRLN1JvL2k1ejhPUWVVV0s2eGtiRWZWVys1YU8vTWphZFpXSC9pSUJ3TVYzWXU3b3cwdmR6MllYNWM0M290blJMYk5STUN2Mm5PTS8xM3R1NUI0dk9qNnhiOGtUd3plSzdVMUF2ODlPbmxmaEJKTjNlR2gxa2RVNW9VMTF1OTc5OTl4T1kwR0MzeHBXY2QwTGdhTm5RWkMzNTJERWUyQ2kvVE4rQ1FaMC9iL3JYZGRDRDNBYlZQZ0JjNWFwMHFkQWplbGlleFpKZU41YVJiTWZaSFhwbXEvb1BiZVpVRDh6bm1Heks3aGNsVHdhc2tqNDdIUzRjWmxyT0ZhbXBHRG03enBIZjBLN1A4TTlnQnZZYzRvK0Q5bWZITGx4ZVVqN0NWMVc2Q1dOWGZ1OUU5eEdmL3EwQjRLMnYxRzBIdWIrM1NpQ25KSUFBOG1BR0RQQndBWkV2Q1V0ZWY0ekdqME51dm91YW5qTmlScng1cG50L1o1WGFxcFd4WVhraHZyWXM4MEs4YUZSc3p3QWNoWXRNem1nczlLcXZBMmFkeGxxaXNzT0N5NVRLMStDME56RDRSSkdib09FUmdqc3ZZTVg5eU9WSnJOU01MT2hEejVDVlYvellNT2JQYWRFTGRzeWVxbFlYcDRaemkxbUhqS1MxMmNCMVQydUt4ODB2OGkyYkNCN2lUci95UWs2RE9aS0g0WVBiREMzTE5IKzJZWG01M1gxVGNFQzljekx0UUVBMnljdS95bU1xWlFYbkN4cDdMaTlEcG1uM0RBK1JlVXAxNnEzMUUrTlA2SjlYNEl1Tmp2dFpEQXN2Z2xMdDRZdGlvRFI2ZHkxU0tHR3RNVmNoQmc5WHlhbVlNYTYrNzNOVlBVbGF2aUYwV0ptVE5rMm16TlQ4WUpmamwyVjZLbU5yaitNbzgwczhvSGg4cE1pZmJ5dnhSQTgvTEpoeHc5cFpBQmVzQ05rMjFFZUd2ZUZIb1B5N1JVbDJqOTdWbURQWWFyZFNJZTNHVWxpcmlEbjRqNlczSTRsVDJDa2VrSFJxZHpNRkt2YkJQbEgyS29VNEoxem0xemZyUEhENzlSWlRUWDMwNUVkemxWN05qc2ZxTEtOV1B4UW1PaFprTjNjNGIzQXhVTHFDVm1HWGU2TkFDRDhQVjJCWUlac095ZGZwNHBQMEdudzBJZStIekFySHovOHUxRlYrWUtLNWZOd0loMGF0Q2ZOL1YzRmp2bTEvb29xUGtPbnV5RGFFOEU4OWFIZmhpbHNxbUxNYzhrdHpkQ0pUQkJaWTdjbFp2WVZSVXhHRXUyZllldlBncWJuOWI3MXdTYjA3Q053U0FLMS9Cbk1YVC9lSkl5Ylp3YmtsTW9QdEptcE9WSmwvVzNNTEhxTUw0Njh3dnVvNFFlNjVzdkczWTltdS9zQndEU2IzWGFZZS9WNG40ekxadTQxNU8vQ3NXR0lkcWFUZ2ZHTFpaSUtaaG9DN2ZyQU4rbkF0NDJ6d1JSK1oyRkMza2ZWeWhkTXdmOXd4amo0Y29GNC9TL0N1TVdhV3piSGw0MnUxVkVEbmZyQU4ramdadlBPMFY0STVsNmlWcjRJOGVHaWZiNTRpbG9FVk1VYmJldzVvMjBOY0FsR1o0cjJ6M1RkZjM4LzdiK2ZHbDgxLzkvTUZXZzVnalQvY2p6LzI1aGM1akorM0FLTVpwaWJhSy9FRTJheWpzeEc2Vy9qV3FrcEs4TC9TL3VmcWVZZWF0N3B0QmhndS91Mk1WRjRuVnI2QkNRc2NIbnJoRUl6TE9kb3dtb2JHeC9vYitVZTNpVXZrWWtxbUZFNDlXdGRkUWVkUEdUaVhsSHNiY2RlUDB2dlVzczJoeVFVRDBsakxNWGFrdG5FMlRUQTN4Nnk5cmwzQkNnNjF5WFFlT3IzdXZvT2FLbmxlbFBEQkw5b2toZ2lCUlV3Q21KeVdOcFBUaVIxRFB4Y2Y0UGlsb3IyejJUZHA4UGZvLzMvYkJwbDhoMWllNEltZ2xyNkhjeS9qZE5ZRm0zelBLR1l1ZzY2YWovMFZwTHVSUmkrZEV1OWplNHoxYmtHQXlraEpvanVwZnIvb0FNYlRZY2VUMTVGS3FobHo1ZzZuWndjL3NSbEdBZnVqVGlWemVYUTJLaUdxVVhvL2tybUJETmNZVzJCWUZyQ2YwclhQa3gxMy9Od3R1Z2tGV0VTWUpsTGxOR1dSa3hjUXZCSDl6RnRaOFBmTmpZVUYyaG5rc0RFeUV2U2Y5cTQrM1hmTVp0SmpBZUNabDh0ZXhwSHRCWU0rMlJNbUUvTU1mMWRZYlFmZ05Qb0NPTkYrMmVxN0hlOFMvczJVTk52ekYvWUU5UmNpc203VlMxNTFMU0VZa0xGVU5xbGNJS2ovWTRyUExMTjVmdFY3dHB2QzNZQ1FOS3lVVDlzZTB0WDMwM0gzL1hnN3BOcElnd0x2cW9XYndxdGlSRVIwYW1VZGhXY2VkM3RTd0RvcWpEdFBrZEcwcm9xV2NHM2hHaVVKbjZDbWJIdG5IaU5xbStoVTYzZTNIMWJpdVpmaHFYZngwVEc0VmR5S1RlYzFoOVNNcXUvaFN2VmtlS2RKMTdYMWJmUnFTWnZCRTJsOERWWXVuV2dONkFMN0wyT1dRdmMzenIyZy8zY0txdVlWQ3phUHhOeDVHbGQ4WGtQZC9lSEJDeDNuVHJ2YW1yL2czT1BOdklrc2gxYzJ5Rk9YUm1jUmxrZnAvb2Z1Zy9lRDNCNkp5U1ZCSC9TMTBMdDIxbTlPRE91eE1GR0Y2WTcxcUV0dW5xREdZM1B6cWtNaWd2dWhqbVgwc2szbkd6WThkaGh5Z1ZENzZubXJOVU5ETzN2Tm0yQ0lYdHRjSXl1ZzlUK3JqczdVN1pzUGZoU1pNNEtwamY2V3ZTQlRWVC9mVy91dnQ5V1djQ1NyYXJnMW9qNXRtT1dXa3FaRmMxS3Y2WHUwZFYvN1EydDZ4RHJyWHlnVWxlRjJBMG42Y0FtWGJkMVFnU2ZWUG0zTXkvZnE5UVZsbzlCME5iKzdyR0ZoNm0zaVVrUTAxYUk5czg4Mjl1eUduOEE3d1BFZWYvVnhtZXQ5NTUxdHh6OW9FbytCOHVmSHRUK0t6QUp6TW1DV3hDZDZoK0VySTlqZkw3cDRObXcxZVFlK3R5bUtZTEt1WFo0MlZnOWRHU0xhYklaNDRXWXFac0x1dTY3VVB0ZGQzWUJVT1VQNGVKSGdyK2EvYmNtN08vYWxrT0RWYmZKbDNhUkNXeVEzMVFzZHkwcHFBZHFsYS8xVUFGUUlKaUNhUG1GcnJ5VzJzakQ0YmU1MmdxNDZFNXp5eVoybm9kbnBhd3k2N0hiWFJxaCt4M1RYSGlvTDVmdWhxNC9zNlF4Tk5EWThxcXV1cDVPOTNvaUNJYmdGOVNpalJIeUZpUDUvYVdRQ0dZRGR5WFkrUnZRZmNPNUViYkQxdm0vckhJcDloZVlXSUtpL1RNUXZvU0pWTnR6eXZXejBrU0RVMjlvdnFSQS9vTlE4WmpMUTMxQWJhM3dWb0ZPdndiNkdxSDFMMmFhb29zNm91MFNEenJUd2RmMHBZRnFuZ2c3YSt5TGordklEeUpoSWN6N0xOUzk0R0p0Mkl1bVpZOStLNGRTUDJYaS82ZnEzZjhMN1BmSkxvTDBqOHFFRlV4algyUC9RM3JmWXg1U2lTRVlkS1BNMVpoY1RrMHZPWmIxT0I4bThDVmkzajhHTy9IRVpGSG1XdWg4elVYazdOWFgwUVZuOWtERzZ1QlBPaXVvbzVXektqSDlpcEZGek9qQXc3cHEwd1FJUXNZbG1MeUttbDltRUl6RjNCdUNuVVJpNTBMNko2Rmpod3RCYzg0STBQNE9aRndhSE9iTVh1bzQ0YTc5OXFhYS9qR01ZSTZJOWs5M1ROU1BaUGFmVUdPclk2cThkZGFoeDB6Y084cE4vbTE3dG1ON2NIRnlBdjc1WDhQWTNNbGhwOWdmRytXSW8xcHd1M1hrQmZjYTNRcW9QUUJ0cnppRlFSanNFTlRDK3lDazA2aEFNSDJnOVlsWFBOemlHK2s0SE51cGorN2taUHlZUEtTc05UalloYytYYzczVjhKcUxsNEltZ0dmdGYwQ3QrcG01aDl4N1ROZmNheEx1b3R3MEd3RnpiaGc1TkxXK01VR0N4OS9XVFcrelVwcGlRR1dzeHNFdVlyNTU2NjJHSGU2UHNBbldiRkFYL0J6ajhxanZPTzIvaDFYRm5BRG4zUnhwTHhQdEYzaEU0aEsxYUpQZSszWDNzQUcvdGxmQWxMNVNoVi8rNE5tbHI4YkNMMUROVSs3cm54OXVzVDJCbkRMTXUwWG1qbUI2dzVjOFFXdWN1UlU0MGpqcVZrNzJWWmppM0w0Wlg2bWlqUHJTbTNrNllUbDJWMUFYUTlsc095TVY4THhyUmhOTTlGQnJiMUlJWmwySmFVaG55R1UvY1dLTjlHYStCNEsyRVpOaUd6ZlhUTGJYS0pqRndJWDNZTTVLOEUvU2NOWkEwYjBka1dwUS9EK1R3MFdiTUROdUV0bGh2TTN1eHg1cmxBb0VBbE9YQm9zMnN4TGFmV0FVc2NYUlJjNUJ1SzM5aFp0aE1NRHd3UkZNeGFJdHJBN2duZ2c2ZG9ZcWZBU2k1NGoyQ3lZUFVjbFkvaUttd1NRSXBKTjJvTW9laDZ4UFRCWExKdTQ4dGZKM21BQVFPT3V4TEZQWEdGYzhnNmtYeXF3UkNDYXlIdk52eHpueldGdU5jcnhoanFZRkFETnpJUCtmcGdURCtiZENWaUZydC9GRU1DTVZDKzRjZnpDQndQdUNURnFNSDltTmFXank4R21pb3dTY0U2bmxYOGVpQjZZV3ZmU0wxWWQvWlhLQSs4K0NuZDlwa2JEcVB6RnZ2VXdZZ1dDaW5rYVNXdjZpdVd0blRkS0Eya25MWC80Y1JrMkpwcHJvUy9TVmJUTm5BWk5JTUFxdy9ML0hUekFTN1JkTWRNcW1mQWd2cnNXQ05XYktlbldSQjlycEpvRzY4TWVxK09HcFNHL09sZXF2ZGtOT21XRm5lVjk3L1U0VGdZdTNZOEVkTWxVRWdyTkN4bXBWL3VUdy9aMnoxRVVOYXZrV3pMeHNLamtibDZqeXJaTkpzR3d6Wmw3aFlsUEp2SnJPSUxDNmpIK0o1K3dKL25DbHBJZmtQN0VZTC93bDVmeVVEdHhEWjNxQ1JYa3gzQ1dDb1FNdEo4aHZhbnNVcjhQaWg4WXQ3MFVZNkNUL3VmeitETHZlY1l3YjMwZDJVdU5UVkgrZktXa0FJNmlGWlRmNHgxUVZMTDVMRlcyQStIeVpvd0xCSkhnYUMrNVdWcmV1ZkdBZ1BXaUNzSndiTnlzZXg0WC9NdVVJRnR5cHJCNjk5NnZ1TnhUR0oyZ1BWZjRZRnQ3ckhrK1JXVFdkb1ZUdURaU3dFSHh4NTJaOE10S1lQZTVKdklvekIzSTUxMUhMcS9yWWYySGJyMDFUU2l0WXYzTndYZy9td1VhRFNpNkM3R3RoM28yWVV1NUdMZ2JuZnhIU0s3Z2ROaWZBVHZkaHhsK1A5eEdUaWJNQjhtN0dZeTlSeTgrZ2ZTZjBPcVVDOWFEa0Q3SHpPUVpOOHZrNDl4OXczZzJRV0N5elV5Q1lUSFVzdXQrWHNGRHZ2ZDVjSHZaNWpGa1A5UE5NQml6YlpocDhURTJDaGZlcStBS3F1QzVZUE0wN1FhY2Q2N09ZZXpQcmNVUWtzMG93YVhMYTA0RGR0ZFRkQUQyTlpQcjJPb1pvVkNMR3pNV0VRb3BmaUVubmd5OTJ1ckxycXNQdWc5VDlIdlEybVdZaHBrYzRZbFFTeE9aZ1lpSEZGV0h5VWxiZklJRmcra0ZiYjVaQ2M4MDVkQmlkKy8zNE56VTRWQTQ4ekJxc3A3cEhxUEVaMHpSRWpRZzBoclB0aDR1WXhRRG1yOFBpalpoWU5ON3ozNzZJR25aQjlEa2thTzczci9rTHBxNklTTEQ3TUJ6OHBtNzhpVW1sUWg1Qis0Lzl2YzIvQ1JmYkJMbGVoMmkvUUNBUUNOeE5YenJ3RFRxeit4emE3cmFyRUpXR0pZOWpiSTdMQnp2Mnd0SG40ZVEyM1hIY25OeUYzcEViMEVzVGFNeW11ZXN3OThaSXpjRkhEVnYvTFRxOTh4d1MxRGJCRkZ6eUtNYlBkeU5ZQlUzUFFjczIzZGs4SGtIYnBrbktoT3pQWWU1TjQ5Z1RvdjBDZ1VBZ21ER1JpRDdxckRTaHVNNWEwOXNtME9PNHdBcWk0azJCditTbGtGQ0V5ZVhNempwVGttQS9kVlJpVHoxMTdxTSsyd2pvSGlJSWNmTlUwbEpLdEFtV1RleFVWTFJmSUJBSUJJTFpCZEYrZ1VBZ0VBaEUrd1VDZ1VBZ0VJajJDd1FDZ1VBZ0VPMFhDQVFDZ1VBZzJpOFFDQVFDZ1VDMFh5QVFDQVFDZ1dpL1FDQVFDQVNDRHdiL0o4QUFITVFSVURqWHgrOEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2ltZy9zYW1wbGVzLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4xLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOS0yMlQyMjozMFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMS4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRcdHJlc29sdmUuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdGlmICggZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHR2YWwgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF07XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHJhZigpIHtcblx0aWYgKCB0aW1lcklkICkge1xuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApO1xuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKSA6XG5cdFx0XHR3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aWYgKCB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aW1lcklkICk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0fVxuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLCByZWN0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcblx0XHRpZiAoIHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQgKSB7XG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogQ3JvcHBlci5qcyB2MC43LjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mZW5neXVhbmNoZW4vY3JvcHBlcmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgRmVuZ3l1YW4gQ2hlblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wMy0yMFQwNjoxNTozNi4yMzRaXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/IGZhY3RvcnkoZ2xvYmFsLCB0cnVlKSA6IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgIGlmICghd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JvcHBlciByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhY3Rvcnkod2luZG93KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkoZ2xvYmFsKTtcbiAgfVxufSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBHbG9iYWxzXG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgdmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgdmFyIEFycmF5QnVmZmVyID0gd2luZG93LkFycmF5QnVmZmVyO1xuICB2YXIgT2JqZWN0ID0gd2luZG93Lk9iamVjdDtcbiAgdmFyIEFycmF5ID0gd2luZG93LkFycmF5O1xuICB2YXIgU3RyaW5nID0gd2luZG93LlN0cmluZztcbiAgdmFyIE51bWJlciA9IHdpbmRvdy5OdW1iZXI7XG4gIHZhciBNYXRoID0gd2luZG93Lk1hdGg7XG5cbiAgLy8gQ29uc3RhbnRzXG4gIHZhciBOQU1FU1BBQ0UgPSAnY3JvcHBlcic7XG5cbiAgLy8gQ2xhc3Nlc1xuICB2YXIgQ0xBU1NfTU9EQUwgPSBOQU1FU1BBQ0UgKyAnLW1vZGFsJztcbiAgdmFyIENMQVNTX0hJREUgPSBOQU1FU1BBQ0UgKyAnLWhpZGUnO1xuICB2YXIgQ0xBU1NfSElEREVOID0gTkFNRVNQQUNFICsgJy1oaWRkZW4nO1xuICB2YXIgQ0xBU1NfSU5WSVNJQkxFID0gTkFNRVNQQUNFICsgJy1pbnZpc2libGUnO1xuICB2YXIgQ0xBU1NfTU9WRSA9IE5BTUVTUEFDRSArICctbW92ZSc7XG4gIHZhciBDTEFTU19DUk9QID0gTkFNRVNQQUNFICsgJy1jcm9wJztcbiAgdmFyIENMQVNTX0RJU0FCTEVEID0gTkFNRVNQQUNFICsgJy1kaXNhYmxlZCc7XG4gIHZhciBDTEFTU19CRyA9IE5BTUVTUEFDRSArICctYmcnO1xuXG4gIC8vIEV2ZW50c1xuICB2YXIgRVZFTlRfTU9VU0VfRE9XTiA9ICdtb3VzZWRvd24gdG91Y2hzdGFydCBwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcbiAgdmFyIEVWRU5UX01PVVNFX01PVkUgPSAnbW91c2Vtb3ZlIHRvdWNobW92ZSBwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcbiAgdmFyIEVWRU5UX01PVVNFX1VQID0gJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbiAgdmFyIEVWRU5UX1dIRUVMID0gJ3doZWVsIG1vdXNld2hlZWwgRE9NTW91c2VTY3JvbGwnO1xuICB2YXIgRVZFTlRfREJMQ0xJQ0sgPSAnZGJsY2xpY2snO1xuICB2YXIgRVZFTlRfUkVTSVpFID0gJ3Jlc2l6ZSc7XG4gIHZhciBFVkVOVF9FUlJPUiA9ICdlcnJvcic7XG4gIHZhciBFVkVOVF9MT0FEID0gJ2xvYWQnO1xuICB2YXIgRVZFTlRfQlVJTEQgPSAnYnVpbGQnO1xuICB2YXIgRVZFTlRfQlVJTFQgPSAnYnVpbHQnO1xuICB2YXIgRVZFTlRfQ1JPUF9TVEFSVCA9ICdjcm9wc3RhcnQnO1xuICB2YXIgRVZFTlRfQ1JPUF9NT1ZFID0gJ2Nyb3Btb3ZlJztcbiAgdmFyIEVWRU5UX0NST1BfRU5EID0gJ2Nyb3BlbmQnO1xuICB2YXIgRVZFTlRfQ1JPUCA9ICdjcm9wJztcbiAgdmFyIEVWRU5UX1pPT00gPSAnem9vbSc7XG5cbiAgLy8gUmVnRXhwc1xuICB2YXIgUkVHRVhQX0FDVElPTlMgPSAvZXx3fHN8bnxzZXxzd3xuZXxud3xhbGx8Y3JvcHxtb3ZlfHpvb20vO1xuICB2YXIgUkVHRVhQX1NVRkZJWCA9IC93aWR0aHxoZWlnaHR8bGVmdHx0b3B8bWFyZ2luTGVmdHxtYXJnaW5Ub3AvO1xuICB2YXIgUkVHRVhQX09SSUdJTlMgPSAvXihodHRwcz86KVxcL1xcLyhbXlxcOlxcL1xcPyNdKyk6PyhcXGQqKS9pO1xuICB2YXIgUkVHRVhQX1RSSU0gPSAvXlxccysoLiopXFxzKyQvO1xuICB2YXIgUkVHRVhQX1NQQUNFUyA9IC9cXHMrLztcbiAgdmFyIFJFR0VYUF9EQVRBX1VSTCA9IC9eZGF0YVxcOi87XG4gIHZhciBSRUdFWFBfREFUQV9VUkxfSEVBRCA9IC9eZGF0YVxcOihbXlxcO10rKVxcO2Jhc2U2NCwvO1xuICB2YXIgUkVHRVhQX0RBVEFfVVJMX0pQRUcgPSAvXmRhdGFcXDppbWFnZVxcL2pwZWcuKjtiYXNlNjQsLztcblxuICAvLyBEYXRhXG4gIHZhciBEQVRBX1BSRVZJRVcgPSAncHJldmlldyc7XG4gIHZhciBEQVRBX0FDVElPTiA9ICdhY3Rpb24nO1xuXG4gIC8vIEFjdGlvbnNcbiAgdmFyIEFDVElPTl9FQVNUID0gJ2UnO1xuICB2YXIgQUNUSU9OX1dFU1QgPSAndyc7XG4gIHZhciBBQ1RJT05fU09VVEggPSAncyc7XG4gIHZhciBBQ1RJT05fTk9SVEggPSAnbic7XG4gIHZhciBBQ1RJT05fU09VVEhfRUFTVCA9ICdzZSc7XG4gIHZhciBBQ1RJT05fU09VVEhfV0VTVCA9ICdzdyc7XG4gIHZhciBBQ1RJT05fTk9SVEhfRUFTVCA9ICduZSc7XG4gIHZhciBBQ1RJT05fTk9SVEhfV0VTVCA9ICdudyc7XG4gIHZhciBBQ1RJT05fQUxMID0gJ2FsbCc7XG4gIHZhciBBQ1RJT05fQ1JPUCA9ICdjcm9wJztcbiAgdmFyIEFDVElPTl9NT1ZFID0gJ21vdmUnO1xuICB2YXIgQUNUSU9OX1pPT00gPSAnem9vbSc7XG4gIHZhciBBQ1RJT05fTk9ORSA9ICdub25lJztcblxuICAvLyBTdXBwb3J0c1xuICB2YXIgU1VQUE9SVF9DQU5WQVMgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG4gIHZhciBJU19TQUZBUkkgPSBuYXZpZ2F0b3IgJiYgL3NhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL2FwcGxlIGNvbXB1dGVyL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcblxuICAvLyBNYXRoc1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciBtYXggPSBNYXRoLm1heDtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICB2YXIgc2luID0gTWF0aC5zaW47XG4gIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgLy8gVXRpbGl0aWVzXG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICBmdW5jdGlvbiB0eXBlT2Yob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKG51bSkge1xuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHZhciBjb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG90eXBlO1xuXG4gICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgICByZXR1cm4gY29uc3RydWN0b3IgJiYgcHJvdG90eXBlICYmIGhhc093blByb3BlcnR5LmNhbGwocHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHR5cGVPZihmbikgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShhcnIpIDogdHlwZU9mKGFycikgPT09ICdhcnJheSc7XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KG9iaiwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID49IDAgPyBvZmZzZXQgOiAwO1xuXG4gICAgaWYgKEFycmF5LmZyb20pIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG9iaikuc2xpY2Uob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpY2UuY2FsbChvYmosIG9mZnNldCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmltKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgc3RyID0gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoUkVHRVhQX1RSSU0sICckMScpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuZ3RoO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKG9iaiAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSB8fCBpc051bWJlcihvYmoubGVuZ3RoKS8qIGFycmF5LWxpa2UgKi8pIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqLCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqLCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgdmFyIGFyZ3M7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmIChPYmplY3QuYXNzaWduKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3Muc2hpZnQoKTtcblxuICAgICAgZWFjaChhcmdzLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGVhY2goYXJnLCBmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICAgIG9ialtpXSA9IHByb3A7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3h5KGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHRvQXJyYXkoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gICAgZWFjaChzdHlsZXMsIGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICAgIGlmIChSRUdFWFBfU1VGRklYLnRlc3QocHJvcGVydHkpICYmIGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSArPSAncHgnO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0ID9cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lO1xuXG4gICAgaWYgKGlzTnVtYmVyKGVsZW1lbnQubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgYWRkQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjbGFzc05hbWUgPSB0cmltKGVsZW1lbnQuY2xhc3NOYW1lKTtcblxuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnICcgKyB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBlYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGVsZW0sIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh2YWx1ZSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIHZhbHVlLCBhZGRlZCkge1xuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBlYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsZW0sIHZhbHVlLCBhZGRlZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJRTEwLTExIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiBgY2xhc3NMaXN0LnRvZ2dsZWBcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEoZWxlbWVudCwgbmFtZSkge1xuICAgIHJldHVybiBpc09iamVjdChlbGVtZW50W25hbWVdKSA/XG4gICAgICBlbGVtZW50W25hbWVdIDpcbiAgICAgIGVsZW1lbnQuZGF0YXNldCA/XG4gICAgICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA6XG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERhdGEoZWxlbWVudCwgbmFtZSwgZGF0YSkge1xuICAgIGlmIChpc09iamVjdChkYXRhKSAmJiBpc1VuZGVmaW5lZChlbGVtZW50W25hbWVdKSkge1xuICAgICAgZWxlbWVudFtuYW1lXSA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgIGVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEYXRhKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBpZiAoaXNPYmplY3QoZWxlbWVudFtuYW1lXSkpIHtcbiAgICAgIGRlbGV0ZSBlbGVtZW50W25hbWVdO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb25jZSkge1xuICAgIHZhciB0eXBlcyA9IHRyaW0odHlwZSkuc3BsaXQoUkVHRVhQX1NQQUNFUyk7XG4gICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICBpZiAodHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGVhY2godHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9uY2UpIHtcbiAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuXG4gICAgICAgIHJldHVybiBvcmlnaW5hbEhhbmRsZXIuYXBwbHkoZWxlbWVudCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgdHlwZXMgPSB0cmltKHR5cGUpLnNwbGl0KFJFR0VYUF9TUEFDRVMpO1xuXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBlYWNoKHR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIHR5cGUsIGRhdGEpIHtcbiAgICB2YXIgZXZlbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5kaXNwYXRjaEV2ZW50KSB7XG5cbiAgICAgIC8vIEV2ZW50IGFuZCBDdXN0b21FdmVudCBvbiBJRTktMTEgYXJlIGdsb2JhbCBvYmplY3RzLCBub3QgY29uc3RydWN0b3JzXG4gICAgICBpZiAoaXNGdW5jdGlvbihFdmVudCkgJiYgaXNGdW5jdGlvbihDdXN0b21FdmVudCkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRTktMTFcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSUU5K1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmZpcmVFdmVudCkge1xuXG4gICAgICAvLyBJRTYtMTAgKG5hdGl2ZSBldmVudHMgb25seSlcbiAgICAgIHJldHVybiBlbGVtZW50LmZpcmVFdmVudCgnb24nICsgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFdmVudChldmVudCkge1xuICAgIHZhciBlID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgIHZhciBkb2M7XG5cbiAgICAvLyBGaXggdGFyZ2V0IHByb3BlcnR5IChJRTgpXG4gICAgaWYgKCFlLnRhcmdldCkge1xuICAgICAgZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bWJlcihlLnBhZ2VYKSkge1xuICAgICAgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgZS5wYWdlWCA9IGUuY2xpZW50WCArICh3aW5kb3cuc2Nyb2xsWCB8fCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZS5wYWdlWSA9IGUuY2xpZW50WSArICh3aW5kb3cuc2Nyb2xsWSB8fCBkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArICh3aW5kb3cuc2Nyb2xsWCB8fCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IDApLFxuICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5zY3JvbGxZIHx8IGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IDApXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRvdWNoZXNDZW50ZXIodG91Y2hlcykge1xuICAgIHZhciBsZW5ndGggPSB0b3VjaGVzLmxlbmd0aDtcbiAgICB2YXIgcGFnZVggPSAwO1xuICAgIHZhciBwYWdlWSA9IDA7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBlYWNoKHRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICBwYWdlWCArPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgcGFnZVkgKz0gdG91Y2gucGFnZVk7XG4gICAgICB9KTtcblxuICAgICAgcGFnZVggLz0gbGVuZ3RoO1xuICAgICAgcGFnZVkgLz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYWdlWDogcGFnZVgsXG4gICAgICBwYWdlWTogcGFnZVlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QnlUYWcoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QnlDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID9cbiAgICAgIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpIDpcbiAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBjbGFzc05hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRDaGlsZChlbGVtZW50LCBlbGVtKSB7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkge1xuICAgIHZhciBwYXJ0cyA9IHVybC5tYXRjaChSRUdFWFBfT1JJR0lOUyk7XG5cbiAgICByZXR1cm4gcGFydHMgJiYgKFxuICAgICAgcGFydHNbMV0gIT09IGxvY2F0aW9uLnByb3RvY29sIHx8XG4gICAgICBwYXJ0c1syXSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBhcnRzWzNdICE9PSBsb2NhdGlvbi5wb3J0XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRpbWVzdGFtcCh1cmwpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gJ3RpbWVzdGFtcD0nICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIHJldHVybiAodXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHRpbWVzdGFtcCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbWFnZVNpemUoaW1hZ2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5ld0ltYWdlO1xuXG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzIChpZ25vcmUgU2FmYXJpKVxuICAgIGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgIUlTX1NBRkFSSSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGltYWdlLm5hdHVyYWxXaWR0aCwgaW1hZ2UubmF0dXJhbEhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gSUU4OiBEb24ndCB1c2UgYG5ldyBJbWFnZSgpYCBoZXJlXG4gICAgbmV3SW1hZ2UgPSBjcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgIG5ld0ltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2Uuc3JjO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNmb3JtcyA9IFtdO1xuICAgIHZhciByb3RhdGUgPSBkYXRhLnJvdGF0ZTtcbiAgICB2YXIgc2NhbGVYID0gZGF0YS5zY2FsZVg7XG4gICAgdmFyIHNjYWxlWSA9IGRhdGEuc2NhbGVZO1xuXG4gICAgaWYgKGlzTnVtYmVyKHJvdGF0ZSkpIHtcbiAgICAgIHRyYW5zZm9ybXMucHVzaCgncm90YXRlKCcgKyByb3RhdGUgKyAnZGVnKScpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihzY2FsZVgpICYmIGlzTnVtYmVyKHNjYWxlWSkpIHtcbiAgICAgIHRyYW5zZm9ybXMucHVzaCgnc2NhbGUoJyArIHNjYWxlWCArICcsJyArIHNjYWxlWSArICcpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybXMubGVuZ3RoID8gdHJhbnNmb3Jtcy5qb2luKCcgJykgOiAnbm9uZSc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3RhdGVkU2l6ZXMoZGF0YSwgcmV2ZXJzZWQpIHtcbiAgICB2YXIgZGVnID0gYWJzKGRhdGEuZGVncmVlKSAlIDE4MDtcbiAgICB2YXIgYXJjID0gKGRlZyA+IDkwID8gKDE4MCAtIGRlZykgOiBkZWcpICogUEkgLyAxODA7XG4gICAgdmFyIHNpbkFyYyA9IHNpbihhcmMpO1xuICAgIHZhciBjb3NBcmMgPSBjb3MoYXJjKTtcbiAgICB2YXIgd2lkdGggPSBkYXRhLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBkYXRhLmFzcGVjdFJhdGlvO1xuICAgIHZhciBuZXdXaWR0aDtcbiAgICB2YXIgbmV3SGVpZ2h0O1xuXG4gICAgaWYgKCFyZXZlcnNlZCkge1xuICAgICAgbmV3V2lkdGggPSB3aWR0aCAqIGNvc0FyYyArIGhlaWdodCAqIHNpbkFyYztcbiAgICAgIG5ld0hlaWdodCA9IHdpZHRoICogc2luQXJjICsgaGVpZ2h0ICogY29zQXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdXaWR0aCA9IHdpZHRoIC8gKGNvc0FyYyArIHNpbkFyYyAvIGFzcGVjdFJhdGlvKTtcbiAgICAgIG5ld0hlaWdodCA9IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNvdXJjZUNhbnZhcyhpbWFnZSwgZGF0YSkge1xuICAgIHZhciBjYW52YXMgPSBjcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkc3RYID0gMDtcbiAgICB2YXIgZHN0WSA9IDA7XG4gICAgdmFyIGRzdFdpZHRoID0gZGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgdmFyIGRzdEhlaWdodCA9IGRhdGEubmF0dXJhbEhlaWdodDtcbiAgICB2YXIgcm90YXRlID0gZGF0YS5yb3RhdGU7XG4gICAgdmFyIHNjYWxlWCA9IGRhdGEuc2NhbGVYO1xuICAgIHZhciBzY2FsZVkgPSBkYXRhLnNjYWxlWTtcbiAgICB2YXIgc2NhbGFibGUgPSBpc051bWJlcihzY2FsZVgpICYmIGlzTnVtYmVyKHNjYWxlWSkgJiYgKHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDEpO1xuICAgIHZhciByb3RhdGFibGUgPSBpc051bWJlcihyb3RhdGUpICYmIHJvdGF0ZSAhPT0gMDtcbiAgICB2YXIgYWR2YW5jZWQgPSByb3RhdGFibGUgfHwgc2NhbGFibGU7XG4gICAgdmFyIGNhbnZhc1dpZHRoID0gZHN0V2lkdGggKiBhYnMoc2NhbGVYIHx8IDEpO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBkc3RIZWlnaHQgKiBhYnMoc2NhbGVZIHx8IDEpO1xuICAgIHZhciB0cmFuc2xhdGVYO1xuICAgIHZhciB0cmFuc2xhdGVZO1xuICAgIHZhciByb3RhdGVkO1xuXG4gICAgaWYgKHNjYWxhYmxlKSB7XG4gICAgICB0cmFuc2xhdGVYID0gY2FudmFzV2lkdGggLyAyO1xuICAgICAgdHJhbnNsYXRlWSA9IGNhbnZhc0hlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0YWJsZSkge1xuICAgICAgcm90YXRlZCA9IGdldFJvdGF0ZWRTaXplcyh7XG4gICAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHQsXG4gICAgICAgIGRlZ3JlZTogcm90YXRlXG4gICAgICB9KTtcblxuICAgICAgY2FudmFzV2lkdGggPSByb3RhdGVkLndpZHRoO1xuICAgICAgY2FudmFzSGVpZ2h0ID0gcm90YXRlZC5oZWlnaHQ7XG4gICAgICB0cmFuc2xhdGVYID0gY2FudmFzV2lkdGggLyAyO1xuICAgICAgdHJhbnNsYXRlWSA9IGNhbnZhc0hlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgIGlmIChhZHZhbmNlZCkge1xuICAgICAgZHN0WCA9IC1kc3RXaWR0aCAvIDI7XG4gICAgICBkc3RZID0gLWRzdEhlaWdodCAvIDI7XG5cbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUodHJhbnNsYXRlWCwgdHJhbnNsYXRlWSk7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0YWJsZSkge1xuICAgICAgY29udGV4dC5yb3RhdGUocm90YXRlICogUEkgLyAxODApO1xuICAgIH1cblxuICAgIC8vIFNob3VsZCBjYWxsIGBzY2FsZWAgYWZ0ZXIgcm90YXRlZFxuICAgIGlmIChzY2FsYWJsZSkge1xuICAgICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIGZsb29yKGRzdFgpLCBmbG9vcihkc3RZKSwgZmxvb3IoZHN0V2lkdGgpLCBmbG9vcihkc3RIZWlnaHQpKTtcblxuICAgIGlmIChhZHZhbmNlZCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0cmluZ0Zyb21DaGFyQ29kZShkYXRhVmlldywgc3RhcnQsIGxlbmd0aCkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgaSA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZW5ndGggKz0gc3RhcnQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc3RyICs9IGZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICB2YXIgb3JpZW50YXRpb247XG4gICAgdmFyIGV4aWZJRENvZGU7XG4gICAgdmFyIHRpZmZPZmZzZXQ7XG4gICAgdmFyIGZpcnN0SUZET2Zmc2V0O1xuICAgIHZhciBsaXR0bGVFbmRpYW47XG4gICAgdmFyIGVuZGlhbm5lc3M7XG4gICAgdmFyIGFwcDFTdGFydDtcbiAgICB2YXIgaWZkU3RhcnQ7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgaTtcblxuICAgIC8vIE9ubHkgaGFuZGxlIEpQRUcgaW1hZ2UgKHN0YXJ0IGJ5IDB4RkZEOClcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgoMCkgPT09IDB4RkYgJiYgZGF0YVZpZXcuZ2V0VWludDgoMSkgPT09IDB4RDgpIHtcbiAgICAgIG9mZnNldCA9IDI7XG5cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgPT09IDB4RkYgJiYgZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSkgPT09IDB4RTEpIHtcbiAgICAgICAgICBhcHAxU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXBwMVN0YXJ0KSB7XG4gICAgICBleGlmSURDb2RlID0gYXBwMVN0YXJ0ICsgNDtcbiAgICAgIHRpZmZPZmZzZXQgPSBhcHAxU3RhcnQgKyAxMDtcblxuICAgICAgaWYgKGdldFN0cmluZ0Zyb21DaGFyQ29kZShkYXRhVmlldywgZXhpZklEQ29kZSwgNCkgPT09ICdFeGlmJykge1xuICAgICAgICBlbmRpYW5uZXNzID0gZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpO1xuICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmRpYW5uZXNzID09PSAweDQ5NDk7XG5cbiAgICAgICAgaWYgKGxpdHRsZUVuZGlhbiB8fCBlbmRpYW5uZXNzID09PSAweDRENEQgLyogYmlnRW5kaWFuICovKSB7XG4gICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMDJBKSB7XG4gICAgICAgICAgICBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0ID49IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgICAgICAgaWZkU3RhcnQgPSB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlmZFN0YXJ0KSB7XG4gICAgICBsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoaWZkU3RhcnQsIGxpdHRsZUVuZGlhbik7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBvZmZzZXQgPSBpZmRTdGFydCArIGkgKiAxMiArIDI7XG5cbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikgPT09IDB4MDExMiAvKiBPcmllbnRhdGlvbiAqLykge1xuXG4gICAgICAgICAgLy8gOCBpcyB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHRhZydzIHZhbHVlXG4gICAgICAgICAgb2Zmc2V0ICs9IDg7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIG9yaWVudGF0aW9uIHZhbHVlXG4gICAgICAgICAgb3JpZW50YXRpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIG9yaWVudGF0aW9uIHdpdGggaXRzIGRlZmF1bHQgdmFsdWUgZm9yIFNhZmFyaVxuICAgICAgICAgIGlmIChJU19TQUZBUkkpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQsIDEsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZW50YXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkYXRhVVJMVG9BcnJheUJ1ZmZlcihkYXRhVVJMKSB7XG4gICAgdmFyIGJhc2U2NCA9IGRhdGFVUkwucmVwbGFjZShSRUdFWFBfREFUQV9VUkxfSEVBRCwgJycpO1xuICAgIHZhciBiaW5hcnkgPSBhdG9iKGJhc2U2NCk7XG4gICAgdmFyIGxlbmd0aCA9IGJpbmFyeS5sZW5ndGg7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhVmlld1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIC8vIE9ubHkgYXZhaWxhYmxlIGZvciBKUEVHIGltYWdlXG4gIGZ1bmN0aW9uIGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIHZhciBsZW5ndGggPSBkYXRhVmlldy5sZW5ndGg7XG4gICAgdmFyIGJhc2U2NCA9ICcnO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNlNjQgKz0gZnJvbUNoYXJDb2RlKGRhdGFWaWV3W2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJyArIGJ0b2EoYmFzZTY0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENyb3BwZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBfdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBDcm9wcGVyLkRFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xuICAgIF90aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgX3RoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICBfdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuICAgIF90aGlzLnJvdGF0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5jcm9wcGVkID0gZmFsc2U7XG4gICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xuICAgIF90aGlzLmxpbWl0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgIF90aGlzLmlzSW1nID0gZmFsc2U7XG4gICAgX3RoaXMub3JpZ2luYWxVcmwgPSAnJztcbiAgICBfdGhpcy5jYW52YXNEYXRhID0gbnVsbDtcbiAgICBfdGhpcy5jcm9wQm94RGF0YSA9IG51bGw7XG4gICAgX3RoaXMucHJldmlld3MgPSBudWxsO1xuICAgIF90aGlzLmluaXQoKTtcbiAgfVxuXG4gIENyb3BwZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDcm9wcGVyLFxuXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudDtcbiAgICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgdXJsO1xuXG4gICAgICBpZiAoZ2V0RGF0YShlbGVtZW50LCBOQU1FU1BBQ0UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0RGF0YShlbGVtZW50LCBOQU1FU1BBQ0UsIF90aGlzKTtcblxuICAgICAgaWYgKHRhZ05hbWUgPT09ICdpbWcnKSB7XG4gICAgICAgIF90aGlzLmlzSW1nID0gdHJ1ZTtcblxuICAgICAgICAvLyBlLmcuOiBcImltZy9waWN0dXJlLmpwZ1wiXG4gICAgICAgIF90aGlzLm9yaWdpbmFsVXJsID0gdXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgIC8vIFN0b3Agd2hlbiBpdCdzIGEgYmxhbmsgaW1hZ2VcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlLmcuOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9pbWcvcGljdHVyZS5qcGdcIlxuICAgICAgICB1cmwgPSBlbGVtZW50LnNyYztcbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgU1VQUE9SVF9DQU5WQVMpIHtcbiAgICAgICAgdXJsID0gZWxlbWVudC50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMubG9hZCh1cmwpO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIHhocjtcblxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmJ1aWxkKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9CVUlMRCwgb3B0aW9ucy5idWlsZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX0JVSUxEKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICBfdGhpcy5pbWFnZURhdGEgPSB7fTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNoZWNrT3JpZW50YXRpb24gfHwgIUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBYTUxIdHRwUmVxdWVzdCBkaXNhbGxvd3MgdG8gb3BlbiBhIERhdGEgVVJMIGluIHNvbWUgYnJvd3NlcnMgbGlrZSBJRTExIGFuZCBTYWZhcmlcbiAgICAgIGlmIChSRUdFWFBfREFUQV9VUkwudGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiBSRUdFWFBfREFUQV9VUkxfSlBFRy50ZXN0KHVybCkgP1xuICAgICAgICAgIF90aGlzLnJlYWQoZGF0YVVSTFRvQXJyYXlCdWZmZXIodXJsKSkgOlxuICAgICAgICAgIF90aGlzLmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jbG9uZSgpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVhZCh0aGlzLnJlc3BvbnNlKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKCdnZXQnLCB1cmwpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH0sXG5cbiAgICByZWFkOiBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgb3JpZW50YXRpb24gPSBnZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcik7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gX3RoaXMuaW1hZ2VEYXRhO1xuICAgICAgdmFyIHJvdGF0ZTtcbiAgICAgIHZhciBzY2FsZVg7XG4gICAgICB2YXIgc2NhbGVZO1xuXG4gICAgICBpZiAob3JpZW50YXRpb24gPiAxKSB7XG4gICAgICAgIF90aGlzLnVybCA9IGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyKTtcblxuICAgICAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG5cbiAgICAgICAgICAvLyBmbGlwIGhvcml6b250YWxcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gcm90YXRlIGxlZnQgMTgwwrBcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByb3RhdGUgPSAtMTgwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBmbGlwIHZlcnRpY2FsXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgc2NhbGVZID0gLTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIGZsaXAgdmVydGljYWwgKyByb3RhdGUgcmlnaHQgOTDCsFxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgICAgICAgc2NhbGVZID0gLTE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIHJvdGF0ZSByaWdodCA5MMKwXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIGZsaXAgaG9yaXpvbnRhbCArIHJvdGF0ZSByaWdodCA5MMKwXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gcm90YXRlIGxlZnQgOTDCsFxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJvdGF0ZSA9IC05MDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0YWJsZSkge1xuICAgICAgICBpbWFnZURhdGEucm90YXRlID0gcm90YXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudDtcbiAgICAgIHZhciB1cmwgPSBfdGhpcy51cmw7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW47XG4gICAgICB2YXIgY3Jvc3NPcmlnaW5Vcmw7XG4gICAgICB2YXIgaW1hZ2U7XG4gICAgICB2YXIgc3RhcnQ7XG4gICAgICB2YXIgc3RvcDtcblxuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2hlY2tDcm9zc09yaWdpbiAmJiBpc0Nyb3NzT3JpZ2luVVJMKHVybCkpIHtcbiAgICAgICAgY3Jvc3NPcmlnaW4gPSBlbGVtZW50LmNyb3NzT3JpZ2luO1xuXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgIGNyb3NzT3JpZ2luVXJsID0gdXJsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG5cbiAgICAgICAgICAvLyBCdXN0IGNhY2hlIHdoZW4gdGhlcmUgaXMgbm90IGEgXCJjcm9zc09yaWdpblwiIHByb3BlcnR5XG4gICAgICAgICAgY3Jvc3NPcmlnaW5VcmwgPSBhZGRUaW1lc3RhbXAodXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgX3RoaXMuY3Jvc3NPcmlnaW5VcmwgPSBjcm9zc09yaWdpblVybDtcbiAgICAgIGltYWdlID0gY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSBjcm9zc09yaWdpblVybCB8fCB1cmw7XG4gICAgICBfdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgX3RoaXMuX3N0YXJ0ID0gc3RhcnQgPSBwcm94eShfdGhpcy5zdGFydCwgX3RoaXMpO1xuICAgICAgX3RoaXMuX3N0b3AgPSBzdG9wID0gcHJveHkoX3RoaXMuc3RvcCwgX3RoaXMpO1xuXG4gICAgICBpZiAoX3RoaXMuaXNJbWcpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY29tcGxldGUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0xPQUQsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIHN0YXJ0KTtcbiAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBzdG9wKTtcbiAgICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGltYWdlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBpbWFnZSA9IF90aGlzLmlzSW1nID8gX3RoaXMuZWxlbWVudCA6IF90aGlzLmltYWdlO1xuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIF90aGlzLl9zdGFydCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9FUlJPUiwgX3RoaXMuX3N0b3ApO1xuICAgICAgfVxuXG4gICAgICBnZXRJbWFnZVNpemUoaW1hZ2UsIGZ1bmN0aW9uIChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgZXh0ZW5kKF90aGlzLmltYWdlRGF0YSwge1xuICAgICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgYXNwZWN0UmF0aW86IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICBfdGhpcy5idWlsZCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaW1hZ2UgPSBfdGhpcy5pbWFnZTtcblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIF90aGlzLl9zdGFydCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfRVJST1IsIF90aGlzLl9zdG9wKTtcblxuICAgICAgcmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgX3RoaXMuaW1hZ2UgPSBudWxsO1xuICAgIH0sXG5cbiAgICBidWlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudDtcbiAgICAgIHZhciBpbWFnZSA9IF90aGlzLmltYWdlO1xuICAgICAgdmFyIGNvbnRhaW5lcjtcbiAgICAgIHZhciB0ZW1wbGF0ZTtcbiAgICAgIHZhciBjcm9wcGVyO1xuICAgICAgdmFyIGNhbnZhcztcbiAgICAgIHZhciBkcmFnQm94O1xuICAgICAgdmFyIGNyb3BCb3g7XG4gICAgICB2YXIgZmFjZTtcblxuICAgICAgaWYgKCFfdGhpcy5yZWFkeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFVuYnVpbGQgZmlyc3Qgd2hlbiByZXBsYWNlXG4gICAgICBpZiAoX3RoaXMuYnVpbHQpIHtcbiAgICAgICAgX3RoaXMudW5idWlsZCgpO1xuICAgICAgfVxuXG4gICAgICB0ZW1wbGF0ZSA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gQ3JvcHBlci5URU1QTEFURTtcblxuICAgICAgLy8gQ3JlYXRlIGNyb3BwZXIgZWxlbWVudHNcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIF90aGlzLmNyb3BwZXIgPSBjcm9wcGVyID0gZ2V0QnlDbGFzcyh0ZW1wbGF0ZSwgJ2Nyb3BwZXItY29udGFpbmVyJylbMF07XG4gICAgICBfdGhpcy5jYW52YXMgPSBjYW52YXMgPSBnZXRCeUNsYXNzKGNyb3BwZXIsICdjcm9wcGVyLWNhbnZhcycpWzBdO1xuICAgICAgX3RoaXMuZHJhZ0JveCA9IGRyYWdCb3ggPSBnZXRCeUNsYXNzKGNyb3BwZXIsICdjcm9wcGVyLWRyYWctYm94JylbMF07XG4gICAgICBfdGhpcy5jcm9wQm94ID0gY3JvcEJveCA9IGdldEJ5Q2xhc3MoY3JvcHBlciwgJ2Nyb3BwZXItY3JvcC1ib3gnKVswXTtcbiAgICAgIF90aGlzLnZpZXdCb3ggPSBnZXRCeUNsYXNzKGNyb3BwZXIsICdjcm9wcGVyLXZpZXctYm94JylbMF07XG4gICAgICBfdGhpcy5mYWNlID0gZmFjZSA9IGdldEJ5Q2xhc3MoY3JvcEJveCwgJ2Nyb3BwZXItZmFjZScpWzBdO1xuXG4gICAgICBhcHBlbmRDaGlsZChjYW52YXMsIGltYWdlKTtcblxuICAgICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIENMQVNTX0hJRERFTik7XG5cbiAgICAgIC8vIEluc2VydHMgdGhlIGNyb3BwZXIgYWZ0ZXIgdG8gdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY3JvcHBlciwgZWxlbWVudC5uZXh0U2libGluZyk7XG5cbiAgICAgIC8vIFNob3cgdGhlIGltYWdlIGlmIGlzIGhpZGRlblxuICAgICAgaWYgKCFfdGhpcy5pc0ltZykge1xuICAgICAgICByZW1vdmVDbGFzcyhpbWFnZSwgQ0xBU1NfSElERSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmluaXRQcmV2aWV3KCk7XG4gICAgICBfdGhpcy5iaW5kKCk7XG5cbiAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBtYXgoMCwgb3B0aW9ucy5hc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgb3B0aW9ucy52aWV3TW9kZSA9IG1heCgwLCBtaW4oMywgcm91bmQob3B0aW9ucy52aWV3TW9kZSkpKSB8fCAwO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdXRvQ3JvcCkge1xuICAgICAgICBfdGhpcy5jcm9wcGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5tb2RhbCkge1xuICAgICAgICAgIGFkZENsYXNzKGRyYWdCb3gsIENMQVNTX01PREFMKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmd1aWRlcykge1xuICAgICAgICBhZGRDbGFzcyhnZXRCeUNsYXNzKGNyb3BCb3gsICdjcm9wcGVyLWRhc2hlZCcpLCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgIGFkZENsYXNzKGdldEJ5Q2xhc3MoY3JvcEJveCwgJ2Nyb3BwZXItY2VudGVyJyksIENMQVNTX0hJRERFTik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmQpIHtcbiAgICAgICAgYWRkQ2xhc3MoY3JvcHBlciwgQ0xBU1NfQkcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIGFkZENsYXNzKGZhY2UsIENMQVNTX01PVkUpO1xuICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBBQ1RJT05fQUxMKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmNyb3BCb3hSZXNpemFibGUpIHtcbiAgICAgICAgYWRkQ2xhc3MoZ2V0QnlDbGFzcyhjcm9wQm94LCAnY3JvcHBlci1saW5lJyksIENMQVNTX0hJRERFTik7XG4gICAgICAgIGFkZENsYXNzKGdldEJ5Q2xhc3MoY3JvcEJveCwgJ2Nyb3BwZXItcG9pbnQnKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0RHJhZ01vZGUob3B0aW9ucy5kcmFnTW9kZSk7XG4gICAgICBfdGhpcy5yZW5kZXIoKTtcbiAgICAgIF90aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgIF90aGlzLnNldERhdGEob3B0aW9ucy5kYXRhKTtcblxuICAgICAgLy8gQ2FsbCB0aGUgYnVpbHQgYXN5bmNocm9ub3VzbHkgdG8ga2VlcCBcImltYWdlLmNyb3BwZXJcIiBpcyBkZWZpbmVkXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5idWlsdCkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9CVUlMVCwgb3B0aW9ucy5idWlsdCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX0JVSUxUKTtcbiAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9DUk9QLCBfdGhpcy5nZXREYXRhKCkpO1xuXG4gICAgICAgIF90aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIH0sIDApO1xuICAgIH0sXG5cbiAgICB1bmJ1aWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIV90aGlzLmJ1aWx0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICBfdGhpcy5pbml0aWFsSW1hZ2VEYXRhID0gbnVsbDtcblxuICAgICAgLy8gQ2xlYXIgYGluaXRpYWxDYW52YXNEYXRhYCBpcyBuZWNlc3Nhcnkgd2hlbiByZXBsYWNlXG4gICAgICBfdGhpcy5pbml0aWFsQ2FudmFzRGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5pbml0aWFsQ3JvcEJveERhdGEgPSBudWxsO1xuICAgICAgX3RoaXMuY29udGFpbmVyRGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5jYW52YXNEYXRhID0gbnVsbDtcblxuICAgICAgLy8gQ2xlYXIgYGNyb3BCb3hEYXRhYCBpcyBuZWNlc3Nhcnkgd2hlbiByZXBsYWNlXG4gICAgICBfdGhpcy5jcm9wQm94RGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy51bmJpbmQoKTtcblxuICAgICAgX3RoaXMucmVzZXRQcmV2aWV3KCk7XG4gICAgICBfdGhpcy5wcmV2aWV3cyA9IG51bGw7XG5cbiAgICAgIF90aGlzLnZpZXdCb3ggPSBudWxsO1xuICAgICAgX3RoaXMuY3JvcEJveCA9IG51bGw7XG4gICAgICBfdGhpcy5kcmFnQm94ID0gbnVsbDtcbiAgICAgIF90aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICBfdGhpcy5jb250YWluZXIgPSBudWxsO1xuXG4gICAgICByZW1vdmVDaGlsZChfdGhpcy5jcm9wcGVyKTtcbiAgICAgIF90aGlzLmNyb3BwZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIF90aGlzLmluaXRDb250YWluZXIoKTtcbiAgICAgIF90aGlzLmluaXRDYW52YXMoKTtcbiAgICAgIF90aGlzLmluaXRDcm9wQm94KCk7XG5cbiAgICAgIF90aGlzLnJlbmRlckNhbnZhcygpO1xuXG4gICAgICBpZiAoX3RoaXMuY3JvcHBlZCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmVsZW1lbnQ7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuY29udGFpbmVyO1xuICAgICAgdmFyIGNyb3BwZXIgPSBfdGhpcy5jcm9wcGVyO1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGE7XG5cbiAgICAgIGFkZENsYXNzKGNyb3BwZXIsIENMQVNTX0hJRERFTik7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuXG4gICAgICBfdGhpcy5jb250YWluZXJEYXRhID0gY29udGFpbmVyRGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IG1heChcbiAgICAgICAgICBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgTnVtYmVyKG9wdGlvbnMubWluQ29udGFpbmVyV2lkdGgpIHx8IDIwMFxuICAgICAgICApLFxuICAgICAgICBoZWlnaHQ6IG1heChcbiAgICAgICAgICBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIE51bWJlcihvcHRpb25zLm1pbkNvbnRhaW5lckhlaWdodCkgfHwgMTAwXG4gICAgICAgIClcbiAgICAgIH07XG5cbiAgICAgIHNldFN0eWxlKGNyb3BwZXIsIHtcbiAgICAgICAgd2lkdGg6IGNvbnRhaW5lckRhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogY29udGFpbmVyRGF0YS5oZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuICAgICAgcmVtb3ZlQ2xhc3MoY3JvcHBlciwgQ0xBU1NfSElEREVOKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FudmFzIChpbWFnZSB3cmFwcGVyKVxuICAgIGluaXRDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdmlld01vZGUgPSBfdGhpcy5vcHRpb25zLnZpZXdNb2RlO1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGEgPSBfdGhpcy5jb250YWluZXJEYXRhO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IF90aGlzLmltYWdlRGF0YTtcbiAgICAgIHZhciByb3RhdGVkID0gYWJzKGltYWdlRGF0YS5yb3RhdGUpID09PSA5MDtcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgOiBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA6IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgY2FudmFzRGF0YTtcblxuICAgICAgaWYgKGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBjb250YWluZXJEYXRhLndpZHRoKSB7XG4gICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICAgIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW52YXNIZWlnaHQgPSBjb250YWluZXJEYXRhLndpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICAgIGNhbnZhc0hlaWdodCA9IGNvbnRhaW5lckRhdGEud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FudmFzRGF0YSA9IHtcbiAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgfTtcblxuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0ID0gKGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNXaWR0aCkgLyAyO1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcCA9IChjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0hlaWdodCkgLyAyO1xuXG4gICAgICBfdGhpcy5jYW52YXNEYXRhID0gY2FudmFzRGF0YTtcbiAgICAgIF90aGlzLmxpbWl0ZWQgPSAodmlld01vZGUgPT09IDEgfHwgdmlld01vZGUgPT09IDIpO1xuICAgICAgX3RoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICBfdGhpcy5pbml0aWFsSW1hZ2VEYXRhID0gZXh0ZW5kKHt9LCBpbWFnZURhdGEpO1xuICAgICAgX3RoaXMuaW5pdGlhbENhbnZhc0RhdGEgPSBleHRlbmQoe30sIGNhbnZhc0RhdGEpO1xuICAgIH0sXG5cbiAgICBsaW1pdENhbnZhczogZnVuY3Rpb24gKHNpemVMaW1pdGVkLCBwb3NpdGlvbkxpbWl0ZWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgdmlld01vZGUgPSBvcHRpb25zLnZpZXdNb2RlO1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGEgPSBfdGhpcy5jb250YWluZXJEYXRhO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gY2FudmFzRGF0YS5hc3BlY3RSYXRpbztcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IF90aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIGNyb3BwZWQgPSBfdGhpcy5jcm9wcGVkICYmIGNyb3BCb3hEYXRhO1xuICAgICAgdmFyIG1pbkNhbnZhc1dpZHRoO1xuICAgICAgdmFyIG1pbkNhbnZhc0hlaWdodDtcbiAgICAgIHZhciBuZXdDYW52YXNMZWZ0O1xuICAgICAgdmFyIG5ld0NhbnZhc1RvcDtcblxuICAgICAgaWYgKHNpemVMaW1pdGVkKSB7XG4gICAgICAgIG1pbkNhbnZhc1dpZHRoID0gTnVtYmVyKG9wdGlvbnMubWluQ2FudmFzV2lkdGgpIHx8IDA7XG4gICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IE51bWJlcihvcHRpb25zLm1pbkNhbnZhc0hlaWdodCkgfHwgMDtcblxuICAgICAgICBpZiAodmlld01vZGUgPiAxKSB7XG4gICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtYXgobWluQ2FudmFzV2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xuICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1heChtaW5DYW52YXNIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID4gMCkge1xuICAgICAgICAgIGlmIChtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtYXgoXG4gICAgICAgICAgICAgIG1pbkNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgICBjcm9wcGVkID8gY3JvcEJveERhdGEud2lkdGggOiAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWluQ2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBtYXgoXG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgICAgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLmhlaWdodCA6IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9wcGVkKSB7XG4gICAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gY3JvcEJveERhdGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAobWluQ2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gbWluQ2FudmFzV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluQ2FudmFzV2lkdGggJiYgbWluQ2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc1dpZHRoID0gbWluQ2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1pbkNhbnZhc1dpZHRoKSB7XG4gICAgICAgICAgbWluQ2FudmFzSGVpZ2h0ID0gbWluQ2FudmFzV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChtaW5DYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzRGF0YS5taW5XaWR0aCA9IG1pbkNhbnZhc1dpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLm1pbkhlaWdodCA9IG1pbkNhbnZhc0hlaWdodDtcbiAgICAgICAgY2FudmFzRGF0YS5tYXhXaWR0aCA9IEluZmluaXR5O1xuICAgICAgICBjYW52YXNEYXRhLm1heEhlaWdodCA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICAgIGlmICh2aWV3TW9kZSkge1xuICAgICAgICAgIG5ld0NhbnZhc0xlZnQgPSBjb250YWluZXJEYXRhLndpZHRoIC0gY2FudmFzRGF0YS53aWR0aDtcbiAgICAgICAgICBuZXdDYW52YXNUb3AgPSBjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0O1xuXG4gICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gbWluKDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gbWluKDAsIG5ld0NhbnZhc1RvcCk7XG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gbWF4KDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gbWF4KDAsIG5ld0NhbnZhc1RvcCk7XG5cbiAgICAgICAgICBpZiAoY3JvcHBlZCAmJiBfdGhpcy5saW1pdGVkKSB7XG4gICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBtaW4oXG4gICAgICAgICAgICAgIGNyb3BCb3hEYXRhLmxlZnQsXG4gICAgICAgICAgICAgIGNyb3BCb3hEYXRhLmxlZnQgKyBjcm9wQm94RGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYW52YXNEYXRhLm1pblRvcCA9IG1pbihcbiAgICAgICAgICAgICAgY3JvcEJveERhdGEudG9wLFxuICAgICAgICAgICAgICBjcm9wQm94RGF0YS50b3AgKyBjcm9wQm94RGF0YS5oZWlnaHQgLSBjYW52YXNEYXRhLmhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XG4gICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAyKSB7XG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLndpZHRoID49IGNvbnRhaW5lckRhdGEud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBtaW4oMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gbWF4KDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID49IGNvbnRhaW5lckRhdGEuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBtaW4oMCwgbmV3Q2FudmFzVG9wKTtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IG1heCgwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbnZhc0RhdGEubWluTGVmdCA9IC1jYW52YXNEYXRhLndpZHRoO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gLWNhbnZhc0RhdGEuaGVpZ2h0O1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhUb3AgPSBjb250YWluZXJEYXRhLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IF90aGlzLmltYWdlRGF0YTtcbiAgICAgIHZhciByb3RhdGUgPSBpbWFnZURhdGEucm90YXRlO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvO1xuICAgICAgdmFyIHJvdGF0ZWREYXRhO1xuXG4gICAgICBpZiAoX3RoaXMucm90YXRlZCkge1xuICAgICAgICBfdGhpcy5yb3RhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZXMgcm90YXRlZCBzaXplcyB3aXRoIGltYWdlIHNpemVzXG4gICAgICAgIHJvdGF0ZWREYXRhID0gZ2V0Um90YXRlZFNpemVzKHtcbiAgICAgICAgICB3aWR0aDogaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBkZWdyZWU6IHJvdGF0ZVxuICAgICAgICB9KTtcblxuICAgICAgICBhc3BlY3RSYXRpbyA9IHJvdGF0ZWREYXRhLndpZHRoIC8gcm90YXRlZERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbyAhPT0gY2FudmFzRGF0YS5hc3BlY3RSYXRpbykge1xuICAgICAgICAgIGNhbnZhc0RhdGEubGVmdCAtPSAocm90YXRlZERhdGEud2lkdGggLSBjYW52YXNEYXRhLndpZHRoKSAvIDI7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKHJvdGF0ZWREYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IHJvdGF0ZWREYXRhLndpZHRoO1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gcm90YXRlZERhdGEuaGVpZ2h0O1xuICAgICAgICAgIGNhbnZhc0RhdGEuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICAgICAgICBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCA9IGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0ID0gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQ7XG5cbiAgICAgICAgICAvLyBDb21wdXRlcyByb3RhdGVkIHNpemVzIHdpdGggbmF0dXJhbCBpbWFnZSBzaXplc1xuICAgICAgICAgIGlmIChyb3RhdGUgJSAxODApIHtcbiAgICAgICAgICAgIHJvdGF0ZWREYXRhID0gZ2V0Um90YXRlZFNpemVzKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICAgIGRlZ3JlZTogcm90YXRlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FudmFzRGF0YS5uYXR1cmFsV2lkdGggPSByb3RhdGVkRGF0YS53aWR0aDtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCA9IHJvdGF0ZWREYXRhLmhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5saW1pdENhbnZhcyh0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8XG4gICAgICAgIGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XG4gICAgICAgIGNhbnZhc0RhdGEubGVmdCA9IGNhbnZhc0RhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID4gY2FudmFzRGF0YS5tYXhIZWlnaHQgfHxcbiAgICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPCBjYW52YXNEYXRhLm1pbkhlaWdodCkge1xuICAgICAgICBjYW52YXNEYXRhLnRvcCA9IGNhbnZhc0RhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gbWluKFxuICAgICAgICBtYXgoY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5taW5XaWR0aCksXG4gICAgICAgIGNhbnZhc0RhdGEubWF4V2lkdGhcbiAgICAgICk7XG4gICAgICBjYW52YXNEYXRhLmhlaWdodCA9IG1pbihcbiAgICAgICAgbWF4KGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLm1pbkhlaWdodCksXG4gICAgICAgIGNhbnZhc0RhdGEubWF4SGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBfdGhpcy5saW1pdENhbnZhcyhmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgIGNhbnZhc0RhdGEub2xkTGVmdCA9IGNhbnZhc0RhdGEubGVmdCA9IG1pbihcbiAgICAgICAgbWF4KGNhbnZhc0RhdGEubGVmdCwgY2FudmFzRGF0YS5taW5MZWZ0KSxcbiAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0XG4gICAgICApO1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcCA9IG1pbihcbiAgICAgICAgbWF4KGNhbnZhc0RhdGEudG9wLCBjYW52YXNEYXRhLm1pblRvcCksXG4gICAgICAgIGNhbnZhc0RhdGEubWF4VG9wXG4gICAgICApO1xuXG4gICAgICBzZXRTdHlsZShfdGhpcy5jYW52YXMsIHtcbiAgICAgICAgd2lkdGg6IGNhbnZhc0RhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGNhbnZhc0RhdGEubGVmdCxcbiAgICAgICAgdG9wOiBjYW52YXNEYXRhLnRvcFxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnJlbmRlckltYWdlKCk7XG5cbiAgICAgIGlmIChfdGhpcy5jcm9wcGVkICYmIF90aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgX3RoaXMubGltaXRDcm9wQm94KHRydWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBfdGhpcy5vdXRwdXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVySW1hZ2U6IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IF90aGlzLmltYWdlRGF0YTtcbiAgICAgIHZhciBuZXdJbWFnZURhdGE7XG4gICAgICB2YXIgcmV2ZXJzZWREYXRhO1xuICAgICAgdmFyIHJldmVyc2VkV2lkdGg7XG4gICAgICB2YXIgcmV2ZXJzZWRIZWlnaHQ7XG4gICAgICB2YXIgdHJhbnNmb3JtO1xuXG4gICAgICBpZiAoaW1hZ2VEYXRhLnJvdGF0ZSkge1xuICAgICAgICByZXZlcnNlZERhdGEgPSBnZXRSb3RhdGVkU2l6ZXMoe1xuICAgICAgICAgIHdpZHRoOiBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHQsXG4gICAgICAgICAgZGVncmVlOiBpbWFnZURhdGEucm90YXRlLFxuICAgICAgICAgIGFzcGVjdFJhdGlvOiBpbWFnZURhdGEuYXNwZWN0UmF0aW9cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV2ZXJzZWRXaWR0aCA9IHJldmVyc2VkRGF0YS53aWR0aDtcbiAgICAgICAgcmV2ZXJzZWRIZWlnaHQgPSByZXZlcnNlZERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIG5ld0ltYWdlRGF0YSA9IHtcbiAgICAgICAgICB3aWR0aDogcmV2ZXJzZWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHJldmVyc2VkSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IChjYW52YXNEYXRhLndpZHRoIC0gcmV2ZXJzZWRXaWR0aCkgLyAyLFxuICAgICAgICAgIHRvcDogKGNhbnZhc0RhdGEuaGVpZ2h0IC0gcmV2ZXJzZWRIZWlnaHQpIC8gMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBleHRlbmQoaW1hZ2VEYXRhLCBuZXdJbWFnZURhdGEgfHwge1xuICAgICAgICB3aWR0aDogY2FudmFzRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9KTtcblxuICAgICAgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKGltYWdlRGF0YSk7XG5cbiAgICAgIHNldFN0eWxlKF90aGlzLmltYWdlLCB7XG4gICAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgbWFyZ2luTGVmdDogaW1hZ2VEYXRhLmxlZnQsXG4gICAgICAgIG1hcmdpblRvcDogaW1hZ2VEYXRhLnRvcCxcbiAgICAgICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIG1zVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgX3RoaXMub3V0cHV0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXRDcm9wQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICAgIHZhciBhdXRvQ3JvcEFyZWEgPSBOdW1iZXIob3B0aW9ucy5hdXRvQ3JvcEFyZWEpIHx8IDAuODtcbiAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoY2FudmFzRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbyA+IGNhbnZhc0RhdGEud2lkdGgpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gY3JvcEJveERhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuY3JvcEJveERhdGEgPSBjcm9wQm94RGF0YTtcbiAgICAgIF90aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhdXRvIGNyb3AgYXJlYVxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBtaW4oXG4gICAgICAgIG1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLFxuICAgICAgICBjcm9wQm94RGF0YS5tYXhXaWR0aFxuICAgICAgKTtcbiAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IG1pbihcbiAgICAgICAgbWF4KGNyb3BCb3hEYXRhLmhlaWdodCwgY3JvcEJveERhdGEubWluSGVpZ2h0KSxcbiAgICAgICAgY3JvcEJveERhdGEubWF4SGVpZ2h0XG4gICAgICApO1xuXG4gICAgICAvLyBUaGUgd2lkdGgvaGVpZ2h0IG9mIGF1dG8gY3JvcCBhcmVhIG11c3QgbGFyZ2UgdGhhbiBcIm1pbldpZHRoL0hlaWdodFwiXG4gICAgICBjcm9wQm94RGF0YS53aWR0aCA9IG1heChcbiAgICAgICAgY3JvcEJveERhdGEubWluV2lkdGgsXG4gICAgICAgIGNyb3BCb3hEYXRhLndpZHRoICogYXV0b0Nyb3BBcmVhXG4gICAgICApO1xuICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gbWF4KFxuICAgICAgICBjcm9wQm94RGF0YS5taW5IZWlnaHQsXG4gICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCAqIGF1dG9Dcm9wQXJlYVxuICAgICAgKTtcbiAgICAgIGNyb3BCb3hEYXRhLm9sZExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0ID0gKFxuICAgICAgICBjYW52YXNEYXRhLmxlZnQgKyAoY2FudmFzRGF0YS53aWR0aCAtIGNyb3BCb3hEYXRhLndpZHRoKSAvIDJcbiAgICAgICk7XG4gICAgICBjcm9wQm94RGF0YS5vbGRUb3AgPSBjcm9wQm94RGF0YS50b3AgPSAoXG4gICAgICAgIGNhbnZhc0RhdGEudG9wICsgKGNhbnZhc0RhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0KSAvIDJcbiAgICAgICk7XG5cbiAgICAgIF90aGlzLmluaXRpYWxDcm9wQm94RGF0YSA9IGV4dGVuZCh7fSwgY3JvcEJveERhdGEpO1xuICAgIH0sXG5cbiAgICBsaW1pdENyb3BCb3g6IGZ1bmN0aW9uIChzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICAgIHZhciBjb250YWluZXJEYXRhID0gX3RoaXMuY29udGFpbmVyRGF0YTtcbiAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IF90aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIGxpbWl0ZWQgPSBfdGhpcy5saW1pdGVkO1xuICAgICAgdmFyIG1pbkNyb3BCb3hXaWR0aDtcbiAgICAgIHZhciBtaW5Dcm9wQm94SGVpZ2h0O1xuICAgICAgdmFyIG1heENyb3BCb3hXaWR0aDtcbiAgICAgIHZhciBtYXhDcm9wQm94SGVpZ2h0O1xuXG4gICAgICBpZiAoc2l6ZUxpbWl0ZWQpIHtcbiAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gTnVtYmVyKG9wdGlvbnMubWluQ3JvcEJveFdpZHRoKSB8fCAwO1xuICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ3JvcEJveEhlaWdodCkgfHwgMDtcblxuICAgICAgICAvLyBUaGUgbWluL21heENyb3BCb3hXaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gY29udGFpbmVyV2lkdGgvSGVpZ2h0XG4gICAgICAgIG1pbkNyb3BCb3hXaWR0aCA9IG1pbihtaW5Dcm9wQm94V2lkdGgsIGNvbnRhaW5lckRhdGEud2lkdGgpO1xuICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluKG1pbkNyb3BCb3hIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcbiAgICAgICAgbWF4Q3JvcEJveFdpZHRoID0gbWluKFxuICAgICAgICAgIGNvbnRhaW5lckRhdGEud2lkdGgsXG4gICAgICAgICAgbGltaXRlZCA/IGNhbnZhc0RhdGEud2lkdGggOiBjb250YWluZXJEYXRhLndpZHRoXG4gICAgICAgICk7XG4gICAgICAgIG1heENyb3BCb3hIZWlnaHQgPSBtaW4oXG4gICAgICAgICAgY29udGFpbmVyRGF0YS5oZWlnaHQsXG4gICAgICAgICAgbGltaXRlZCA/IGNhbnZhc0RhdGEuaGVpZ2h0IDogY29udGFpbmVyRGF0YS5oZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAobWluQ3JvcEJveFdpZHRoICYmIG1pbkNyb3BCb3hIZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5Dcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IG1pbkNyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluQ3JvcEJveFdpZHRoKSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5Dcm9wQm94SGVpZ2h0KSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94V2lkdGggPSBtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heENyb3BCb3hIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1heENyb3BCb3hXaWR0aCkge1xuICAgICAgICAgICAgbWF4Q3JvcEJveEhlaWdodCA9IG1heENyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhDcm9wQm94V2lkdGggPSBtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1pbldpZHRoL0hlaWdodCBtdXN0IGJlIGxlc3MgdGhhbiBtYXhXaWR0aC9IZWlnaHRcbiAgICAgICAgY3JvcEJveERhdGEubWluV2lkdGggPSBtaW4obWluQ3JvcEJveFdpZHRoLCBtYXhDcm9wQm94V2lkdGgpO1xuICAgICAgICBjcm9wQm94RGF0YS5taW5IZWlnaHQgPSBtaW4obWluQ3JvcEJveEhlaWdodCwgbWF4Q3JvcEJveEhlaWdodCk7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFdpZHRoID0gbWF4Q3JvcEJveFdpZHRoO1xuICAgICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHQgPSBtYXhDcm9wQm94SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICAgIGlmIChsaW1pdGVkKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IG1heCgwLCBjYW52YXNEYXRhLmxlZnQpO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1pblRvcCA9IG1heCgwLCBjYW52YXNEYXRhLnRvcCk7XG4gICAgICAgICAgY3JvcEJveERhdGEubWF4TGVmdCA9IG1pbihcbiAgICAgICAgICAgIGNvbnRhaW5lckRhdGEud2lkdGgsXG4gICAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgKyBjYW52YXNEYXRhLndpZHRoXG4gICAgICAgICAgKSAtIGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IG1pbihcbiAgICAgICAgICAgIGNvbnRhaW5lckRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodFxuICAgICAgICAgICkgLSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IDA7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluVG9wID0gMDtcbiAgICAgICAgICBjcm9wQm94RGF0YS5tYXhMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aCAtIGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlckNyb3BCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY29udGFpbmVyRGF0YSA9IF90aGlzLmNvbnRhaW5lckRhdGE7XG4gICAgICB2YXIgY3JvcEJveERhdGEgPSBfdGhpcy5jcm9wQm94RGF0YTtcblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLndpZHRoID4gY3JvcEJveERhdGEubWF4V2lkdGggfHxcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPCBjcm9wQm94RGF0YS5taW5XaWR0aCkge1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gY3JvcEJveERhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLmhlaWdodCA+IGNyb3BCb3hEYXRhLm1heEhlaWdodCB8fFxuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPCBjcm9wQm94RGF0YS5taW5IZWlnaHQpIHtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gY3JvcEJveERhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjcm9wQm94RGF0YS53aWR0aCA9IG1pbihcbiAgICAgICAgbWF4KGNyb3BCb3hEYXRhLndpZHRoLCBjcm9wQm94RGF0YS5taW5XaWR0aCksXG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFdpZHRoXG4gICAgICApO1xuICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gbWluKFxuICAgICAgICBtYXgoY3JvcEJveERhdGEuaGVpZ2h0LCBjcm9wQm94RGF0YS5taW5IZWlnaHQpLFxuICAgICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIF90aGlzLmxpbWl0Q3JvcEJveChmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgIGNyb3BCb3hEYXRhLm9sZExlZnQgPSBjcm9wQm94RGF0YS5sZWZ0ID0gbWluKFxuICAgICAgICBtYXgoY3JvcEJveERhdGEubGVmdCwgY3JvcEJveERhdGEubWluTGVmdCksXG4gICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnRcbiAgICAgICk7XG4gICAgICBjcm9wQm94RGF0YS5vbGRUb3AgPSBjcm9wQm94RGF0YS50b3AgPSBtaW4oXG4gICAgICAgIG1heChjcm9wQm94RGF0YS50b3AsIGNyb3BCb3hEYXRhLm1pblRvcCksXG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcFxuICAgICAgKTtcblxuICAgICAgaWYgKG9wdGlvbnMubW92YWJsZSAmJiBvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG5cbiAgICAgICAgLy8gVHVybiB0byBtb3ZlIHRoZSBjYW52YXMgd2hlbiB0aGUgY3JvcCBib3ggaXMgZXF1YWwgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBzZXREYXRhKF90aGlzLmZhY2UsIERBVEFfQUNUSU9OLCBjcm9wQm94RGF0YS53aWR0aCA9PT0gY29udGFpbmVyRGF0YS53aWR0aCAmJlxuICAgICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9PT0gY29udGFpbmVyRGF0YS5oZWlnaHQgPyBBQ1RJT05fTU9WRSA6IEFDVElPTl9BTEwpO1xuICAgICAgfVxuXG4gICAgICBzZXRTdHlsZShfdGhpcy5jcm9wQm94LCB7XG4gICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjcm9wQm94RGF0YS5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGNyb3BCb3hEYXRhLmxlZnQsXG4gICAgICAgIHRvcDogY3JvcEJveERhdGEudG9wXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLmNyb3BwZWQgJiYgX3RoaXMubGltaXRlZCkge1xuICAgICAgICBfdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICBfdGhpcy5vdXRwdXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3V0cHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfdGhpcy5wcmV2aWV3KCk7XG5cbiAgICAgIGlmIChfdGhpcy5jb21wbGV0ZSkge1xuICAgICAgICBkaXNwYXRjaEV2ZW50KF90aGlzLmVsZW1lbnQsIEVWRU5UX0NST1AsIF90aGlzLmdldERhdGEoKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluaXRQcmV2aWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHByZXZpZXcgPSBfdGhpcy5vcHRpb25zLnByZXZpZXc7XG4gICAgICB2YXIgaW1hZ2UgPSBjcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHZhciBjcm9zc09yaWdpbiA9IF90aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgdmFyIHVybCA9IGNyb3NzT3JpZ2luID8gX3RoaXMuY3Jvc3NPcmlnaW5VcmwgOiBfdGhpcy51cmw7XG4gICAgICB2YXIgcHJldmlld3M7XG5cbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICBhcHBlbmRDaGlsZChfdGhpcy52aWV3Qm94LCBpbWFnZSk7XG4gICAgICBfdGhpcy5pbWFnZTIgPSBpbWFnZTtcblxuICAgICAgaWYgKCFwcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJldmlld3MgPSBwcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocHJldmlldyk7XG5cbiAgICAgIGVhY2gocHJldmlld3MsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBpbWFnZSA9IGNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHNpemUgZm9yIHJlY292ZXJcbiAgICAgICAgc2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcsIHtcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIGh0bWw6IGVsZW1lbnQuaW5uZXJIVE1MXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIGltZyBlbGVtZW50IHN0eWxlc1xuICAgICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcbiAgICAgICAgICogQWRkIGBoZWlnaHQ6YXV0b2AgdG8gb3ZlcnJpZGUgYGhlaWdodGAgYXR0cmlidXRlIG9uIElFOFxuICAgICAgICAgKiAoT2NjdXIgb25seSB3aGVuIG1hcmdpbi10b3AgPD0gLWhlaWdodClcbiAgICAgICAgICovXG5cbiAgICAgICAgaW1hZ2Uuc3R5bGUuY3NzVGV4dCA9IChcbiAgICAgICAgICAnZGlzcGxheTpibG9jazsnICtcbiAgICAgICAgICAnd2lkdGg6MTAwJTsnICtcbiAgICAgICAgICAnaGVpZ2h0OmF1dG87JyArXG4gICAgICAgICAgJ21pbi13aWR0aDowIWltcG9ydGFudDsnICtcbiAgICAgICAgICAnbWluLWhlaWdodDowIWltcG9ydGFudDsnICtcbiAgICAgICAgICAnbWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50OycgK1xuICAgICAgICAgICdtYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50OycgK1xuICAgICAgICAgICdpbWFnZS1vcmllbnRhdGlvbjowZGVnIWltcG9ydGFudDtcIidcbiAgICAgICAgKTtcblxuICAgICAgICBlbXB0eShlbGVtZW50KTtcbiAgICAgICAgYXBwZW5kQ2hpbGQoZWxlbWVudCwgaW1hZ2UpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlc2V0UHJldmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgZWFjaCh0aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcblxuICAgICAgICBzZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGRhdGEuaHRtbDtcbiAgICAgICAgcmVtb3ZlRGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHByZXZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gX3RoaXMuaW1hZ2VEYXRhO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGNyb3BCb3hEYXRhID0gX3RoaXMuY3JvcEJveERhdGE7XG4gICAgICB2YXIgY3JvcEJveFdpZHRoID0gY3JvcEJveERhdGEud2lkdGg7XG4gICAgICB2YXIgY3JvcEJveEhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICAgIHZhciB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0IC0gaW1hZ2VEYXRhLmxlZnQ7XG4gICAgICB2YXIgdG9wID0gY3JvcEJveERhdGEudG9wIC0gY2FudmFzRGF0YS50b3AgLSBpbWFnZURhdGEudG9wO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybShpbWFnZURhdGEpO1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSB7XG4gICAgICAgICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIG1zVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICghX3RoaXMuY3JvcHBlZCB8fCBfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldFN0eWxlKF90aGlzLmltYWdlMiwgZXh0ZW5kKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgbWFyZ2luTGVmdDogLWxlZnQsXG4gICAgICAgIG1hcmdpblRvcDogLXRvcFxuICAgICAgfSwgdHJhbnNmb3JtcykpO1xuXG4gICAgICBlYWNoKF90aGlzLnByZXZpZXdzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsV2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBkYXRhLmhlaWdodDtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gb3JpZ2luYWxXaWR0aDtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuXG4gICAgICAgIGlmIChjcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICByYXRpbyA9IG9yaWdpbmFsV2lkdGggLyBjcm9wQm94V2lkdGg7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gY3JvcEJveEhlaWdodCAqIHJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyb3BCb3hIZWlnaHQgJiYgbmV3SGVpZ2h0ID4gb3JpZ2luYWxIZWlnaHQpIHtcbiAgICAgICAgICByYXRpbyA9IG9yaWdpbmFsSGVpZ2h0IC8gY3JvcEJveEhlaWdodDtcbiAgICAgICAgICBuZXdXaWR0aCA9IGNyb3BCb3hXaWR0aCAqIHJhdGlvO1xuICAgICAgICAgIG5ld0hlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRTdHlsZShnZXRCeVRhZyhlbGVtZW50LCAnaW1nJylbMF0sIGV4dGVuZCh7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoICogcmF0aW8sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiByYXRpbyxcbiAgICAgICAgICBtYXJnaW5MZWZ0OiAtbGVmdCAqIHJhdGlvLFxuICAgICAgICAgIG1hcmdpblRvcDogLXRvcCAqIHJhdGlvXG4gICAgICAgIH0sIHRyYW5zZm9ybXMpKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIGNyb3BwZXIgPSBfdGhpcy5jcm9wcGVyO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BzdGFydCkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwgb3B0aW9ucy5jcm9wc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3Btb3ZlKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCBvcHRpb25zLmNyb3BlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3ApKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1AsIG9wdGlvbnMuY3JvcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuem9vbSkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfTU9VU0VfRE9XTiwgKF90aGlzLl9jcm9wU3RhcnQgPSBwcm94eShfdGhpcy5jcm9wU3RhcnQsIF90aGlzKSkpO1xuXG4gICAgICBpZiAob3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PbldoZWVsKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGNyb3BwZXIsIEVWRU5UX1dIRUVMLCAoX3RoaXMuX3doZWVsID0gcHJveHkoX3RoaXMud2hlZWwsIF90aGlzKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b2dnbGVEcmFnTW9kZU9uRGJsY2xpY2spIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfREJMQ0xJQ0ssIChfdGhpcy5fZGJsY2xpY2sgPSBwcm94eShfdGhpcy5kYmxjbGljaywgX3RoaXMpKSk7XG4gICAgICB9XG5cbiAgICAgIGFkZExpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9NT1VTRV9NT1ZFLCAoX3RoaXMuX2Nyb3BNb3ZlID0gcHJveHkoX3RoaXMuY3JvcE1vdmUsIF90aGlzKSkpO1xuICAgICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX01PVVNFX1VQLCAoX3RoaXMuX2Nyb3BFbmQgPSBwcm94eShfdGhpcy5jcm9wRW5kLCBfdGhpcykpKTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICBhZGRMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgKF90aGlzLl9yZXNpemUgPSBwcm94eShfdGhpcy5yZXNpemUsIF90aGlzKSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmVsZW1lbnQ7XG4gICAgICB2YXIgY3JvcHBlciA9IF90aGlzLmNyb3BwZXI7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcHN0YXJ0KSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX1NUQVJULCBvcHRpb25zLmNyb3BzdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcG1vdmUpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfTU9WRSwgb3B0aW9ucy5jcm9wbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcGVuZCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9FTkQsIG9wdGlvbnMuY3JvcGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuY3JvcCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUCwgb3B0aW9ucy5jcm9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9aT09NLCBvcHRpb25zLnpvb20pO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9NT1VTRV9ET1dOLCBfdGhpcy5fY3JvcFN0YXJ0KTtcblxuICAgICAgaWYgKG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25XaGVlbCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9XSEVFTCwgX3RoaXMuX3doZWVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGNyb3BwZXIsIEVWRU5UX0RCTENMSUNLLCBfdGhpcy5fZGJsY2xpY2spO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfTU9VU0VfTU9WRSwgX3RoaXMuX2Nyb3BNb3ZlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9NT1VTRV9VUCwgX3RoaXMuX2Nyb3BFbmQpO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCBfdGhpcy5fcmVzaXplKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHJlc3RvcmUgPSBfdGhpcy5vcHRpb25zLnJlc3RvcmU7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuY29udGFpbmVyO1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGEgPSBfdGhpcy5jb250YWluZXJEYXRhO1xuICAgICAgdmFyIGNhbnZhc0RhdGE7XG4gICAgICB2YXIgY3JvcEJveERhdGE7XG4gICAgICB2YXIgcmF0aW87XG5cbiAgICAgIC8vIENoZWNrIGBjb250YWluZXJgIGlzIG5lY2Vzc2FyeSBmb3IgSUU4XG4gICAgICBpZiAoX3RoaXMuZGlzYWJsZWQgfHwgIWNvbnRhaW5lckRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByYXRpbyA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIGNvbnRhaW5lckRhdGEud2lkdGg7XG5cbiAgICAgIC8vIFJlc2l6ZSB3aGVuIHdpZHRoIGNoYW5nZWQgb3IgaGVpZ2h0IGNoYW5nZWRcbiAgICAgIGlmIChyYXRpbyAhPT0gMSB8fCBjb250YWluZXIub2Zmc2V0SGVpZ2h0ICE9PSBjb250YWluZXJEYXRhLmhlaWdodCkge1xuICAgICAgICBpZiAocmVzdG9yZSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEgPSBfdGhpcy5nZXRDYW52YXNEYXRhKCk7XG4gICAgICAgICAgY3JvcEJveERhdGEgPSBfdGhpcy5nZXRDcm9wQm94RGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICBfdGhpcy5zZXRDYW52YXNEYXRhKGVhY2goY2FudmFzRGF0YSwgZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICAgIGNhbnZhc0RhdGFbaV0gPSBuICogcmF0aW87XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzLnNldENyb3BCb3hEYXRhKGVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YVtpXSA9IG4gKiByYXRpbztcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldERyYWdNb2RlKGhhc0NsYXNzKF90aGlzLmRyYWdCb3gsIENMQVNTX0NST1ApID8gQUNUSU9OX01PVkUgOiBBQ1RJT05fQ1JPUCk7XG4gICAgfSxcblxuICAgIHdoZWVsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZSA9IGdldEV2ZW50KGV2ZW50KTtcbiAgICAgIHZhciByYXRpbyA9IE51bWJlcihfdGhpcy5vcHRpb25zLndoZWVsWm9vbVJhdGlvKSB8fCAwLjE7XG4gICAgICB2YXIgZGVsdGEgPSAxO1xuXG4gICAgICBpZiAoX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgLy8gTGltaXQgd2hlZWwgc3BlZWQgdG8gcHJldmVudCB6b29tIHRvbyBmYXN0ICgjMjEpXG4gICAgICBpZiAoX3RoaXMud2hlZWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy53aGVlbGluZyA9IHRydWU7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgICAgfSwgNTApO1xuXG4gICAgICBpZiAoZS5kZWx0YVkpIHtcbiAgICAgICAgZGVsdGEgPSBlLmRlbHRhWSA+IDAgPyAxIDogLTE7XG4gICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YSkge1xuICAgICAgICBkZWx0YSA9IC1lLndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICB9IGVsc2UgaWYgKGUuZGV0YWlsKSB7XG4gICAgICAgIGRlbHRhID0gZS5kZXRhaWwgPiAwID8gMSA6IC0xO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy56b29tKC1kZWx0YSAqIHJhdGlvLCBlKTtcbiAgICB9LFxuXG4gICAgY3JvcFN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgZSA9IGdldEV2ZW50KGV2ZW50KTtcbiAgICAgIHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgdmFyIHRvdWNoZXNMZW5ndGg7XG4gICAgICB2YXIgdG91Y2g7XG4gICAgICB2YXIgYWN0aW9uO1xuXG4gICAgICBpZiAoX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICB0b3VjaGVzTGVuZ3RoID0gdG91Y2hlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRvdWNoZXNMZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuem9vbWFibGUgJiYgb3B0aW9ucy56b29tT25Ub3VjaCAmJiB0b3VjaGVzTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0b3VjaCA9IHRvdWNoZXNbMV07XG4gICAgICAgICAgICBfdGhpcy5zdGFydFgyID0gdG91Y2gucGFnZVg7XG4gICAgICAgICAgICBfdGhpcy5zdGFydFkyID0gdG91Y2gucGFnZVk7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fWk9PTTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRvdWNoID0gdG91Y2hlc1swXTtcbiAgICAgIH1cblxuICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGdldERhdGEoZS50YXJnZXQsIERBVEFfQUNUSU9OKTtcblxuICAgICAgaWYgKFJFR0VYUF9BQ1RJT05TLnRlc3QoYWN0aW9uKSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2hFdmVudChfdGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX1NUQVJULCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICBfdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIF90aGlzLmNyb3BwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuc3RhcnRYID0gdG91Y2ggPyB0b3VjaC5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgIF90aGlzLnN0YXJ0WSA9IHRvdWNoID8gdG91Y2gucGFnZVkgOiBlLnBhZ2VZO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09IEFDVElPTl9DUk9QKSB7XG4gICAgICAgICAgX3RoaXMuY3JvcHBpbmcgPSB0cnVlO1xuICAgICAgICAgIGFkZENsYXNzKF90aGlzLmRyYWdCb3gsIENMQVNTX01PREFMKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcm9wTW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGUgPSBnZXRFdmVudChldmVudCk7XG4gICAgICB2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgICAgIHZhciBhY3Rpb24gPSBfdGhpcy5hY3Rpb247XG4gICAgICB2YXIgdG91Y2hlc0xlbmd0aDtcbiAgICAgIHZhciB0b3VjaDtcblxuICAgICAgaWYgKF90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgdG91Y2hlc0xlbmd0aCA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0b3VjaGVzTGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uVG91Y2ggJiYgdG91Y2hlc0xlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdG91Y2ggPSB0b3VjaGVzWzFdO1xuICAgICAgICAgICAgX3RoaXMuZW5kWDIgPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgICAgIF90aGlzLmVuZFkyID0gdG91Y2gucGFnZVk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b3VjaCA9IHRvdWNoZXNbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoX3RoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9NT1ZFLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICBfdGhpcy5lbmRYID0gdG91Y2ggPyB0b3VjaC5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgIF90aGlzLmVuZFkgPSB0b3VjaCA/IHRvdWNoLnBhZ2VZIDogZS5wYWdlWTtcblxuICAgICAgICBfdGhpcy5jaGFuZ2UoZS5zaGlmdEtleSwgYWN0aW9uID09PSBBQ1RJT05fWk9PTSA/IGUgOiBudWxsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JvcEVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGUgPSBnZXRFdmVudChldmVudCk7XG4gICAgICB2YXIgYWN0aW9uID0gX3RoaXMuYWN0aW9uO1xuXG4gICAgICBpZiAoX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgIGlmIChfdGhpcy5jcm9wcGluZykge1xuICAgICAgICAgIF90aGlzLmNyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoX3RoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwsIF90aGlzLmNyb3BwZWQgJiYgb3B0aW9ucy5tb2RhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hY3Rpb24gPSAnJztcblxuICAgICAgICBkaXNwYXRjaEV2ZW50KF90aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hhbmdlOiBmdW5jdGlvbiAoc2hpZnRLZXksIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvO1xuICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLmFjdGlvbjtcbiAgICAgIHZhciBjb250YWluZXJEYXRhID0gX3RoaXMuY29udGFpbmVyRGF0YTtcbiAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IF90aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIHdpZHRoID0gY3JvcEJveERhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICB2YXIgbWluTGVmdCA9IDA7XG4gICAgICB2YXIgbWluVG9wID0gMDtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgcmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgdmFyIHJhbmdlO1xuXG4gICAgICAvLyBMb2NraW5nIGFzcGVjdCByYXRpbyBpbiBcImZyZWUgbW9kZVwiIGJ5IGhvbGRpbmcgc2hpZnQga2V5XG4gICAgICBpZiAoIWFzcGVjdFJhdGlvICYmIHNoaWZ0S2V5KSB7XG4gICAgICAgIGFzcGVjdFJhdGlvID0gd2lkdGggJiYgaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMubGltaXRlZCkge1xuICAgICAgICBtaW5MZWZ0ID0gY3JvcEJveERhdGEubWluTGVmdDtcbiAgICAgICAgbWluVG9wID0gY3JvcEJveERhdGEubWluVG9wO1xuICAgICAgICBtYXhXaWR0aCA9IG1pbkxlZnQgKyBtaW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCk7XG4gICAgICAgIG1heEhlaWdodCA9IG1pblRvcCArIG1pbihjb250YWluZXJEYXRhLmhlaWdodCwgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJhbmdlID0ge1xuICAgICAgICB4OiBfdGhpcy5lbmRYIC0gX3RoaXMuc3RhcnRYLFxuICAgICAgICB5OiBfdGhpcy5lbmRZIC0gX3RoaXMuc3RhcnRZXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcmFuZ2UuWCA9IHJhbmdlLnkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgcmFuZ2UuWSA9IHJhbmdlLnggLyBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgLy8gTW92ZSBjcm9wIGJveFxuICAgICAgICBjYXNlIEFDVElPTl9BTEw6XG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBjcm9wIGJveFxuICAgICAgICBjYXNlIEFDVElPTl9FQVNUOlxuICAgICAgICAgIGlmIChyYW5nZS54ID49IDAgJiYgKHJpZ2h0ID49IG1heFdpZHRoIHx8IGFzcGVjdFJhdGlvICYmXG4gICAgICAgICAgICAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcblxuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcblxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIHRvcCAtPSByYW5nZS5ZIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSDpcbiAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwICYmICh0b3AgPD0gbWluVG9wIHx8IGFzcGVjdFJhdGlvICYmXG4gICAgICAgICAgICAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcblxuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG5cbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLlggLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEg7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1dFU1Q6XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGFzcGVjdFJhdGlvICYmXG4gICAgICAgICAgICAodG9wIDw9IG1pblRvcCB8fCBib3R0b20gPj0gbWF4SGVpZ2h0KSkpIHtcblxuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG5cbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB0b3AgKz0gcmFuZ2UuWSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fU09VVEg6XG4gICAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCAmJiAoYm90dG9tID49IG1heEhlaWdodCB8fCBhc3BlY3RSYXRpbyAmJlxuICAgICAgICAgICAgKGxlZnQgPD0gbWluTGVmdCB8fCByaWdodCA+PSBtYXhXaWR0aCkpKSB7XG5cbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgbGVmdCAtPSByYW5nZS5YIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIO1xuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSF9FQVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCByaWdodCA+PSBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPD0gMCAmJiB0b3AgPD0gbWluVG9wKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2UueSA8PSAwKSB7XG4gICAgICAgICAgICAgIGlmICh0b3AgPiBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9OT1JUSF9XRVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCBsZWZ0IDw9IG1pbkxlZnQpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgbGVmdCArPSByYW5nZS5YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChsZWZ0ID4gbWluTGVmdCkge1xuICAgICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPD0gMCAmJiB0b3AgPD0gbWluVG9wKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xuICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfRUFTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1NPVVRIX1dFU1Q6XG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwICYmIChsZWZ0IDw9IG1pbkxlZnQgfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS54IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA+PSAwICYmIGJvdHRvbSA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPj0gMCkge1xuICAgICAgICAgICAgICBpZiAoYm90dG9tIDwgbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3aWR0aCA8IDAgJiYgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfRUFTVDtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSF9FQVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChib3R0b20gPCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9XRVNUO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX0VBU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIE1vdmUgY2FudmFzXG4gICAgICAgIGNhc2UgQUNUSU9OX01PVkU6XG4gICAgICAgICAgX3RoaXMubW92ZShyYW5nZS54LCByYW5nZS55KTtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gWm9vbSBjYW52YXNcbiAgICAgICAgY2FzZSBBQ1RJT05fWk9PTTpcbiAgICAgICAgICBfdGhpcy56b29tKChmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciB6MSA9IHNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgICAgICAgdmFyIHoyID0gc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cbiAgICAgICAgICAgIHJldHVybiAoejIgLSB6MSkgLyB6MTtcbiAgICAgICAgICB9KShcbiAgICAgICAgICAgIGFicyhfdGhpcy5zdGFydFggLSBfdGhpcy5zdGFydFgyKSxcbiAgICAgICAgICAgIGFicyhfdGhpcy5zdGFydFkgLSBfdGhpcy5zdGFydFkyKSxcbiAgICAgICAgICAgIGFicyhfdGhpcy5lbmRYIC0gX3RoaXMuZW5kWDIpLFxuICAgICAgICAgICAgYWJzKF90aGlzLmVuZFkgLSBfdGhpcy5lbmRZMilcbiAgICAgICAgICApLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICBfdGhpcy5zdGFydFgyID0gX3RoaXMuZW5kWDI7XG4gICAgICAgICAgX3RoaXMuc3RhcnRZMiA9IF90aGlzLmVuZFkyO1xuICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBDcmVhdGUgY3JvcCBib3hcbiAgICAgICAgY2FzZSBBQ1RJT05fQ1JPUDpcbiAgICAgICAgICBpZiAoIXJhbmdlLnggfHwgIXJhbmdlLnkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9mZnNldCA9IGdldE9mZnNldChfdGhpcy5jcm9wcGVyKTtcbiAgICAgICAgICBsZWZ0ID0gX3RoaXMuc3RhcnRYIC0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgdG9wID0gX3RoaXMuc3RhcnRZIC0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICB3aWR0aCA9IGNyb3BCb3hEYXRhLm1pbldpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IGNyb3BCb3hEYXRhLm1pbkhlaWdodDtcblxuICAgICAgICAgIGlmIChyYW5nZS54ID4gMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfRUFTVCA6IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueCA8IDApIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICBhY3Rpb24gPSByYW5nZS55ID4gMCA/IEFDVElPTl9TT1VUSF9XRVNUIDogQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlLnkgPCAwKSB7XG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNob3cgdGhlIGNyb3AgYm94IGlmIGlzIGhpZGRlblxuICAgICAgICAgIGlmICghX3RoaXMuY3JvcHBlZCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3RoaXMuY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcbiAgICAgICAgICAgIF90aGlzLmNyb3BwZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMubGltaXRlZCkge1xuICAgICAgICAgICAgICBfdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyYWJsZSkge1xuICAgICAgICBjcm9wQm94RGF0YS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBsZWZ0O1xuICAgICAgICBjcm9wQm94RGF0YS50b3AgPSB0b3A7XG4gICAgICAgIF90aGlzLmFjdGlvbiA9IGFjdGlvbjtcblxuICAgICAgICBfdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlXG4gICAgICBfdGhpcy5zdGFydFggPSBfdGhpcy5lbmRYO1xuICAgICAgX3RoaXMuc3RhcnRZID0gX3RoaXMuZW5kWTtcbiAgICB9LFxuXG4gICAgLy8gU2hvdyB0aGUgY3JvcCBib3ggbWFudWFsbHlcbiAgICBjcm9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoX3RoaXMuYnVpbHQgJiYgIV90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGlmICghX3RoaXMuY3JvcHBlZCkge1xuICAgICAgICAgIF90aGlzLmNyb3BwZWQgPSB0cnVlO1xuICAgICAgICAgIF90aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLm1vZGFsKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhfdGhpcy5kcmFnQm94LCBDTEFTU19NT0RBTCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoX3RoaXMuY3JvcEJveCwgQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldENyb3BCb3hEYXRhKF90aGlzLmluaXRpYWxDcm9wQm94RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVzZXQgdGhlIGltYWdlIGFuZCBjcm9wIGJveCB0byB0aGVpciBpbml0aWFsIHN0YXRlc1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoX3RoaXMuYnVpbHQgJiYgIV90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIF90aGlzLmltYWdlRGF0YSA9IGV4dGVuZCh7fSwgX3RoaXMuaW5pdGlhbEltYWdlRGF0YSk7XG4gICAgICAgIF90aGlzLmNhbnZhc0RhdGEgPSBleHRlbmQoe30sIF90aGlzLmluaXRpYWxDYW52YXNEYXRhKTtcbiAgICAgICAgX3RoaXMuY3JvcEJveERhdGEgPSBleHRlbmQoe30sIF90aGlzLmluaXRpYWxDcm9wQm94RGF0YSk7XG5cbiAgICAgICAgX3RoaXMucmVuZGVyQ2FudmFzKCk7XG5cbiAgICAgICAgaWYgKF90aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhciB0aGUgY3JvcCBib3hcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKF90aGlzLmNyb3BwZWQgJiYgIV90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGV4dGVuZChfdGhpcy5jcm9wQm94RGF0YSwge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5jcm9wcGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlbmRlckNyb3BCb3goKTtcblxuICAgICAgICBfdGhpcy5saW1pdENhbnZhcygpO1xuXG4gICAgICAgIC8vIFJlbmRlciBjYW52YXMgYWZ0ZXIgY3JvcCBib3ggcmVuZGVyZWRcbiAgICAgICAgX3RoaXMucmVuZGVyQ2FudmFzKCk7XG5cbiAgICAgICAgcmVtb3ZlQ2xhc3MoX3RoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xuICAgICAgICBhZGRDbGFzcyhfdGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIGltYWdlJ3Mgc3JjIGFuZCByZWJ1aWxkIHRoZSBjcm9wcGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbmx5Q29sb3JDaGFuZ2VkIChvcHRpb25hbClcbiAgICAgKi9cbiAgICByZXBsYWNlOiBmdW5jdGlvbiAodXJsLCBvbmx5Q29sb3JDaGFuZ2VkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIV90aGlzLmRpc2FibGVkICYmIHVybCkge1xuICAgICAgICBpZiAoX3RoaXMuaXNJbWcpIHtcbiAgICAgICAgICBfdGhpcy5lbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbmx5Q29sb3JDaGFuZ2VkKSB7XG4gICAgICAgICAgX3RoaXMudXJsID0gdXJsO1xuICAgICAgICAgIF90aGlzLmltYWdlLnNyYyA9IHVybDtcblxuICAgICAgICAgIGlmIChfdGhpcy5idWlsdCkge1xuICAgICAgICAgICAgX3RoaXMuaW1hZ2UyLnNyYyA9IHVybDtcblxuICAgICAgICAgICAgZWFjaChfdGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2V0QnlUYWcoZWxlbWVudCwgJ2ltZycpWzBdLnNyYyA9IHVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNJbWcpIHtcbiAgICAgICAgICAgIF90aGlzLnJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBkYXRhXG4gICAgICAgICAgX3RoaXMub3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICBfdGhpcy5sb2FkKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFbmFibGUgKHVuZnJlZXplKSB0aGUgY3JvcHBlclxuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKF90aGlzLmJ1aWx0KSB7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZUNsYXNzKF90aGlzLmNyb3BwZXIsIENMQVNTX0RJU0FCTEVEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIChmcmVlemUpIHRoZSBjcm9wcGVyXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKF90aGlzLmJ1aWx0KSB7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYWRkQ2xhc3MoX3RoaXMuY3JvcHBlciwgQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhlIGNyb3BwZXIgYW5kIHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW1hZ2VcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIGltYWdlID0gX3RoaXMuaW1hZ2U7XG5cbiAgICAgIGlmIChfdGhpcy5yZWFkeSkge1xuICAgICAgICBpZiAoX3RoaXMuaXNJbWcgJiYgX3RoaXMucmVwbGFjZWQpIHtcbiAgICAgICAgICBlbGVtZW50LnNyYyA9IF90aGlzLm9yaWdpbmFsVXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMudW5idWlsZCgpO1xuICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLmlzSW1nKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfTE9BRCwgX3RoaXMuc3RhcnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgTkFNRVNQQUNFKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjYW52YXMgd2l0aCByZWxhdGl2ZSBvZmZzZXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIChvcHRpb25hbClcbiAgICAgKi9cbiAgICBtb3ZlOiBmdW5jdGlvbiAob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcblxuICAgICAgcmV0dXJuIF90aGlzLm1vdmVUbyhcbiAgICAgICAgaXNVbmRlZmluZWQob2Zmc2V0WCkgPyBvZmZzZXRYIDogY2FudmFzRGF0YS5sZWZ0ICsgTnVtYmVyKG9mZnNldFgpLFxuICAgICAgICBpc1VuZGVmaW5lZChvZmZzZXRZKSA/IG9mZnNldFkgOiBjYW52YXNEYXRhLnRvcCArIE51bWJlcihvZmZzZXRZKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IChvcHRpb25hbClcbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgXCJ5XCIgaXMgbm90IHByZXNlbnQsIGl0cyBkZWZhdWx0IHZhbHVlIGlzIFwieFwiXG4gICAgICBpZiAoaXNVbmRlZmluZWQoeSkpIHtcbiAgICAgICAgeSA9IHg7XG4gICAgICB9XG5cbiAgICAgIHggPSBOdW1iZXIoeCk7XG4gICAgICB5ID0gTnVtYmVyKHkpO1xuXG4gICAgICBpZiAoX3RoaXMuYnVpbHQgJiYgIV90aGlzLmRpc2FibGVkICYmIF90aGlzLm9wdGlvbnMubW92YWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSB4O1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgPSB5O1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSBjYW52YXMgd2l0aCBhIHJlbGF0aXZlIHJhdGlvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBfb3JpZ2luYWxFdmVudCAocHJpdmF0ZSlcbiAgICAgKi9cbiAgICB6b29tOiBmdW5jdGlvbiAocmF0aW8sIF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuXG4gICAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XG5cbiAgICAgIGlmIChyYXRpbyA8IDApIHtcbiAgICAgICAgcmF0aW8gPSAxIC8gKDEgLSByYXRpbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXRpbyA9IDEgKyByYXRpbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLnpvb21UbyhjYW52YXNEYXRhLndpZHRoICogcmF0aW8gLyBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCwgX29yaWdpbmFsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoZSBjYW52YXMgdG8gYW4gYWJzb2x1dGUgcmF0aW9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IChwcml2YXRlKVxuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24gKHJhdGlvLCBfb3JpZ2luYWxFdmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGNhbnZhc0RhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgbmF0dXJhbFdpZHRoID0gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciBuZXdXaWR0aDtcbiAgICAgIHZhciBuZXdIZWlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgdmFyIGNlbnRlcjtcblxuICAgICAgcmF0aW8gPSBOdW1iZXIocmF0aW8pO1xuXG4gICAgICBpZiAocmF0aW8gPj0gMCAmJiBfdGhpcy5idWlsdCAmJiAhX3RoaXMuZGlzYWJsZWQgJiYgb3B0aW9ucy56b29tYWJsZSkge1xuICAgICAgICBuZXdXaWR0aCA9IG5hdHVyYWxXaWR0aCAqIHJhdGlvO1xuICAgICAgICBuZXdIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0ICogcmF0aW87XG5cbiAgICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoX3RoaXMuZWxlbWVudCwgRVZFTlRfWk9PTSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIG9sZFJhdGlvOiB3aWR0aCAvIG5hdHVyYWxXaWR0aCxcbiAgICAgICAgICByYXRpbzogbmV3V2lkdGggLyBuYXR1cmFsV2lkdGhcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gZ2V0T2Zmc2V0KF90aGlzLmNyb3BwZXIpO1xuICAgICAgICAgIGNlbnRlciA9IF9vcmlnaW5hbEV2ZW50LnRvdWNoZXMgPyBnZXRUb3VjaGVzQ2VudGVyKF9vcmlnaW5hbEV2ZW50LnRvdWNoZXMpIDoge1xuICAgICAgICAgICAgcGFnZVg6IF9vcmlnaW5hbEV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IF9vcmlnaW5hbEV2ZW50LnBhZ2VZXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFpvb20gZnJvbSB0aGUgdHJpZ2dlcmluZyBwb2ludCBvZiB0aGUgZXZlbnRcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKFxuICAgICAgICAgICAgKChjZW50ZXIucGFnZVggLSBvZmZzZXQubGVmdCkgLSBjYW52YXNEYXRhLmxlZnQpIC8gd2lkdGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhbnZhc0RhdGEudG9wIC09IChuZXdIZWlnaHQgLSBoZWlnaHQpICogKFxuICAgICAgICAgICAgKChjZW50ZXIucGFnZVkgLSBvZmZzZXQudG9wKSAtIGNhbnZhc0RhdGEudG9wKSAvIGhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBab29tIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgY2FudmFzXG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0IC09IChuZXdXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgX3RoaXMucmVuZGVyQ2FudmFzKHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSBkZWdyZWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfdGhpcy5yb3RhdGVUbygoX3RoaXMuaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwKSArIE51bWJlcihkZWdyZWUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlIHRoZSBjYW52YXMgdG8gYW4gYWJzb2x1dGUgZGVncmVlXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbiNyb3RhdGUoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZVxuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbiAoZGVncmVlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBkZWdyZWUgPSBOdW1iZXIoZGVncmVlKTtcblxuICAgICAgaWYgKGlzTnVtYmVyKGRlZ3JlZSkgJiYgX3RoaXMuYnVpbHQgJiYgIV90aGlzLmRpc2FibGVkICYmIF90aGlzLm9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICAgIF90aGlzLmltYWdlRGF0YS5yb3RhdGUgPSBkZWdyZWUgJSAzNjA7XG4gICAgICAgIF90aGlzLnJvdGF0ZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGltYWdlXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbiNzY2FsZSgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWSAob3B0aW9uYWwpXG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uIChzY2FsZVgsIHNjYWxlWSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBpbWFnZURhdGEgPSBfdGhpcy5pbWFnZURhdGE7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiBcInNjYWxlWVwiIGlzIG5vdCBwcmVzZW50LCBpdHMgZGVmYXVsdCB2YWx1ZSBpcyBcInNjYWxlWFwiXG4gICAgICBpZiAoaXNVbmRlZmluZWQoc2NhbGVZKSkge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZVg7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IE51bWJlcihzY2FsZVgpO1xuICAgICAgc2NhbGVZID0gTnVtYmVyKHNjYWxlWSk7XG5cbiAgICAgIGlmIChfdGhpcy5idWlsdCAmJiAhX3RoaXMuZGlzYWJsZWQgJiYgX3RoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NhbGVYKSkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoc2NhbGVZKSkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIF90aGlzLnJlbmRlckltYWdlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGFic2Npc3NhIG9mIHRoZSBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqL1xuICAgIHNjYWxlWDogZnVuY3Rpb24gKHNjYWxlWCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzY2FsZVkgPSBfdGhpcy5pbWFnZURhdGEuc2NhbGVZO1xuXG4gICAgICByZXR1cm4gX3RoaXMuc2NhbGUoc2NhbGVYLCBpc051bWJlcihzY2FsZVkpID8gc2NhbGVZIDogMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBvcmRpbmF0ZSBvZiB0aGUgaW1hZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKi9cbiAgICBzY2FsZVk6IGZ1bmN0aW9uIChzY2FsZVkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgc2NhbGVYID0gX3RoaXMuaW1hZ2VEYXRhLnNjYWxlWDtcblxuICAgICAgcmV0dXJuIF90aGlzLnNjYWxlKGlzTnVtYmVyKHNjYWxlWCkgPyBzY2FsZVggOiAxLCBzY2FsZVkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhIChiYXNlIG9uIHRoZSBvcmlnaW5hbCBpbWFnZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcm91bmRlZCAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gKHJvdW5kZWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gX3RoaXMuaW1hZ2VEYXRhO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGNyb3BCb3hEYXRhID0gX3RoaXMuY3JvcEJveERhdGE7XG4gICAgICB2YXIgcmF0aW87XG4gICAgICB2YXIgZGF0YTtcblxuICAgICAgaWYgKF90aGlzLmJ1aWx0ICYmIF90aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICB4OiBjcm9wQm94RGF0YS5sZWZ0IC0gY2FudmFzRGF0YS5sZWZ0LFxuICAgICAgICAgIHk6IGNyb3BCb3hEYXRhLnRvcCAtIGNhbnZhc0RhdGEudG9wLFxuICAgICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHJhdGlvID0gaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aDtcblxuICAgICAgICBlYWNoKGRhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgbiA9IG4gLyByYXRpbztcbiAgICAgICAgICBkYXRhW2ldID0gcm91bmRlZCA/IHJvdW5kKG4pIDogbjtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgZGF0YS5yb3RhdGUgPSBpbWFnZURhdGEucm90YXRlIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNjYWxhYmxlKSB7XG4gICAgICAgIGRhdGEuc2NhbGVYID0gaW1hZ2VEYXRhLnNjYWxlWCB8fCAxO1xuICAgICAgICBkYXRhLnNjYWxlWSA9IGltYWdlRGF0YS5zY2FsZVkgfHwgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3JvcHBlZCBhcmVhIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gX3RoaXMuaW1hZ2VEYXRhO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGNyb3BCb3hEYXRhID0ge307XG4gICAgICB2YXIgcm90YXRlZDtcbiAgICAgIHZhciBzY2FsZWQ7XG4gICAgICB2YXIgcmF0aW87XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmNhbGwoX3RoaXMuZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5idWlsdCAmJiAhX3RoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEucm90YXRlID0gZGF0YS5yb3RhdGU7XG4gICAgICAgICAgICBfdGhpcy5yb3RhdGVkID0gcm90YXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5zY2FsZVgpICYmIGRhdGEuc2NhbGVYICE9PSBpbWFnZURhdGEuc2NhbGVYKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gZGF0YS5zY2FsZVg7XG4gICAgICAgICAgICBzY2FsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc051bWJlcihkYXRhLnNjYWxlWSkgJiYgZGF0YS5zY2FsZVkgIT09IGltYWdlRGF0YS5zY2FsZVkpIHtcbiAgICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBkYXRhLnNjYWxlWTtcbiAgICAgICAgICAgIHNjYWxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0ZWQpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJDYW52YXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZWQpIHtcbiAgICAgICAgICBfdGhpcy5yZW5kZXJJbWFnZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmF0aW8gPSBpbWFnZURhdGEud2lkdGggLyBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLngpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEueCAqIHJhdGlvICsgY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEueSkpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnkgKiByYXRpbyArIGNhbnZhc0RhdGEudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoICogcmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5oZWlnaHQpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgKiByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldENyb3BCb3hEYXRhKGNyb3BCb3hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRhaW5lciBzaXplIGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGdldENvbnRhaW5lckRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfdGhpcy5idWlsdCA/IF90aGlzLmNvbnRhaW5lckRhdGEgOiB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbWFnZSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfdGhpcy5yZWFkeSA/IF90aGlzLmltYWdlRGF0YSA6IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBnZXRDYW52YXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSBfdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgaWYgKF90aGlzLmJ1aWx0KSB7XG4gICAgICAgIGVhY2goW1xuICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICduYXR1cmFsV2lkdGgnLFxuICAgICAgICAgICduYXR1cmFsSGVpZ2h0J1xuICAgICAgICBdLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FudmFzIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IF90aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBjYW52YXNEYXRhLmFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YS5jYWxsKF90aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuYnVpbHQgJiYgIV90aGlzLmRpc2FibGVkICYmIGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSBkYXRhLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBnZXRDcm9wQm94RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IF90aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIGRhdGE7XG5cbiAgICAgIGlmIChfdGhpcy5idWlsdCAmJiBfdGhpcy5jcm9wcGVkKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgbGVmdDogY3JvcEJveERhdGEubGVmdCxcbiAgICAgICAgICB0b3A6IGNyb3BCb3hEYXRhLnRvcCxcbiAgICAgICAgICB3aWR0aDogY3JvcEJveERhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjcm9wQm94RGF0YS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGEgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3JvcCBib3ggcG9zaXRpb24gYW5kIHNpemUgd2l0aCBuZXcgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzZXRDcm9wQm94RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgY3JvcEJveERhdGEgPSBfdGhpcy5jcm9wQm94RGF0YTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IF90aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICB2YXIgd2lkdGhDaGFuZ2VkO1xuICAgICAgdmFyIGhlaWdodENoYW5nZWQ7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmNhbGwoX3RoaXMuZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5idWlsdCAmJiBfdGhpcy5jcm9wcGVkICYmICFfdGhpcy5kaXNhYmxlZCAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gZGF0YS5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEudG9wKSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGRhdGEudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSB7XG4gICAgICAgICAgd2lkdGhDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBjcm9wQm94RGF0YS53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5oZWlnaHQpKSB7XG4gICAgICAgICAgaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAod2lkdGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgY2FudmFzIGRyYXduIHRoZSBjcm9wcGVkIGltYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgICAqL1xuICAgIGdldENyb3BwZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9yaWdpbmFsV2lkdGg7XG4gICAgICB2YXIgb3JpZ2luYWxIZWlnaHQ7XG4gICAgICB2YXIgY2FudmFzV2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0O1xuICAgICAgdmFyIHNjYWxlZFdpZHRoO1xuICAgICAgdmFyIHNjYWxlZEhlaWdodDtcbiAgICAgIHZhciBzY2FsZWRSYXRpbztcbiAgICAgIHZhciBhc3BlY3RSYXRpbztcbiAgICAgIHZhciBjYW52YXM7XG4gICAgICB2YXIgY29udGV4dDtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICBpZiAoIV90aGlzLmJ1aWx0IHx8ICFfdGhpcy5jcm9wcGVkIHx8ICFTVVBQT1JUX0NBTlZBUykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBfdGhpcy5nZXREYXRhKCk7XG4gICAgICBvcmlnaW5hbFdpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgIG9yaWdpbmFsSGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICBhc3BlY3RSYXRpbyA9IG9yaWdpbmFsV2lkdGggLyBvcmlnaW5hbEhlaWdodDtcblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgc2NhbGVkV2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICBzY2FsZWRIZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcblxuICAgICAgICBpZiAoc2NhbGVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRIZWlnaHQgPSBzY2FsZWRXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIHNjYWxlZFJhdGlvID0gc2NhbGVkV2lkdGggLyBvcmlnaW5hbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZEhlaWdodCkge1xuICAgICAgICAgIHNjYWxlZFdpZHRoID0gc2NhbGVkSGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgc2NhbGVkUmF0aW8gPSBzY2FsZWRIZWlnaHQgLyBvcmlnaW5hbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY2FudmFzIGVsZW1lbnQgd2lsbCB1c2UgYE1hdGguZmxvb3JgIG9uIGEgZmxvYXQgbnVtYmVyLCBzbyBmbG9vciBmaXJzdFxuICAgICAgY2FudmFzV2lkdGggPSBmbG9vcihzY2FsZWRXaWR0aCB8fCBvcmlnaW5hbFdpZHRoKTtcbiAgICAgIGNhbnZhc0hlaWdodCA9IGZsb29yKHNjYWxlZEhlaWdodCB8fCBvcmlnaW5hbEhlaWdodCk7XG5cbiAgICAgIGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBpZiAob3B0aW9ucy5maWxsQ29sb3IpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5kcmF3SW1hZ2VcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlLmFwcGx5KGNvbnRleHQsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBnZXRTb3VyY2VDYW52YXMoX3RoaXMuaW1hZ2UsIF90aGlzLmltYWdlRGF0YSk7XG4gICAgICAgIHZhciBzb3VyY2VXaWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICAgICAgdmFyIHNvdXJjZUhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNEYXRhID0gX3RoaXMuY2FudmFzRGF0YTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtzb3VyY2VdO1xuXG4gICAgICAgIC8vIFNvdXJjZSBjYW52YXNcbiAgICAgICAgdmFyIHNyY1ggPSBkYXRhLnggKyBjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCAqIChhYnMoZGF0YS5zY2FsZVggfHwgMSkgLSAxKSAvIDI7XG4gICAgICAgIHZhciBzcmNZID0gZGF0YS55ICsgY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0ICogKGFicyhkYXRhLnNjYWxlWSB8fCAxKSAtIDEpIC8gMjtcbiAgICAgICAgdmFyIHNyY1dpZHRoO1xuICAgICAgICB2YXIgc3JjSGVpZ2h0O1xuXG4gICAgICAgIC8vIERlc3RpbmF0aW9uIGNhbnZhc1xuICAgICAgICB2YXIgZHN0WDtcbiAgICAgICAgdmFyIGRzdFk7XG4gICAgICAgIHZhciBkc3RXaWR0aDtcbiAgICAgICAgdmFyIGRzdEhlaWdodDtcblxuICAgICAgICBpZiAoc3JjWCA8PSAtb3JpZ2luYWxXaWR0aCB8fCBzcmNYID4gc291cmNlV2lkdGgpIHtcbiAgICAgICAgICBzcmNYID0gc3JjV2lkdGggPSBkc3RYID0gZHN0V2lkdGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHNyY1ggPD0gMCkge1xuICAgICAgICAgIGRzdFggPSAtc3JjWDtcbiAgICAgICAgICBzcmNYID0gMDtcbiAgICAgICAgICBzcmNXaWR0aCA9IGRzdFdpZHRoID0gbWluKHNvdXJjZVdpZHRoLCBvcmlnaW5hbFdpZHRoICsgc3JjWCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjWCA8PSBzb3VyY2VXaWR0aCkge1xuICAgICAgICAgIGRzdFggPSAwO1xuICAgICAgICAgIHNyY1dpZHRoID0gZHN0V2lkdGggPSBtaW4ob3JpZ2luYWxXaWR0aCwgc291cmNlV2lkdGggLSBzcmNYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmNXaWR0aCA8PSAwIHx8IHNyY1kgPD0gLW9yaWdpbmFsSGVpZ2h0IHx8IHNyY1kgPiBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgICBzcmNZID0gc3JjSGVpZ2h0ID0gZHN0WSA9IGRzdEhlaWdodCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjWSA8PSAwKSB7XG4gICAgICAgICAgZHN0WSA9IC1zcmNZO1xuICAgICAgICAgIHNyY1kgPSAwO1xuICAgICAgICAgIHNyY0hlaWdodCA9IGRzdEhlaWdodCA9IG1pbihzb3VyY2VIZWlnaHQsIG9yaWdpbmFsSGVpZ2h0ICsgc3JjWSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjWSA8PSBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgICBkc3RZID0gMDtcbiAgICAgICAgICBzcmNIZWlnaHQgPSBkc3RIZWlnaHQgPSBtaW4ob3JpZ2luYWxIZWlnaHQsIHNvdXJjZUhlaWdodCAtIHNyY1kpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zLnB1c2goZmxvb3Ioc3JjWCksIGZsb29yKHNyY1kpLCBmbG9vcihzcmNXaWR0aCksIGZsb29yKHNyY0hlaWdodCkpO1xuXG4gICAgICAgIC8vIFNjYWxlIGRlc3RpbmF0aW9uIHNpemVzXG4gICAgICAgIGlmIChzY2FsZWRSYXRpbykge1xuICAgICAgICAgIGRzdFggKj0gc2NhbGVkUmF0aW87XG4gICAgICAgICAgZHN0WSAqPSBzY2FsZWRSYXRpbztcbiAgICAgICAgICBkc3RXaWR0aCAqPSBzY2FsZWRSYXRpbztcbiAgICAgICAgICBkc3RIZWlnaHQgKj0gc2NhbGVkUmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBcIkluZGV4U2l6ZUVycm9yXCIgaW4gSUUgYW5kIEZpcmVmb3hcbiAgICAgICAgaWYgKGRzdFdpZHRoID4gMCAmJiBkc3RIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2goZmxvb3IoZHN0WCksIGZsb29yKGRzdFkpLCBmbG9vcihkc3RXaWR0aCksIGZsb29yKGRzdEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH0pLmNhbGwoX3RoaXMpKTtcblxuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGNyb3AgYm94XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXNwZWN0UmF0aW9cbiAgICAgKi9cbiAgICBzZXRBc3BlY3RSYXRpbzogZnVuY3Rpb24gKGFzcGVjdFJhdGlvKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAoIV90aGlzLmRpc2FibGVkICYmICFpc1VuZGVmaW5lZChhc3BlY3RSYXRpbykpIHtcblxuICAgICAgICAvLyAwIC0+IE5hTlxuICAgICAgICBvcHRpb25zLmFzcGVjdFJhdGlvID0gbWF4KDAsIGFzcGVjdFJhdGlvKSB8fCBOYU47XG5cbiAgICAgICAgaWYgKF90aGlzLmJ1aWx0KSB7XG4gICAgICAgICAgX3RoaXMuaW5pdENyb3BCb3goKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5jcm9wcGVkKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkcmFnIG1vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIChvcHRpb25hbClcbiAgICAgKi9cbiAgICBzZXREcmFnTW9kZTogZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgZHJhZ0JveCA9IF90aGlzLmRyYWdCb3g7XG4gICAgICB2YXIgZmFjZSA9IF90aGlzLmZhY2U7XG4gICAgICB2YXIgY3JvcHBhYmxlO1xuICAgICAgdmFyIG1vdmFibGU7XG5cbiAgICAgIGlmIChfdGhpcy5yZWFkeSAmJiAhX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgY3JvcHBhYmxlID0gbW9kZSA9PT0gQUNUSU9OX0NST1A7XG4gICAgICAgIG1vdmFibGUgPSBvcHRpb25zLm1vdmFibGUgJiYgbW9kZSA9PT0gQUNUSU9OX01PVkU7XG4gICAgICAgIG1vZGUgPSAoY3JvcHBhYmxlIHx8IG1vdmFibGUpID8gbW9kZSA6IEFDVElPTl9OT05FO1xuXG4gICAgICAgIHNldERhdGEoZHJhZ0JveCwgREFUQV9BQ1RJT04sIG1vZGUpO1xuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnQm94LCBDTEFTU19DUk9QLCBjcm9wcGFibGUpO1xuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnQm94LCBDTEFTU19NT1ZFLCBtb3ZhYmxlKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuY3JvcEJveE1vdmFibGUpIHtcblxuICAgICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBtb2RlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhmYWNlLCBDTEFTU19DUk9QLCBjcm9wcGFibGUpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gIH07XG5cbiAgQ3JvcHBlci5ERUZBVUxUUyA9IHtcblxuICAgIC8vIERlZmluZSB0aGUgdmlldyBtb2RlIG9mIHRoZSBjcm9wcGVyXG4gICAgdmlld01vZGU6IDAsIC8vIDAsIDEsIDIsIDNcblxuICAgIC8vIERlZmluZSB0aGUgZHJhZ2dpbmcgbW9kZSBvZiB0aGUgY3JvcHBlclxuICAgIGRyYWdNb2RlOiAnY3JvcCcsIC8vICdjcm9wJywgJ21vdmUnIG9yICdub25lJ1xuXG4gICAgLy8gRGVmaW5lIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGNyb3AgYm94XG4gICAgYXNwZWN0UmF0aW86IE5hTixcblxuICAgIC8vIEFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBjcm9wcGluZyByZXN1bHQgZGF0YVxuICAgIGRhdGE6IG51bGwsXG5cbiAgICAvLyBBIHNlbGVjdG9yIGZvciBhZGRpbmcgZXh0cmEgY29udGFpbmVycyB0byBwcmV2aWV3XG4gICAgcHJldmlldzogJycsXG5cbiAgICAvLyBSZS1yZW5kZXIgdGhlIGNyb3BwZXIgd2hlbiByZXNpemUgdGhlIHdpbmRvd1xuICAgIHJlc3BvbnNpdmU6IHRydWUsXG5cbiAgICAvLyBSZXN0b3JlIHRoZSBjcm9wcGVkIGFyZWEgYWZ0ZXIgcmVzaXplIHRoZSB3aW5kb3dcbiAgICByZXN0b3JlOiB0cnVlLFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgaW1hZ2UgaXMgYSBjcm9zcy1vcmlnaW4gaW1hZ2VcbiAgICBjaGVja0Nyb3NzT3JpZ2luOiB0cnVlLFxuXG4gICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgaW1hZ2UncyBFeGlmIE9yaWVudGF0aW9uIGluZm9ybWF0aW9uXG4gICAgY2hlY2tPcmllbnRhdGlvbjogdHJ1ZSxcblxuICAgIC8vIFNob3cgdGhlIGJsYWNrIG1vZGFsXG4gICAgbW9kYWw6IHRydWUsXG5cbiAgICAvLyBTaG93IHRoZSBkYXNoZWQgbGluZXMgZm9yIGd1aWRpbmdcbiAgICBndWlkZXM6IHRydWUsXG5cbiAgICAvLyBTaG93IHRoZSBjZW50ZXIgaW5kaWNhdG9yIGZvciBndWlkaW5nXG4gICAgY2VudGVyOiB0cnVlLFxuXG4gICAgLy8gU2hvdyB0aGUgd2hpdGUgbW9kYWwgdG8gaGlnaGxpZ2h0IHRoZSBjcm9wIGJveFxuICAgIGhpZ2hsaWdodDogdHJ1ZSxcblxuICAgIC8vIFNob3cgdGhlIGdyaWQgYmFja2dyb3VuZFxuICAgIGJhY2tncm91bmQ6IHRydWUsXG5cbiAgICAvLyBFbmFibGUgdG8gY3JvcCB0aGUgaW1hZ2UgYXV0b21hdGljYWxseSB3aGVuIGluaXRpYWxpemVcbiAgICBhdXRvQ3JvcDogdHJ1ZSxcblxuICAgIC8vIERlZmluZSB0aGUgcGVyY2VudGFnZSBvZiBhdXRvbWF0aWMgY3JvcHBpbmcgYXJlYSB3aGVuIGluaXRpYWxpemVzXG4gICAgYXV0b0Nyb3BBcmVhOiAwLjgsXG5cbiAgICAvLyBFbmFibGUgdG8gbW92ZSB0aGUgaW1hZ2VcbiAgICBtb3ZhYmxlOiB0cnVlLFxuXG4gICAgLy8gRW5hYmxlIHRvIHJvdGF0ZSB0aGUgaW1hZ2VcbiAgICByb3RhdGFibGU6IHRydWUsXG5cbiAgICAvLyBFbmFibGUgdG8gc2NhbGUgdGhlIGltYWdlXG4gICAgc2NhbGFibGU6IHRydWUsXG5cbiAgICAvLyBFbmFibGUgdG8gem9vbSB0aGUgaW1hZ2VcbiAgICB6b29tYWJsZTogdHJ1ZSxcblxuICAgIC8vIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZSBieSBkcmFnZ2luZyB0b3VjaFxuICAgIHpvb21PblRvdWNoOiB0cnVlLFxuXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlXG4gICAgem9vbU9uV2hlZWw6IHRydWUsXG5cbiAgICAvLyBEZWZpbmUgem9vbSByYXRpbyB3aGVuIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlXG4gICAgd2hlZWxab29tUmF0aW86IDAuMSxcblxuICAgIC8vIEVuYWJsZSB0byBtb3ZlIHRoZSBjcm9wIGJveFxuICAgIGNyb3BCb3hNb3ZhYmxlOiB0cnVlLFxuXG4gICAgLy8gRW5hYmxlIHRvIHJlc2l6ZSB0aGUgY3JvcCBib3hcbiAgICBjcm9wQm94UmVzaXphYmxlOiB0cnVlLFxuXG4gICAgLy8gVG9nZ2xlIGRyYWcgbW9kZSBiZXR3ZWVuIFwiY3JvcFwiIGFuZCBcIm1vdmVcIiB3aGVuIGNsaWNrIHR3aWNlIG9uIHRoZSBjcm9wcGVyXG4gICAgdG9nZ2xlRHJhZ01vZGVPbkRibGNsaWNrOiB0cnVlLFxuXG4gICAgLy8gU2l6ZSBsaW1pdGF0aW9uXG4gICAgbWluQ2FudmFzV2lkdGg6IDAsXG4gICAgbWluQ2FudmFzSGVpZ2h0OiAwLFxuICAgIG1pbkNyb3BCb3hXaWR0aDogMCxcbiAgICBtaW5Dcm9wQm94SGVpZ2h0OiAwLFxuICAgIG1pbkNvbnRhaW5lcldpZHRoOiAyMDAsXG4gICAgbWluQ29udGFpbmVySGVpZ2h0OiAxMDAsXG5cbiAgICAvLyBTaG9ydGN1dHMgb2YgZXZlbnRzXG4gICAgYnVpbGQ6IG51bGwsXG4gICAgYnVpbHQ6IG51bGwsXG4gICAgY3JvcHN0YXJ0OiBudWxsLFxuICAgIGNyb3Btb3ZlOiBudWxsLFxuICAgIGNyb3BlbmQ6IG51bGwsXG4gICAgY3JvcDogbnVsbCxcbiAgICB6b29tOiBudWxsXG4gIH07XG5cbiAgQ3JvcHBlci5URU1QTEFURSA9IChmdW5jdGlvbiAoc291cmNlLCB3b3Jkcykge1xuICAgIHdvcmRzID0gd29yZHMuc3BsaXQoJywnKTtcblxuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvXFxkKy9nLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIHdvcmRzW2ldO1xuICAgIH0pO1xuICB9KSgnPDAgNj1cIjUtY29udGFpbmVyXCI+PDAgNj1cIjUtd3JhcC05XCI+PDAgNj1cIjUtY2FudmFzXCI+PC8wPjwvMD48MCA2PVwiNS1kcmFnLTlcIj48LzA+PDAgNj1cIjUtY3JvcC05XCI+PDEgNj1cIjUtdmlldy05XCI+PC8xPjwxIDY9XCI1LTggOC1oXCI+PC8xPjwxIDY9XCI1LTggOC12XCI+PC8xPjwxIDY9XCI1LWNlbnRlclwiPjwvMT48MSA2PVwiNS1mYWNlXCI+PC8xPjwxIDY9XCI1LTcgNy1lXCIgMy0yPVwiZVwiPjwvMT48MSA2PVwiNS03IDctblwiIDMtMj1cIm5cIj48LzE+PDEgNj1cIjUtNyA3LXdcIiAzLTI9XCJ3XCI+PC8xPjwxIDY9XCI1LTcgNy1zXCIgMy0yPVwic1wiPjwvMT48MSA2PVwiNS00IDQtZVwiIDMtMj1cImVcIj48LzE+PDEgNj1cIjUtNCA0LW5cIiAzLTI9XCJuXCI+PC8xPjwxIDY9XCI1LTQgNC13XCIgMy0yPVwid1wiPjwvMT48MSA2PVwiNS00IDQtc1wiIDMtMj1cInNcIj48LzE+PDEgNj1cIjUtNCA0LW5lXCIgMy0yPVwibmVcIj48LzE+PDEgNj1cIjUtNCA0LW53XCIgMy0yPVwibndcIj48LzE+PDEgNj1cIjUtNCA0LXN3XCIgMy0yPVwic3dcIj48LzE+PDEgNj1cIjUtNCA0LXNlXCIgMy0yPVwic2VcIj48LzE+PC8wPjwvMD4nLCAnZGl2LHNwYW4sYWN0aW9uLGRhdGEscG9pbnQsY3JvcHBlcixjbGFzcyxsaW5lLGRhc2hlZCxib3gnKTtcblxuICAvKkNyb3BwZXIuVEVNUExBVEUgPSAoXG4gICAgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNvbnRhaW5lclwiPicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLXdyYXAtYm94XCI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jYW52YXNcIj48L2Rpdj4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1kcmFnLWJveFwiPjwvZGl2PicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNyb3AtYm94XCI+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImNyb3BwZXItdmlldy1ib3hcIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC1oXCI+PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtdlwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1jZW50ZXJcIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZmFjZVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtZVwiIGRhdGEtYWN0aW9uPVwiZVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtblwiIGRhdGEtYWN0aW9uPVwiblwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtd1wiIGRhdGEtYWN0aW9uPVwid1wiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtc1wiIGRhdGEtYWN0aW9uPVwic1wiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1lXCIgZGF0YS1hY3Rpb249XCJlXCI+PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW5cIiBkYXRhLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtd1wiIGRhdGEtYWN0aW9uPVwid1wiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zXCIgZGF0YS1hY3Rpb249XCJzXCI+PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LW5lXCIgZGF0YS1hY3Rpb249XCJuZVwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1ud1wiIGRhdGEtYWN0aW9uPVwibndcIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtc3dcIiBkYXRhLWFjdGlvbj1cInN3XCI+PC9zcGFuPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNlXCIgZGF0YS1hY3Rpb249XCJzZVwiPjwvc3Bhbj4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAnPC9kaXY+J1xuICApOyovXG5cbiAgdmFyIF9Dcm9wcGVyID0gd2luZG93LkNyb3BwZXI7XG5cbiAgQ3JvcHBlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5Dcm9wcGVyID0gX0Nyb3BwZXI7XG4gICAgcmV0dXJuIENyb3BwZXI7XG4gIH07XG5cbiAgQ3JvcHBlci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKENyb3BwZXIuREVGQVVMVFMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ2Nyb3BwZXInLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIENyb3BwZXI7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIW5vR2xvYmFsKSB7XG4gICAgd2luZG93LkNyb3BwZXIgPSBDcm9wcGVyO1xuICB9XG5cbiAgcmV0dXJuIENyb3BwZXI7XG5cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3JvcHBlcmpzL2Rpc3QvY3JvcHBlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9